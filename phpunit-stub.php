<?php
/** @noinspection ALL */

// @codingStandardsIgnoreFile

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsFalse extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsTrue extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use count;
    use is_array;
    use iterator_count;
    use sprintf;
    use Countable;
    use EmptyIterator;
    use Generator;
    use Iterator;
    use IteratorAggregate;
    use PHPUnit\Framework\Exception;
    use Traversable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    class Count extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var int
         */
        private $expectedCount;

        public function __construct(int $expected) {}

        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @throws Exception
         */
        protected function matches($other): bool {}

        /**
         * @throws Exception
         */
        protected function getCountOf($other): ?int {}

        /**
         * Returns the total number of iterations from a generator.
         * This will fully exhaust the generator.
         */
        protected function getCountOfGenerator(\Generator $generator): int {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class GreaterThan extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var float|int
         */
        private $value;

        /**
         * @param float|int $value
         */
        public function __construct($value) {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use count;
    use gettype;
    use sprintf;
    use strpos;
    use Countable;
    use EmptyIterator;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsEmpty extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class LessThan extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var float|int
         */
        private $value;

        /**
         * @param float|int $value
         */
        public function __construct($value) {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class SameSize extends \PHPUnit\Framework\Constraint\Count
    {
        public function __construct(\iterable $expected) {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_string;
    use sprintf;
    use strpos;
    use trim;
    use PHPUnit\Framework\ExpectationFailedException;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use SebastianBergmann\Comparator\Factory as ComparatorFactory;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsEqual extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var mixed
         */
        private $value;

        /**
         * @var float
         */
        private $delta;

        /**
         * @var bool
         */
        private $canonicalize;

        /**
         * @var bool
         */
        private $ignoreCase;

        public function __construct($value, float $delta = 0, bool $canonicalize = false, bool $ignoreCase = false) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         *
         * @return bool
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_string;
    use sprintf;
    use strpos;
    use trim;
    use PHPUnit\Framework\ExpectationFailedException;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use SebastianBergmann\Comparator\Factory as ComparatorFactory;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsEqualCanonicalizing extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var mixed
         */
        private $value;

        public function __construct($value) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_string;
    use sprintf;
    use strpos;
    use trim;
    use PHPUnit\Framework\ExpectationFailedException;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use SebastianBergmann\Comparator\Factory as ComparatorFactory;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsEqualIgnoringCase extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var mixed
         */
        private $value;

        public function __construct($value) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use trim;
    use PHPUnit\Framework\ExpectationFailedException;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use SebastianBergmann\Comparator\Factory as ComparatorFactory;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsEqualWithDelta extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var mixed
         */
        private $value;

        /**
         * @var float
         */
        private $delta;

        public function __construct($value, float $delta) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use get_class;
    use sprintf;
    use PHPUnit\Util\Filter;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $className;

        public function __construct(string $className) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ExceptionCode extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var int|string
         */
        private $expectedCode;

        /**
         * @param int|string $expected
         */
        public function __construct($expected) {}

        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param Throwable $other
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use strpos;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ExceptionMessage extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $expectedMessage;

        public function __construct(string $expected) {}

        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param Throwable $other
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use Exception;
    use PHPUnit\Util\RegularExpression as RegularExpressionUtil;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ExceptionMessageRegularExpression extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $expectedMessageRegExp;

        public function __construct(string $expected) {}

        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param \PHPUnit\Framework\Exception $other
         *
         * @throws Exception
         * @throws \PHPUnit\Framework\Exception
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_dir;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class DirectoryExists extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use file_exists;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class FileExists extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_readable;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsReadable extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_writable;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsWritable extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_finite;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsFinite extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_infinite;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsInfinite extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_nan;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsNan extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use get_class;
    use is_object;
    use sprintf;
    use PHPUnit\Framework\Exception;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    class ClassHasAttribute extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $attributeName;

        public function __construct(string $attributeName) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         */
        protected function failureDescription($other): string {}

        protected function attributeName(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use PHPUnit\Framework\Exception;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ClassHasStaticAttribute extends \PHPUnit\Framework\Constraint\ClassHasAttribute
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use get_class;
    use is_object;
    use PHPUnit\Framework\ActualValueIsNotAnObjectException;
    use PHPUnit\Framework\ComparisonMethodDoesNotAcceptParameterTypeException;
    use PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException;
    use PHPUnit\Framework\ComparisonMethodDoesNotDeclareExactlyOneParameterException;
    use PHPUnit\Framework\ComparisonMethodDoesNotDeclareParameterTypeException;
    use PHPUnit\Framework\ComparisonMethodDoesNotExistException;
    use ReflectionNamedType;
    use ReflectionObject;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ObjectEquals extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var object
         */
        private $expected;

        /**
         * @var string
         */
        private $method;

        public function __construct(object $object, string $method = 'equals') {}

        public function toString(): string {}

        /**
         * @throws ActualValueIsNotAnObjectException
         * @throws ComparisonMethodDoesNotExistException
         * @throws ComparisonMethodDoesNotDeclareBoolReturnTypeException
         * @throws ComparisonMethodDoesNotDeclareExactlyOneParameterException
         * @throws ComparisonMethodDoesNotDeclareParameterTypeException
         * @throws ComparisonMethodDoesNotAcceptParameterTypeException
         */
        protected function matches($other): bool {}

        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use ReflectionObject;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ObjectHasAttribute extends \PHPUnit\Framework\Constraint\ClassHasAttribute
    {
        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use array_map;
    use array_values;
    use count;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class BinaryOperator extends \PHPUnit\Framework\Constraint\Operator
    {
        /**
         * @var Constraint[]
         */
        private $constraints = [/** value is missing */];

        public static function fromConstraints(\PHPUnit\Framework\Constraint\Constraint ...$constraints): self {}

        /**
         * @param mixed[] $constraints
         */
        public function setConstraints(array $constraints): \void {}

        /**
         * Returns the number of operands (constraints).
         */
        final public function arity(): int {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Counts the number of constraint elements.
         */
        public function count(): int {}

        /**
         * Returns the nested constraints.
         */
        final protected function constraints(): array {}

        /**
         * Returns true if the $constraint needs to be wrapped with braces.
         */
        final protected function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint): bool {}

        /**
         * Reduces the sub-expression starting at $this by skipping degenerate
         * sub-expression and returns first descendant constraint that starts
         * a non-reducible sub-expression.
         *
         * See Constraint::reduce() for more.
         */
        protected function reduce(): \PHPUnit\Framework\Constraint\Constraint {}

        /**
         * Returns string representation of given operand in context of this operator.
         *
         * @param Constraint $constraint operand constraint
         * @param int        $position   position of $constraint in this expression
         */
        private function constraintToString(\PHPUnit\Framework\Constraint\Constraint $constraint, int $position): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class LogicalAnd extends \PHPUnit\Framework\Constraint\BinaryOperator
    {
        /**
         * Returns the name of this operator.
         */
        public function operator(): string {}

        /**
         * Returns this operator's precedence.
         *
         * @see https://www.php.net/manual/en/language.operators.precedence.php
         */
        public function precedence(): int {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use array_map;
    use count;
    use preg_match;
    use preg_quote;
    use preg_replace;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class LogicalNot extends \PHPUnit\Framework\Constraint\UnaryOperator
    {
        public static function negate(string $string): string {}

        /**
         * Returns the name of this operator.
         */
        public function operator(): string {}

        /**
         * Returns this operator's precedence.
         *
         * @see https://www.php.net/manual/en/language.operators.precedence.php
         */
        public function precedence(): int {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Applies additional transformation to strings returned by toString() or
         * failureDescription().
         */
        protected function transformString(string $string): string {}

        /**
         * Reduces the sub-expression starting at $this by skipping degenerate
         * sub-expression and returns first descendant constraint that starts
         * a non-reducible sub-expression.
         *
         * See Constraint::reduce() for more.
         */
        protected function reduce(): \PHPUnit\Framework\Constraint\Constraint {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class LogicalOr extends \PHPUnit\Framework\Constraint\BinaryOperator
    {
        /**
         * Returns the name of this operator.
         */
        public function operator(): string {}

        /**
         * Returns this operator's precedence.
         *
         * @see https://www.php.net/manual/en/language.operators.precedence.php
         */
        public function precedence(): int {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        public function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use array_reduce;
    use array_shift;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class LogicalXor extends \PHPUnit\Framework\Constraint\BinaryOperator
    {
        /**
         * Returns the name of this operator.
         */
        public function operator(): string {}

        /**
         * Returns this operator's precedence.
         *
         * @see https://www.php.net/manual/en/language.operators.precedence.php.
         */
        public function precedence(): int {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        public function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class Operator extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns the name of this operator.
         */
        abstract public function operator(): string;

        /**
         * Returns this operator's precedence.
         *
         * @see https://www.php.net/manual/en/language.operators.precedence.php
         */
        abstract public function precedence(): int;

        /**
         * Returns the number of operands.
         */
        abstract public function arity(): int;

        /**
         * Validates $constraint argument.
         */
        protected function checkConstraint($constraint): \PHPUnit\Framework\Constraint\Constraint {}

        /**
         * Returns true if the $constraint needs to be wrapped with braces.
         */
        protected function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use count;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class UnaryOperator extends \PHPUnit\Framework\Constraint\Operator
    {
        /**
         * @var Constraint
         */
        private $constraint;

        /**
         * @param Constraint|mixed $constraint
         */
        public function __construct($constraint) {}

        /**
         * Returns the number of operands (constraints).
         */
        public function arity(): int {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Counts the number of constraint elements.
         */
        public function count(): int {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

        /**
         * Transforms string returned by the memeber constraint's toString() or
         * failureDescription() such that it reflects constraint's participation in
         * this expression.
         *
         * The method may be overwritten in a subclass to apply default
         * transformation in case the operand constraint does not provide its own
         * custom strings via toStringInContext() or failureDescriptionInContext().
         *
         * @param string $string the string to be transformed
         */
        protected function transformString(string $string): string {}

        /**
         * Provides access to $this->constraint for subclasses.
         */
        final protected function constraint(): \PHPUnit\Framework\Constraint\Constraint {}

        /**
         * Returns true if the $constraint needs to be wrapped with parentheses.
         */
        protected function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use json_decode;
    use json_last_error;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsJson extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use preg_match;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    class RegularExpression extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $pattern;

        public function __construct(string $pattern) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use mb_stripos;
    use mb_strtolower;
    use sprintf;
    use strpos;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class StringContains extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $string;

        /**
         * @var bool
         */
        private $ignoreCase;

        public function __construct(string $string, bool $ignoreCase = false) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use strlen;
    use substr;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class StringEndsWith extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $suffix;

        public function __construct(string $suffix) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use DIRECTORY_SEPARATOR;
    use explode;
    use implode;
    use preg_match;
    use preg_quote;
    use preg_replace;
    use strtr;
    use SebastianBergmann\Diff\Differ;
    use SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class StringMatchesFormatDescription extends \PHPUnit\Framework\Constraint\RegularExpression
    {
        /**
         * @var string
         */
        private $string;

        public function __construct(string $string) {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        protected function failureDescription($other): string {}

        protected function additionalFailureDescription($other): string {}

        private function createPatternFromFormat(string $string): string {}

        private function convertNewlines(string $text): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use strlen;
    use strpos;
    use PHPUnit\Framework\InvalidArgumentException;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class StringStartsWith extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $prefix;

        public function __construct(string $prefix) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use array_key_exists;
    use is_array;
    use ArrayAccess;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ArrayHasKey extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var int|string
         */
        private $key;

        /**
         * @param int|string $key
         */
        public function __construct($key) {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use is_array;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class TraversableContains extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var mixed
         */
        private $value;

        public function __construct($value) {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

        protected function value() {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use SplObjectStorage;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class TraversableContainsEqual extends \PHPUnit\Framework\Constraint\TraversableContains
    {
        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use SplObjectStorage;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class TraversableContainsIdentical extends \PHPUnit\Framework\Constraint\TraversableContains
    {
        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use PHPUnit\Framework\ExpectationFailedException;
    use Traversable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class TraversableContainsOnly extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var Constraint
         */
        private $constraint;

        /**
         * @var string
         */
        private $type;

        /**
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct(string $type, bool $isNativeType = true) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @param mixed|Traversable $other
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsInstanceOf extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $className;

        public function __construct(string $className) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

        private function getType(): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsNull extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use gettype;
    use is_array;
    use is_bool;
    use is_callable;
    use is_float;
    use is_int;
    use is_iterable;
    use is_numeric;
    use is_object;
    use is_scalar;
    use is_string;
    use sprintf;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsType extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        const TYPE_ARRAY = 'array';

        /**
         * @var string
         */
        const TYPE_BOOL = 'bool';

        /**
         * @var string
         */
        const TYPE_FLOAT = 'float';

        /**
         * @var string
         */
        const TYPE_INT = 'int';

        /**
         * @var string
         */
        const TYPE_NULL = 'null';

        /**
         * @var string
         */
        const TYPE_NUMERIC = 'numeric';

        /**
         * @var string
         */
        const TYPE_OBJECT = 'object';

        /**
         * @var string
         */
        const TYPE_RESOURCE = 'resource';

        /**
         * @var string
         */
        const TYPE_CLOSED_RESOURCE = 'resource (closed)';

        /**
         * @var string
         */
        const TYPE_STRING = 'string';

        /**
         * @var string
         */
        const TYPE_SCALAR = 'scalar';

        /**
         * @var string
         */
        const TYPE_CALLABLE = 'callable';

        /**
         * @var string
         */
        const TYPE_ITERABLE = 'iterable';

        /**
         * @var array<string,bool>
         */
        const KNOWN_TYPES = [/** value is missing */];

        /**
         * @var string
         */
        private $type;

        /**
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct(string $type) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use call_user_func;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class Callback extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var callable
         */
        private $callback;

        public function __construct(callable $callback) {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $value. Returns true if the
         * constraint is met, false otherwise.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use sprintf;
    use Countable;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\SelfDescribing;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use SebastianBergmann\Exporter\Exporter;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class Constraint
    {
        /**
         * @var ?Exporter
         */
        private $exporter;

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Counts the number of constraint elements.
         */
        public function count(): int {}

        protected function exporter(): \SebastianBergmann\Exporter\Exporter {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * This method can be overridden to implement the evaluation algorithm.
         *
         * @param mixed $other value or object to evaluate
         * @codeCoverageIgnore
         */
        protected function matches($other): bool {}

        /**
         * Throws an exception for the given compared value and test description.
         *
         * @param mixed             $other             evaluated value or object
         * @param string            $description       Additional information about the test
         * @param ComparisonFailure $comparisonFailure
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-return never-return
         */
        protected function fail($other, $description, ?\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null): \void {}

        /**
         * Return additional failure description where needed.
         *
         * The function can be overridden to provide additional failure
         * information like a diff
         *
         * @param mixed $other evaluated value or object
         */
        protected function additionalFailureDescription($other): string {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * To provide additional failure information additionalFailureDescription
         * can be used.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

        /**
         * Returns a custom string representation of the constraint object when it
         * appears in context of an $operator expression.
         *
         * The purpose of this method is to provide meaningful descriptive string
         * in context of operators such as LogicalNot. Native PHPUnit constraints
         * are supported out of the box by LogicalNot, but externally developed
         * ones had no way to provide correct strings in this context.
         *
         * The method shall return empty string, when it does not handle
         * customization by itself.
         *
         * @param Operator $operator the $operator of the expression
         * @param mixed    $role     role of $this constraint in the $operator expression
         */
        protected function toStringInContext(\PHPUnit\Framework\Constraint\Operator $operator, $role): string {}

        /**
         * Returns the description of the failure when this constraint appears in
         * context of an $operator expression.
         *
         * The purpose of this method is to provide meaningful failue description
         * in context of operators such as LogicalNot. Native PHPUnit constraints
         * are supported out of the box by LogicalNot, but externally developed
         * ones had no way to provide correct messages in this context.
         *
         * The method shall return empty string, when it does not handle
         * customization by itself.
         *
         * @param Operator $operator the $operator of the expression
         * @param mixed    $role     role of $this constraint in the $operator expression
         * @param mixed    $other    evaluated value or object
         */
        protected function failureDescriptionInContext(\PHPUnit\Framework\Constraint\Operator $operator, $role, $other): string {}

        /**
         * Reduces the sub-expression starting at $this by skipping degenerate
         * sub-expression and returns first descendant constraint that starts
         * a non-reducible sub-expression.
         *
         * Returns $this for terminal constraints and for operators that start
         * non-reducible sub-expression, or the nearest descendant of $this that
         * starts a non-reducible sub-expression.
         *
         * A constraint expression may be modelled as a tree with non-terminal
         * nodes (operators) and terminal nodes. For example:
         *
         *      LogicalOr           (operator, non-terminal)
         *      + LogicalAnd        (operator, non-terminal)
         *      | + IsType('int')   (terminal)
         *      | + GreaterThan(10) (terminal)
         *      + LogicalNot        (operator, non-terminal)
         *        + IsType('array') (terminal)
         *
         * A degenerate sub-expression is a part of the tree, that effectively does
         * not contribute to the evaluation of the expression it appears in. An example
         * of degenerate sub-expression is a BinaryOperator constructed with single
         * operand or nested BinaryOperators, each with single operand. An
         * expression involving a degenerate sub-expression is equivalent to a
         * reduced expression with the degenerate sub-expression removed, for example
         *
         *      LogicalAnd          (operator)
         *      + LogicalOr         (degenerate operator)
         *      | + LogicalAnd      (degenerate operator)
         *      |   + IsType('int') (terminal)
         *      + GreaterThan(10)   (terminal)
         *
         * is equivalent to
         *
         *      LogicalAnd          (operator)
         *      + IsType('int')     (terminal)
         *      + GreaterThan(10)   (terminal)
         *
         * because the subexpression
         *
         *      + LogicalOr
         *        + LogicalAnd
         *          + -
         *
         * is degenerate. Calling reduce() on the LogicalOr object above, as well
         * as on LogicalAnd, shall return the IsType('int') instance.
         *
         * Other specific reductions can be implemented, for example cascade of
         * LogicalNot operators
         *
         *      + LogicalNot
         *        + LogicalNot
         *          +LogicalNot
         *           + IsTrue
         *
         * can be reduced to
         *
         *      LogicalNot
         *      + IsTrue
         */
        protected function reduce(): self {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use PHPUnit\Framework\ExpectationFailedException;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsAnything extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         */
        public function toString(): string {}

        /**
         * Counts the number of constraint elements.
         */
        public function count(): int {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use abs;
    use get_class;
    use is_array;
    use is_float;
    use is_infinite;
    use is_nan;
    use is_object;
    use is_string;
    use sprintf;
    use PHPUnit\Framework\ExpectationFailedException;
    use SebastianBergmann\Comparator\ComparisonFailure;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class IsIdentical extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var float
         */
        const EPSILON = 1.0E-10;

        /**
         * @var mixed
         */
        private $value;

        public function __construct($value) {}

        /**
         * Evaluates the constraint for parameter $other.
         *
         * If $returnResult is set to false (the default), an exception is thrown
         * in case of a failure. null is returned otherwise.
         *
         * If $returnResult is true, the result of the evaluation is returned as
         * a boolean value instead: true in case of success, false in case of a
         * failure.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function evaluate($other, string $description = '', bool $returnResult = false): ?bool {}

        /**
         * Returns a string representation of the constraint.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * Returns the description of the failure.
         *
         * The beginning of failure messages is "Failed asserting that" in most
         * cases. This method should return the second part of that sentence.
         *
         * @param mixed $other evaluated value or object
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function failureDescription($other): string {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use json_decode;
    use sprintf;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Util\Json;
    use SebastianBergmann\Comparator\ComparisonFailure;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class JsonMatches extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $value;

        public function __construct(string $value) {}

        /**
         * Returns a string representation of the object.
         */
        public function toString(): string {}

        /**
         * Evaluates the constraint for parameter $other. Returns true if the
         * constraint is met, false otherwise.
         *
         * This method can be overridden to implement the evaluation algorithm.
         *
         * @param mixed $other value or object to evaluate
         */
        protected function matches($other): bool {}

        /**
         * Throws an exception for the given compared value and test description.
         *
         * @param mixed             $other             evaluated value or object
         * @param string            $description       Additional information about the test
         * @param ComparisonFailure $comparisonFailure
         *
         * @throws ExpectationFailedException
         * @throws \PHPUnit\Framework\Exception
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-return never-return
         */
        protected function fail($other, $description, ?\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null): \void {}

    }
}

namespace PHPUnit\Framework\Constraint
{
    use JSON_ERROR_CTRL_CHAR;
    use JSON_ERROR_DEPTH;
    use JSON_ERROR_NONE;
    use JSON_ERROR_STATE_MISMATCH;
    use JSON_ERROR_SYNTAX;
    use JSON_ERROR_UTF8;
    use strtolower;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class JsonMatchesErrorMessageProvider
    {
        /**
         * Translates JSON error to a human readable string.
         */
        public static function determineJsonError(string $error, string $prefix = ''): ?string {}

        /**
         * Translates a given type to a human readable message prefix.
         */
        public static function translateTypeToPrefix(string $type): string {}

    }
}

namespace PHPUnit\Framework\Error
{

    /**
     * @internal
     */
    final class Deprecated extends \PHPUnit\Framework\Error\Error
    {
    }
}

namespace PHPUnit\Framework\Error
{
    use PHPUnit\Framework\Exception;

    /**
     * @internal
     */
    class Error extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $message, int $code, string $file, int $line, ?\Exception $previous = null) {}

    }
}

namespace PHPUnit\Framework\Error
{

    /**
     * @internal
     */
    final class Notice extends \PHPUnit\Framework\Error\Error
    {
    }
}

namespace PHPUnit\Framework\Error
{

    /**
     * @internal
     */
    final class Warning extends \PHPUnit\Framework\Error\Error
    {
    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ActualValueIsNotAnObjectException extends \PHPUnit\Framework\Exception
    {
        public function __construct() {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class AssertionFailedError extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\SelfDescribing
    {
        /**
         * Wrapper for getMessage() which is declared as final.
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class CodeCoverageException extends \PHPUnit\Framework\Exception
    {
    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ComparisonMethodDoesNotAcceptParameterTypeException extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $className, string $methodName, string $type) {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ComparisonMethodDoesNotDeclareBoolReturnTypeException extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $className, string $methodName) {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ComparisonMethodDoesNotDeclareExactlyOneParameterException extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $className, string $methodName) {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ComparisonMethodDoesNotDeclareParameterTypeException extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $className, string $methodName) {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ComparisonMethodDoesNotExistException extends \PHPUnit\Framework\Exception
    {
        public function __construct(string $className, string $methodName) {}

        public function __toString(): string {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoveredCodeNotExecutedException extends \PHPUnit\Framework\RiskyTestError
    {
    }
}

namespace PHPUnit\Framework
{
    use array_keys;
    use get_object_vars;
    use PHPUnit\Util\Filter;
    use RuntimeException;
    use Throwable;

    /**
     * Base class for all PHPUnit Framework exceptions.
     *
     * Ensures that exceptions thrown during a test run do not leave stray
     * references behind.
     *
     * Every Exception contains a stack trace. Each stack frame contains the 'args'
     * of the called function. The function arguments can contain references to
     * instantiated objects. The references prevent the objects from being
     * destructed (until test results are eventually printed), so memory cannot be
     * freed up.
     *
     * With enabled process isolation, test results are serialized in the child
     * process and unserialized in the parent process. The stack trace of Exceptions
     * may contain objects that cannot be serialized or unserialized (e.g., PDO
     * connections). Unserializing user-space objects from the child process into
     * the parent would break the intended encapsulation of process isolation.
     *
     * @see http://fabien.potencier.org/article/9/php-serialization-stack-traces-and-exceptions
     *
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class Exception extends \RuntimeException
    {
        /**
         * @var array
         */
        protected $serializableTrace;

        public function __construct($message = '', $code = 0, ?\Throwable $previous = null) {}

        public function __toString(): string {}

        public function __sleep(): array {}

        /**
         * Returns the serializable trace (without 'args').
         */
        public function getSerializableTrace(): array {}

    }
}

namespace PHPUnit\Framework
{
    use Exception;
    use SebastianBergmann\Comparator\ComparisonFailure;

    /**
     * Exception for expectations which failed their check.
     *
     * The exception contains the error message and optionally a
     * SebastianBergmann\Comparator\ComparisonFailure which is used to
     * generate diff output of the failed expectations.
     *
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExpectationFailedException extends \PHPUnit\Framework\AssertionFailedError
    {
        /**
         * @var ComparisonFailure
         */
        protected $comparisonFailure;

        public function __construct(string $message, ?\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null, ?\Exception $previous = null) {}

        public function getComparisonFailure(): ?\SebastianBergmann\Comparator\ComparisonFailure {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IncompleteTestError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\IncompleteTest
    {
    }
}

namespace PHPUnit\Framework
{
    use debug_backtrace;
    use in_array;
    use lcfirst;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvalidArgumentException extends \PHPUnit\Framework\Exception
    {
        public static function create(int $argument, string $type): self {}

        private function __construct(string $message = '', int $code = 0, ?\Exception $previous = null) {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvalidCoversTargetException extends \PHPUnit\Framework\CodeCoverageException
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvalidDataProviderException extends \PHPUnit\Framework\Exception
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MissingCoversAnnotationException extends \PHPUnit\Framework\RiskyTestError
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class NoChildTestSuiteException extends \PHPUnit\Framework\Exception
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class OutputError extends \PHPUnit\Framework\AssertionFailedError
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class PHPTAssertionFailedError extends \PHPUnit\Framework\SyntheticError
    {
        /**
         * @var string
         */
        private $diff;

        public function __construct(string $message, int $code, string $file, int $line, array $trace, string $diff) {}

        public function getDiff(): string {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class RiskyTestError extends \PHPUnit\Framework\AssertionFailedError
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SkippedTestError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\SkippedTest
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SkippedTestSuiteError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\SkippedTest
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class SyntheticError extends \PHPUnit\Framework\AssertionFailedError
    {
        /**
         * The synthetic file.
         *
         * @var string
         */
        protected $syntheticFile = '';

        /**
         * The synthetic line number.
         *
         * @var int
         */
        protected $syntheticLine = 0;

        /**
         * The synthetic trace.
         *
         * @var array
         */
        protected $syntheticTrace = [/** value is missing */];

        public function __construct(string $message, int $code, string $file, int $line, array $trace) {}

        public function getSyntheticFile(): string {}

        public function getSyntheticLine(): int {}

        public function getSyntheticTrace(): array {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SyntheticSkippedError extends \PHPUnit\Framework\SyntheticError implements \PHPUnit\Framework\SkippedTest
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class UnintentionallyCoveredCodeError extends \PHPUnit\Framework\RiskyTestError
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Warning extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\SelfDescribing
    {
        /**
         * Wrapper for getMessage() which is declared as final.
         */
        public function toString(): string {}

    }
}

namespace PHPUnit\Framework
{
    use DEBUG_BACKTRACE_IGNORE_ARGS;
    use PHP_EOL;
    use array_shift;
    use array_unshift;
    use assert;
    use class_exists;
    use count;
    use debug_backtrace;
    use explode;
    use file_get_contents;
    use func_get_args;
    use implode;
    use interface_exists;
    use is_array;
    use is_bool;
    use is_int;
    use is_iterable;
    use is_object;
    use is_string;
    use preg_match;
    use preg_split;
    use sprintf;
    use strpos;
    use ArrayAccess;
    use Countable;
    use DOMAttr;
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Framework\Constraint\ArrayHasKey;
    use PHPUnit\Framework\Constraint\Callback;
    use PHPUnit\Framework\Constraint\ClassHasAttribute;
    use PHPUnit\Framework\Constraint\ClassHasStaticAttribute;
    use PHPUnit\Framework\Constraint\Constraint;
    use PHPUnit\Framework\Constraint\Count;
    use PHPUnit\Framework\Constraint\DirectoryExists;
    use PHPUnit\Framework\Constraint\FileExists;
    use PHPUnit\Framework\Constraint\GreaterThan;
    use PHPUnit\Framework\Constraint\IsAnything;
    use PHPUnit\Framework\Constraint\IsEmpty;
    use PHPUnit\Framework\Constraint\IsEqual;
    use PHPUnit\Framework\Constraint\IsEqualCanonicalizing;
    use PHPUnit\Framework\Constraint\IsEqualIgnoringCase;
    use PHPUnit\Framework\Constraint\IsEqualWithDelta;
    use PHPUnit\Framework\Constraint\IsFalse;
    use PHPUnit\Framework\Constraint\IsFinite;
    use PHPUnit\Framework\Constraint\IsIdentical;
    use PHPUnit\Framework\Constraint\IsInfinite;
    use PHPUnit\Framework\Constraint\IsInstanceOf;
    use PHPUnit\Framework\Constraint\IsJson;
    use PHPUnit\Framework\Constraint\IsNan;
    use PHPUnit\Framework\Constraint\IsNull;
    use PHPUnit\Framework\Constraint\IsReadable;
    use PHPUnit\Framework\Constraint\IsTrue;
    use PHPUnit\Framework\Constraint\IsType;
    use PHPUnit\Framework\Constraint\IsWritable;
    use PHPUnit\Framework\Constraint\JsonMatches;
    use PHPUnit\Framework\Constraint\LessThan;
    use PHPUnit\Framework\Constraint\LogicalAnd;
    use PHPUnit\Framework\Constraint\LogicalNot;
    use PHPUnit\Framework\Constraint\LogicalOr;
    use PHPUnit\Framework\Constraint\LogicalXor;
    use PHPUnit\Framework\Constraint\ObjectEquals;
    use PHPUnit\Framework\Constraint\ObjectHasAttribute;
    use PHPUnit\Framework\Constraint\RegularExpression;
    use PHPUnit\Framework\Constraint\SameSize;
    use PHPUnit\Framework\Constraint\StringContains;
    use PHPUnit\Framework\Constraint\StringEndsWith;
    use PHPUnit\Framework\Constraint\StringMatchesFormatDescription;
    use PHPUnit\Framework\Constraint\StringStartsWith;
    use PHPUnit\Framework\Constraint\TraversableContainsEqual;
    use PHPUnit\Framework\Constraint\TraversableContainsIdentical;
    use PHPUnit\Framework\Constraint\TraversableContainsOnly;
    use PHPUnit\Util\Type;
    use PHPUnit\Util\Xml;
    use PHPUnit\Util\Xml\Loader as XmlLoader;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class Assert
    {
        /**
         * @var int
         */
        private static $count = 0;

        /**
         * Asserts that an array has a specified key.
         *
         * @param int|string        $key
         * @param array|ArrayAccess $array
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertArrayHasKey($key, $array, string $message = ''): \void {}

        /**
         * Asserts that an array does not have a specified key.
         *
         * @param int|string        $key
         * @param array|ArrayAccess $array
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertArrayNotHasKey($key, $array, string $message = ''): \void {}

        /**
         * Asserts that a haystack contains a needle.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertContains($needle, \iterable $haystack, string $message = ''): \void {}

        public static function assertContainsEquals($needle, \iterable $haystack, string $message = ''): \void {}

        /**
         * Asserts that a haystack does not contain a needle.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertNotContains($needle, \iterable $haystack, string $message = ''): \void {}

        public static function assertNotContainsEquals($needle, \iterable $haystack, string $message = ''): \void {}

        /**
         * Asserts that a haystack contains only values of a given type.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertContainsOnly(string $type, \iterable $haystack, ?bool $isNativeType = null, string $message = ''): \void {}

        /**
         * Asserts that a haystack contains only instances of a given class name.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertContainsOnlyInstancesOf(string $className, \iterable $haystack, string $message = ''): \void {}

        /**
         * Asserts that a haystack does not contain only values of a given type.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotContainsOnly(string $type, \iterable $haystack, ?bool $isNativeType = null, string $message = ''): \void {}

        /**
         * Asserts the number of elements of an array, Countable or Traversable.
         *
         * @param Countable|iterable $haystack
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertCount(int $expectedCount, $haystack, string $message = ''): \void {}

        /**
         * Asserts the number of elements of an array, Countable or Traversable.
         *
         * @param Countable|iterable $haystack
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertNotCount(int $expectedCount, $haystack, string $message = ''): \void {}

        /**
         * Asserts that two variables are equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertEquals($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are equal (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertEqualsCanonicalizing($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are equal (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertEqualsIgnoringCase($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are equal (with delta).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertEqualsWithDelta($expected, $actual, float $delta, string $message = ''): \void {}

        /**
         * Asserts that two variables are not equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotEquals($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are not equal (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotEqualsCanonicalizing($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are not equal (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotEqualsIgnoringCase($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables are not equal (with delta).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotEqualsWithDelta($expected, $actual, float $delta, string $message = ''): \void {}

        /**
         * Asserts that a variable is empty.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert empty $actual
         */
        public static function assertEmpty($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not empty.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !empty $actual
         */
        public static function assertNotEmpty($actual, string $message = ''): \void {}

        /**
         * Asserts that a value is greater than another value.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertGreaterThan($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a value is greater than or equal to another value.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertGreaterThanOrEqual($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a value is smaller than another value.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertLessThan($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a value is smaller than or equal to another value.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertLessThanOrEqual($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is equal to the contents of another
         * file.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileEquals(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is equal to the contents of another
         * file (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileEqualsCanonicalizing(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is equal to the contents of another
         * file (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileEqualsIgnoringCase(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is not equal to the contents of
         * another file.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileNotEquals(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is not equal to the contents of another
         * file (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileNotEqualsCanonicalizing(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of one file is not equal to the contents of another
         * file (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileNotEqualsIgnoringCase(string $expected, string $actual, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is equal
         * to the contents of a file.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringEqualsFile(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is equal
         * to the contents of a file (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is equal
         * to the contents of a file (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is not equal
         * to the contents of a file.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotEqualsFile(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is not equal
         * to the contents of a file (canonicalizing).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that the contents of a string is not equal
         * to the contents of a file (ignoring case).
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = ''): \void {}

        /**
         * Asserts that a file/dir is readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertIsReadable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file/dir exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertIsNotReadable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file/dir exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4062
         */
        public static function assertNotIsReadable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file/dir exists and is writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertIsWritable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file/dir exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertIsNotWritable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file/dir exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4065
         */
        public static function assertNotIsWritable(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a directory exists.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryExists(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory does not exist.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryDoesNotExist(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory does not exist.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4068
         */
        public static function assertDirectoryNotExists(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryIsReadable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryIsNotReadable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4071
         */
        public static function assertDirectoryNotIsReadable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryIsWritable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDirectoryIsNotWritable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a directory exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4074
         */
        public static function assertDirectoryNotIsWritable(string $directory, string $message = ''): \void {}

        /**
         * Asserts that a file exists.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileExists(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file does not exist.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileDoesNotExist(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file does not exist.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4077
         */
        public static function assertFileNotExists(string $filename, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileIsReadable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileIsNotReadable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is not readable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4080
         */
        public static function assertFileNotIsReadable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileIsWritable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFileIsNotWritable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a file exists and is not writable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4083
         */
        public static function assertFileNotIsWritable(string $file, string $message = ''): \void {}

        /**
         * Asserts that a condition is true.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert true $condition
         */
        public static function assertTrue($condition, string $message = ''): \void {}

        /**
         * Asserts that a condition is not true.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !true $condition
         */
        public static function assertNotTrue($condition, string $message = ''): \void {}

        /**
         * Asserts that a condition is false.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert false $condition
         */
        public static function assertFalse($condition, string $message = ''): \void {}

        /**
         * Asserts that a condition is not false.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !false $condition
         */
        public static function assertNotFalse($condition, string $message = ''): \void {}

        /**
         * Asserts that a variable is null.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert null $actual
         */
        public static function assertNull($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not null.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !null $actual
         */
        public static function assertNotNull($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is finite.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertFinite($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is infinite.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertInfinite($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is nan.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNan($actual, string $message = ''): \void {}

        /**
         * Asserts that a class has a specified attribute.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertClassHasAttribute(string $attributeName, string $className, string $message = ''): \void {}

        /**
         * Asserts that a class does not have a specified attribute.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertClassNotHasAttribute(string $attributeName, string $className, string $message = ''): \void {}

        /**
         * Asserts that a class has a specified static attribute.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertClassHasStaticAttribute(string $attributeName, string $className, string $message = ''): \void {}

        /**
         * Asserts that a class does not have a specified static attribute.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertClassNotHasStaticAttribute(string $attributeName, string $className, string $message = ''): \void {}

        /**
         * Asserts that an object has a specified attribute.
         *
         * @param object $object
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertObjectHasAttribute(string $attributeName, $object, string $message = ''): \void {}

        /**
         * Asserts that an object does not have a specified attribute.
         *
         * @param object $object
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertObjectNotHasAttribute(string $attributeName, $object, string $message = ''): \void {}

        /**
         * Asserts that two variables have the same type and value.
         * Used on objects, it asserts that two variables reference
         * the same object.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-template ExpectedType
         * @psalm-param ExpectedType $expected
         * @psalm-assert =ExpectedType $actual
         */
        public static function assertSame($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that two variables do not have the same type and value.
         * Used on objects, it asserts that two variables do not reference
         * the same object.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertNotSame($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of a given type.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         *
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $expected
         * @psalm-assert ExpectedType $actual
         */
        public static function assertInstanceOf(string $expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of a given type.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         *
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $expected
         * @psalm-assert !ExpectedType $actual
         */
        public static function assertNotInstanceOf(string $expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type array.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert array $actual
         */
        public static function assertIsArray($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type bool.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert bool $actual
         */
        public static function assertIsBool($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type float.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert float $actual
         */
        public static function assertIsFloat($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type int.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert int $actual
         */
        public static function assertIsInt($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type numeric.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert numeric $actual
         */
        public static function assertIsNumeric($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type object.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert object $actual
         */
        public static function assertIsObject($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type resource.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert resource $actual
         */
        public static function assertIsResource($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type resource and is closed.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert resource $actual
         */
        public static function assertIsClosedResource($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert string $actual
         */
        public static function assertIsString($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type scalar.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert scalar $actual
         */
        public static function assertIsScalar($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type callable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert callable $actual
         */
        public static function assertIsCallable($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is of type iterable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert iterable $actual
         */
        public static function assertIsIterable($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type array.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !array $actual
         */
        public static function assertIsNotArray($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type bool.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !bool $actual
         */
        public static function assertIsNotBool($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type float.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !float $actual
         */
        public static function assertIsNotFloat($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type int.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !int $actual
         */
        public static function assertIsNotInt($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type numeric.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !numeric $actual
         */
        public static function assertIsNotNumeric($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type object.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !object $actual
         */
        public static function assertIsNotObject($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type resource.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !resource $actual
         */
        public static function assertIsNotResource($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type resource.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !resource $actual
         */
        public static function assertIsNotClosedResource($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !string $actual
         */
        public static function assertIsNotString($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type scalar.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !scalar $actual
         */
        public static function assertIsNotScalar($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type callable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !callable $actual
         */
        public static function assertIsNotCallable($actual, string $message = ''): \void {}

        /**
         * Asserts that a variable is not of type iterable.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @psalm-assert !iterable $actual
         */
        public static function assertIsNotIterable($actual, string $message = ''): \void {}

        /**
         * Asserts that a string matches a given regular expression.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertMatchesRegularExpression(string $pattern, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string matches a given regular expression.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4086
         */
        public static function assertRegExp(string $pattern, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string does not match a given regular expression.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertDoesNotMatchRegularExpression(string $pattern, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string does not match a given regular expression.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4089
         */
        public static function assertNotRegExp(string $pattern, string $string, string $message = ''): \void {}

        /**
         * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
         * is the same.
         *
         * @param Countable|iterable $expected
         * @param Countable|iterable $actual
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertSameSize($expected, $actual, string $message = ''): \void {}

        /**
         * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
         * is not the same.
         *
         * @param Countable|iterable $expected
         * @param Countable|iterable $actual
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertNotSameSize($expected, $actual, string $message = ''): \void {}

        /**
         * Asserts that a string matches a given format string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringMatchesFormat(string $format, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string does not match a given format string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotMatchesFormat(string $format, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string matches a given format file.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringMatchesFormatFile(string $formatFile, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string does not match a given format string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotMatchesFormatFile(string $formatFile, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string starts with a given prefix.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringStartsWith(string $prefix, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string starts not with a given prefix.
         *
         * @param string $prefix
         * @param string $string
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringStartsNotWith($prefix, $string, string $message = ''): \void {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringContainsString(string $needle, string $haystack, string $message = ''): \void {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringContainsStringIgnoringCase(string $needle, string $haystack, string $message = ''): \void {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotContainsString(string $needle, string $haystack, string $message = ''): \void {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringNotContainsStringIgnoringCase(string $needle, string $haystack, string $message = ''): \void {}

        /**
         * Asserts that a string ends with a given suffix.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringEndsWith(string $suffix, string $string, string $message = ''): \void {}

        /**
         * Asserts that a string ends not with a given suffix.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertStringEndsNotWith(string $suffix, string $string, string $message = ''): \void {}

        /**
         * Asserts that two XML files are equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public static function assertXmlFileEqualsXmlFile(string $expectedFile, string $actualFile, string $message = ''): \void {}

        /**
         * Asserts that two XML files are not equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws \PHPUnit\Util\Exception
         */
        public static function assertXmlFileNotEqualsXmlFile(string $expectedFile, string $actualFile, string $message = ''): \void {}

        /**
         * Asserts that two XML documents are equal.
         *
         * @param DOMDocument|string $actualXml
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws \PHPUnit\Util\Xml\Exception
         */
        public static function assertXmlStringEqualsXmlFile(string $expectedFile, $actualXml, string $message = ''): \void {}

        /**
         * Asserts that two XML documents are not equal.
         *
         * @param DOMDocument|string $actualXml
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws \PHPUnit\Util\Xml\Exception
         */
        public static function assertXmlStringNotEqualsXmlFile(string $expectedFile, $actualXml, string $message = ''): \void {}

        /**
         * Asserts that two XML documents are equal.
         *
         * @param DOMDocument|string $expectedXml
         * @param DOMDocument|string $actualXml
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws \PHPUnit\Util\Xml\Exception
         */
        public static function assertXmlStringEqualsXmlString($expectedXml, $actualXml, string $message = ''): \void {}

        /**
         * Asserts that two XML documents are not equal.
         *
         * @param DOMDocument|string $expectedXml
         * @param DOMDocument|string $actualXml
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws \PHPUnit\Util\Xml\Exception
         */
        public static function assertXmlStringNotEqualsXmlString($expectedXml, $actualXml, string $message = ''): \void {}

        /**
         * Asserts that a hierarchy of DOMElements matches.
         *
         * @throws AssertionFailedError
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @codeCoverageIgnore
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4091
         */
        public static function assertEqualXMLStructure(\DOMElement $expectedElement, \DOMElement $actualElement, bool $checkAttributes = false, string $message = ''): \void {}

        /**
         * Evaluates a PHPUnit\Framework\Constraint matcher object.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertThat($value, \PHPUnit\Framework\Constraint\Constraint $constraint, string $message = ''): \void {}

        /**
         * Asserts that a string is a valid JSON string.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJson(string $actualJson, string $message = ''): \void {}

        /**
         * Asserts that two given JSON encoded objects or arrays are equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonStringEqualsJsonString(string $expectedJson, string $actualJson, string $message = ''): \void {}

        /**
         * Asserts that two given JSON encoded objects or arrays are not equal.
         *
         * @param string $expectedJson
         * @param string $actualJson
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonStringNotEqualsJsonString($expectedJson, $actualJson, string $message = ''): \void {}

        /**
         * Asserts that the generated JSON encoded object and the content of the given file are equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonStringEqualsJsonFile(string $expectedFile, string $actualJson, string $message = ''): \void {}

        /**
         * Asserts that the generated JSON encoded object and the content of the given file are not equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonStringNotEqualsJsonFile(string $expectedFile, string $actualJson, string $message = ''): \void {}

        /**
         * Asserts that two JSON files are equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonFileEqualsJsonFile(string $expectedFile, string $actualFile, string $message = ''): \void {}

        /**
         * Asserts that two JSON files are not equal.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function assertJsonFileNotEqualsJsonFile(string $expectedFile, string $actualFile, string $message = ''): \void {}

        /**
         * @throws Exception
         */
        public static function logicalAnd(): \PHPUnit\Framework\Constraint\LogicalAnd {}

        public static function logicalOr(): \PHPUnit\Framework\Constraint\LogicalOr {}

        public static function logicalNot(\PHPUnit\Framework\Constraint\Constraint $constraint): \PHPUnit\Framework\Constraint\LogicalNot {}

        public static function logicalXor(): \PHPUnit\Framework\Constraint\LogicalXor {}

        public static function anything(): \PHPUnit\Framework\Constraint\IsAnything {}

        public static function isTrue(): \PHPUnit\Framework\Constraint\IsTrue {}

        public static function callback(callable $callback): \PHPUnit\Framework\Constraint\Callback {}

        public static function isFalse(): \PHPUnit\Framework\Constraint\IsFalse {}

        public static function isJson(): \PHPUnit\Framework\Constraint\IsJson {}

        public static function isNull(): \PHPUnit\Framework\Constraint\IsNull {}

        public static function isFinite(): \PHPUnit\Framework\Constraint\IsFinite {}

        public static function isInfinite(): \PHPUnit\Framework\Constraint\IsInfinite {}

        public static function isNan(): \PHPUnit\Framework\Constraint\IsNan {}

        public static function containsEqual($value): \PHPUnit\Framework\Constraint\TraversableContainsEqual {}

        public static function containsIdentical($value): \PHPUnit\Framework\Constraint\TraversableContainsIdentical {}

        public static function containsOnly(string $type): \PHPUnit\Framework\Constraint\TraversableContainsOnly {}

        public static function containsOnlyInstancesOf(string $className): \PHPUnit\Framework\Constraint\TraversableContainsOnly {}

        /**
         * @param int|string $key
         */
        public static function arrayHasKey($key): \PHPUnit\Framework\Constraint\ArrayHasKey {}

        public static function equalTo($value): \PHPUnit\Framework\Constraint\IsEqual {}

        public static function equalToCanonicalizing($value): \PHPUnit\Framework\Constraint\IsEqualCanonicalizing {}

        public static function equalToIgnoringCase($value): \PHPUnit\Framework\Constraint\IsEqualIgnoringCase {}

        public static function equalToWithDelta($value, float $delta): \PHPUnit\Framework\Constraint\IsEqualWithDelta {}

        public static function isEmpty(): \PHPUnit\Framework\Constraint\IsEmpty {}

        public static function isWritable(): \PHPUnit\Framework\Constraint\IsWritable {}

        public static function isReadable(): \PHPUnit\Framework\Constraint\IsReadable {}

        public static function directoryExists(): \PHPUnit\Framework\Constraint\DirectoryExists {}

        public static function fileExists(): \PHPUnit\Framework\Constraint\FileExists {}

        public static function greaterThan($value): \PHPUnit\Framework\Constraint\GreaterThan {}

        public static function greaterThanOrEqual($value): \PHPUnit\Framework\Constraint\LogicalOr {}

        public static function classHasAttribute(string $attributeName): \PHPUnit\Framework\Constraint\ClassHasAttribute {}

        public static function classHasStaticAttribute(string $attributeName): \PHPUnit\Framework\Constraint\ClassHasStaticAttribute {}

        public static function objectHasAttribute($attributeName): \PHPUnit\Framework\Constraint\ObjectHasAttribute {}

        public static function identicalTo($value): \PHPUnit\Framework\Constraint\IsIdentical {}

        public static function isInstanceOf(string $className): \PHPUnit\Framework\Constraint\IsInstanceOf {}

        public static function isType(string $type): \PHPUnit\Framework\Constraint\IsType {}

        public static function lessThan($value): \PHPUnit\Framework\Constraint\LessThan {}

        public static function lessThanOrEqual($value): \PHPUnit\Framework\Constraint\LogicalOr {}

        public static function matchesRegularExpression(string $pattern): \PHPUnit\Framework\Constraint\RegularExpression {}

        public static function matches(string $string): \PHPUnit\Framework\Constraint\StringMatchesFormatDescription {}

        public static function stringStartsWith($prefix): \PHPUnit\Framework\Constraint\StringStartsWith {}

        public static function stringContains(string $string, bool $case = true): \PHPUnit\Framework\Constraint\StringContains {}

        public static function stringEndsWith(string $suffix): \PHPUnit\Framework\Constraint\StringEndsWith {}

        public static function countOf(int $count): \PHPUnit\Framework\Constraint\Count {}

        public static function objectEquals(object $object, string $method = 'equals'): \PHPUnit\Framework\Constraint\ObjectEquals {}

        /**
         * Fails a test with the given message.
         *
         * @throws AssertionFailedError
         *
         * @psalm-return never-return
         */
        public static function fail(string $message = ''): \void {}

        /**
         * Mark the test as incomplete.
         *
         * @throws IncompleteTestError
         *
         * @psalm-return never-return
         */
        public static function markTestIncomplete(string $message = ''): \void {}

        /**
         * Mark the test as skipped.
         *
         * @throws SkippedTestError
         * @throws SyntheticSkippedError
         *
         * @psalm-return never-return
         */
        public static function markTestSkipped(string $message = ''): \void {}

        /**
         * Return the current assertion count.
         */
        public static function getCount(): int {}

        /**
         * Reset the assertion counter.
         */
        public static function resetCount(): \void {}

        /**
         * @throws ExpectationFailedException
         */
        public function assertObjectEquals(object $expected, object $actual, string $method = 'equals', string $message = ''): \void {}

        private static function detectLocationHint(string $message): ?array {}

        private static function isValidObjectAttributeName(string $attributeName): bool {}

        private static function isValidClassAttributeName(string $attributeName): bool {}

        /**
         * @codeCoverageIgnore
         */
        private static function createWarning(string $warning): \void {}

    }
}

namespace PHPUnit\Framework
{
    use explode;
    use PHPUnit\Util\Test as TestUtil;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class DataProviderTestSuite extends \PHPUnit\Framework\TestSuite
    {
        /**
         * @var list<ExecutionOrderDependency>
         */
        private $dependencies = [/** value is missing */];

        /**
         * @param list<ExecutionOrderDependency> $dependencies
         */
        public function setDependencies(array $dependencies): \void {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function provides(): array {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function requires(): array {}

        /**
         * Returns the size of the each test created using the data provider(s).
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function getSize(): int {}

    }
}

namespace PHPUnit\Framework
{
    use array_keys;
    use get_class;
    use spl_object_hash;
    use PHPUnit\Util\Filter;
    use Throwable;

    /**
     * Wraps Exceptions thrown by code under test.
     *
     * Re-instantiates Exceptions thrown by user-space code to retain their original
     * class names, properties, and stack traces (but without arguments).
     *
     * Unlike PHPUnit\Framework_\Exception, the complete stack of previous Exceptions
     * is processed.
     *
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExceptionWrapper extends \PHPUnit\Framework\Exception
    {
        /**
         * @var string
         */
        protected $className;

        /**
         * @var null|ExceptionWrapper
         */
        protected $previous;

        public function __construct(\Throwable $t) {}

        public function __toString(): string {}

        public function getClassName(): string {}

        public function getPreviousWrapped(): ?self {}

        public function setClassName(string $className): \void {}

        public function setOriginalException(\Throwable $t): \void {}

        public function getOriginalException(): ?\Throwable {}

        /**
         * Method to contain static originalException to exclude it from stacktrace to prevent the stacktrace contents,
         * which can be quite big, from being garbage-collected, thus blocking memory until shutdown.
         *
         * Approach works both for var_dump() and var_export() and print_r().
         */
        private function originalException(?\Throwable $exceptionToStore = null): ?\Throwable {}

    }
}

namespace PHPUnit\Framework
{
    use array_filter;
    use array_map;
    use array_values;
    use count;
    use explode;
    use in_array;
    use strpos;
    use trim;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExecutionOrderDependency
    {
        /**
         * @var string
         */
        private $className = '';

        /**
         * @var string
         */
        private $methodName = '';

        /**
         * @var bool
         */
        private $useShallowClone = false;

        /**
         * @var bool
         */
        private $useDeepClone = false;

        public static function createFromDependsAnnotation(string $className, string $annotation): self {}

        /**
         * @psalm-param list<ExecutionOrderDependency> $dependencies
         *
         * @psalm-return list<ExecutionOrderDependency>
         */
        public static function filterInvalid(array $dependencies): array {}

        /**
         * @psalm-param list<ExecutionOrderDependency> $existing
         * @psalm-param list<ExecutionOrderDependency> $additional
         *
         * @psalm-return list<ExecutionOrderDependency>
         */
        public static function mergeUnique(array $existing, array $additional): array {}

        /**
         * @psalm-param list<ExecutionOrderDependency> $left
         * @psalm-param list<ExecutionOrderDependency> $right
         *
         * @psalm-return list<ExecutionOrderDependency>
         */
        public static function diff(array $left, array $right): array {}

        public function __construct(string $classOrCallableName, ?string $methodName = null, ?string $option = null) {}

        public function __toString(): string {}

        public function isValid(): bool {}

        public function useShallowClone(): bool {}

        public function useDeepClone(): bool {}

        public function targetIsClass(): bool {}

        public function getTarget(): string {}

        public function getTargetClassName(): string {}

    }
}

namespace PHPUnit\Framework
{
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface IncompleteTest
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IncompleteTestCase extends \PHPUnit\Framework\TestCase
    {
        /**
         * @var bool
         */
        protected $backupGlobals = false;

        /**
         * @var bool
         */
        protected $backupStaticAttributes = false;

        /**
         * @var bool
         */
        protected $runTestInSeparateProcess = false;

        /**
         * @var bool
         */
        protected $useErrorHandler = false;

        /**
         * @var string
         */
        private $message;

        public function __construct(string $className, string $methodName, string $message = '') {}

        public function getMessage(): string {}

        /**
         * Returns a string representation of the test case.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * @throws Exception
         */
        protected function runTest(): \void {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvalidParameterGroupException extends \PHPUnit\Framework\Exception
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Reorderable
    {
        public function sortId(): string;

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function provides(): array;

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function requires(): array;

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface SelfDescribing
    {
        /**
         * Returns a string representation of the object.
         */
        public function toString(): string;

    }
}

namespace PHPUnit\Framework
{
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface SkippedTest
    {
    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SkippedTestCase extends \PHPUnit\Framework\TestCase
    {
        /**
         * @var bool
         */
        protected $backupGlobals = false;

        /**
         * @var bool
         */
        protected $backupStaticAttributes = false;

        /**
         * @var bool
         */
        protected $runTestInSeparateProcess = false;

        /**
         * @var bool
         */
        protected $useErrorHandler = false;

        /**
         * @var string
         */
        private $message;

        public function __construct(string $className, string $methodName, string $message = '') {}

        public function getMessage(): string {}

        /**
         * Returns a string representation of the test case.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function toString(): string {}

        /**
         * @throws Exception
         */
        protected function runTest(): \void {}

    }
}

namespace PHPUnit\Framework
{
    use Countable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface Test
    {
        /**
         * Runs a test and collects its result in a TestResult instance.
         */
        public function run(?\PHPUnit\Framework\TestResult $result = null): \PHPUnit\Framework\TestResult;

    }
}

namespace PHPUnit\Framework
{
    use assert;
    use count;
    use get_class;
    use sprintf;
    use trim;
    use PHPUnit\Util\Filter;
    use PHPUnit\Util\InvalidDataSetException;
    use PHPUnit\Util\Test as TestUtil;
    use ReflectionClass;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestBuilder
    {
        public function build(\ReflectionClass $theClass, string $methodName): \PHPUnit\Framework\Test {}

        /** @psalm-param class-string $className */
        private function buildTestWithoutData(string $className) {}

        /** @psalm-param class-string $className */
        private function buildDataProviderTestSuite(string $methodName, string $className, $data, bool $runTestInSeparateProcess, ?bool $preserveGlobalState, bool $runClassInSeparateProcess, array $backupSettings): \PHPUnit\Framework\DataProviderTestSuite {}

        private function configureTestCase(\PHPUnit\Framework\TestCase $test, bool $runTestInSeparateProcess, ?bool $preserveGlobalState, bool $runClassInSeparateProcess, array $backupSettings): \void {}

        private function throwableToString(\Throwable $t): string {}

    }
}

namespace PHPUnit\Framework
{
    use LC_ALL;
    use LC_COLLATE;
    use LC_CTYPE;
    use LC_MONETARY;
    use LC_NUMERIC;
    use LC_TIME;
    use PATHINFO_FILENAME;
    use PHP_EOL;
    use PHP_URL_PATH;
    use array_filter;
    use array_flip;
    use array_keys;
    use array_merge;
    use array_pop;
    use array_search;
    use array_unique;
    use array_values;
    use basename;
    use call_user_func;
    use chdir;
    use class_exists;
    use clearstatcache;
    use count;
    use debug_backtrace;
    use defined;
    use explode;
    use get_class;
    use get_include_path;
    use getcwd;
    use implode;
    use in_array;
    use ini_set;
    use is_array;
    use is_callable;
    use is_int;
    use is_object;
    use is_string;
    use libxml_clear_errors;
    use method_exists;
    use ob_end_clean;
    use ob_get_contents;
    use ob_get_level;
    use ob_start;
    use parse_url;
    use pathinfo;
    use preg_replace;
    use serialize;
    use setlocale;
    use sprintf;
    use strpos;
    use substr;
    use trim;
    use var_export;
    use DeepCopy\DeepCopy;
    use PHPUnit\Framework\Constraint\Exception as ExceptionConstraint;
    use PHPUnit\Framework\Constraint\ExceptionCode;
    use PHPUnit\Framework\Constraint\ExceptionMessage;
    use PHPUnit\Framework\Constraint\ExceptionMessageRegularExpression;
    use PHPUnit\Framework\Error\Deprecated;
    use PHPUnit\Framework\Error\Error;
    use PHPUnit\Framework\Error\Notice;
    use PHPUnit\Framework\Error\Warning as WarningError;
    use PHPUnit\Framework\MockObject\Generator as MockGenerator;
    use PHPUnit\Framework\MockObject\MockBuilder;
    use PHPUnit\Framework\MockObject\MockObject;
    use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount as AnyInvokedCountMatcher;
    use PHPUnit\Framework\MockObject\Rule\InvokedAtIndex as InvokedAtIndexMatcher;
    use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount as InvokedAtLeastCountMatcher;
    use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce as InvokedAtLeastOnceMatcher;
    use PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount as InvokedAtMostCountMatcher;
    use PHPUnit\Framework\MockObject\Rule\InvokedCount as InvokedCountMatcher;
    use PHPUnit\Framework\MockObject\Stub;
    use PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls as ConsecutiveCallsStub;
    use PHPUnit\Framework\MockObject\Stub\Exception as ExceptionStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnArgument as ReturnArgumentStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnCallback as ReturnCallbackStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnSelf as ReturnSelfStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnValueMap as ReturnValueMapStub;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\Util\Exception as UtilException;
    use PHPUnit\Util\GlobalState;
    use PHPUnit\Util\PHP\AbstractPhpProcess;
    use PHPUnit\Util\Test as TestUtil;
    use PHPUnit\Util\Type;
    use Prophecy\Exception\Prediction\PredictionException;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophet;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\Comparator\Comparator;
    use SebastianBergmann\Comparator\Factory as ComparatorFactory;
    use SebastianBergmann\Diff\Differ;
    use SebastianBergmann\Exporter\Exporter;
    use SebastianBergmann\GlobalState\ExcludeList;
    use SebastianBergmann\GlobalState\Restorer;
    use SebastianBergmann\GlobalState\Snapshot;
    use SebastianBergmann\ObjectEnumerator\Enumerator;
    use SebastianBergmann\Template\Template;
    use SoapClient;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    abstract class TestCase extends \PHPUnit\Framework\Assert
    {
        const LOCALE_CATEGORIES = [/** value is missing */];

        /**
         * @var ?bool
         */
        protected $backupGlobals;

        /**
         * @var string[]
         */
        protected $backupGlobalsExcludeList = [/** value is missing */];

        /**
         * @var string[]
         *
         * @deprecated Use $backupGlobalsExcludeList instead
         */
        protected $backupGlobalsBlacklist = [/** value is missing */];

        /**
         * @var bool
         */
        protected $backupStaticAttributes;

        /**
         * @var array<string,array<int,string>>
         */
        protected $backupStaticAttributesExcludeList = [/** value is missing */];

        /**
         * @var array<string,array<int,string>>
         *
         * @deprecated Use $backupStaticAttributesExcludeList instead
         */
        protected $backupStaticAttributesBlacklist = [/** value is missing */];

        /**
         * @var bool
         */
        protected $runTestInSeparateProcess;

        /**
         * @var bool
         */
        protected $preserveGlobalState = true;

        /**
         * @var list<ExecutionOrderDependency>
         */
        protected $providedTests = [/** value is missing */];

        /**
         * @var bool
         */
        private $runClassInSeparateProcess;

        /**
         * @var bool
         */
        private $inIsolation = false;

        /**
         * @var array
         */
        private $data;

        /**
         * @var int|string
         */
        private $dataName;

        /**
         * @var null|string
         */
        private $expectedException;

        /**
         * @var null|string
         */
        private $expectedExceptionMessage;

        /**
         * @var null|string
         */
        private $expectedExceptionMessageRegExp;

        /**
         * @var null|int|string
         */
        private $expectedExceptionCode;

        /**
         * @var string
         */
        private $name = '';

        /**
         * @var list<ExecutionOrderDependency>
         */
        private $dependencies = [/** value is missing */];

        /**
         * @var array
         */
        private $dependencyInput = [/** value is missing */];

        /**
         * @var array<string,string>
         */
        private $iniSettings = [/** value is missing */];

        /**
         * @var array
         */
        private $locale = [/** value is missing */];

        /**
         * @var MockObject[]
         */
        private $mockObjects = [/** value is missing */];

        /**
         * @var MockGenerator
         */
        private $mockObjectGenerator;

        /**
         * @var int
         */
        private $status;

        /**
         * @var string
         */
        private $statusMessage = '';

        /**
         * @var int
         */
        private $numAssertions = 0;

        /**
         * @var TestResult
         */
        private $result;

        /**
         * @var mixed
         */
        private $testResult;

        /**
         * @var string
         */
        private $output = '';

        /**
         * @var string
         */
        private $outputExpectedRegex;

        /**
         * @var string
         */
        private $outputExpectedString;

        /**
         * @var mixed
         */
        private $outputCallback = false;

        /**
         * @var bool
         */
        private $outputBufferingActive = false;

        /**
         * @var int
         */
        private $outputBufferingLevel;

        /**
         * @var bool
         */
        private $outputRetrievedForAssertion = false;

        /**
         * @var Snapshot
         */
        private $snapshot;

        /**
         * @var \Prophecy\Prophet
         */
        private $prophet;

        /**
         * @var bool
         */
        private $beStrictAboutChangesToGlobalState = false;

        /**
         * @var bool
         */
        private $registerMockObjectsFromTestArgumentsRecursively = false;

        /**
         * @var string[]
         */
        private $warnings = [/** value is missing */];

        /**
         * @var string[]
         */
        private $groups = [/** value is missing */];

        /**
         * @var bool
         */
        private $doesNotPerformAssertions = false;

        /**
         * @var Comparator[]
         */
        private $customComparators = [/** value is missing */];

        /**
         * @var string[]
         */
        private $doubledTypes = [/** value is missing */];

        /**
         * Returns a matcher that matches when the method is executed
         * zero or more times.
         */
        public static function any(): \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount {}

        /**
         * Returns a matcher that matches when the method is never executed.
         */
        public static function never(): \PHPUnit\Framework\MockObject\Rule\InvokedCount {}

        /**
         * Returns a matcher that matches when the method is executed
         * at least N times.
         */
        public static function atLeast(int $requiredInvocations): \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount {}

        /**
         * Returns a matcher that matches when the method is executed at least once.
         */
        public static function atLeastOnce(): \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce {}

        /**
         * Returns a matcher that matches when the method is executed exactly once.
         */
        public static function once(): \PHPUnit\Framework\MockObject\Rule\InvokedCount {}

        /**
         * Returns a matcher that matches when the method is executed
         * exactly $count times.
         */
        public static function exactly(int $count): \PHPUnit\Framework\MockObject\Rule\InvokedCount {}

        /**
         * Returns a matcher that matches when the method is executed
         * at most N times.
         */
        public static function atMost(int $allowedInvocations): \PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount {}

        /**
         * Returns a matcher that matches when the method is executed
         * at the given index.
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4297
         * @codeCoverageIgnore
         */
        public static function at(int $index): \PHPUnit\Framework\MockObject\Rule\InvokedAtIndex {}

        public static function returnValue($value): \PHPUnit\Framework\MockObject\Stub\ReturnStub {}

        public static function returnValueMap(array $valueMap): \PHPUnit\Framework\MockObject\Stub\ReturnValueMap {}

        public static function returnArgument(int $argumentIndex): \PHPUnit\Framework\MockObject\Stub\ReturnArgument {}

        public static function returnCallback($callback): \PHPUnit\Framework\MockObject\Stub\ReturnCallback {}

        /**
         * Returns the current object.
         *
         * This method is useful when mocking a fluent interface.
         */
        public static function returnSelf(): \PHPUnit\Framework\MockObject\Stub\ReturnSelf {}

        public static function throwException(\Throwable $exception): \PHPUnit\Framework\MockObject\Stub\Exception {}

        public static function onConsecutiveCalls(...$args): \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls {}

        /**
         * @param int|string $dataName
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function __construct(?string $name = null, array $data = [/** value is missing */], $dataName = '') {}

        /**
         * This method is called before the first test of this test class is run.
         */
        public static function setUpBeforeClass(): \void {}

        /**
         * This method is called after the last test of this test class is run.
         */
        public static function tearDownAfterClass(): \void {}

        /**
         * This method is called before each test.
         */
        protected function setUp(): \void {}

        /**
         * This method is called after each test.
         */
        protected function tearDown(): \void {}

        /**
         * Returns a string representation of the test case.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        public function toString(): string {}

        public function count(): int {}

        public function getActualOutputForAssertion(): string {}

        public function expectOutputRegex(string $expectedRegex): \void {}

        public function expectOutputString(string $expectedString): \void {}

        /**
         * @psalm-param class-string<\Throwable> $exception
         */
        public function expectException(string $exception): \void {}

        /**
         * @param int|string $code
         */
        public function expectExceptionCode($code): \void {}

        public function expectExceptionMessage(string $message): \void {}

        public function expectExceptionMessageMatches(string $regularExpression): \void {}

        /**
         * Sets up an expectation for an exception to be raised by the code under test.
         * Information for expected exception class, expected exception message, and
         * expected exception code are retrieved from a given Exception object.
         */
        public function expectExceptionObject(\Exception $exception): \void {}

        public function expectNotToPerformAssertions(): \void {}

        public function expectDeprecation(): \void {}

        public function expectDeprecationMessage(string $message): \void {}

        public function expectDeprecationMessageMatches(string $regularExpression): \void {}

        public function expectNotice(): \void {}

        public function expectNoticeMessage(string $message): \void {}

        public function expectNoticeMessageMatches(string $regularExpression): \void {}

        public function expectWarning(): \void {}

        public function expectWarningMessage(string $message): \void {}

        public function expectWarningMessageMatches(string $regularExpression): \void {}

        public function expectError(): \void {}

        public function expectErrorMessage(string $message): \void {}

        public function expectErrorMessageMatches(string $regularExpression): \void {}

        public function getStatus(): int {}

        public function markAsRisky(): \void {}

        public function getStatusMessage(): string {}

        public function hasFailed(): bool {}

        /**
         * Runs the test case and collects the results in a TestResult object.
         * If no TestResult object is passed a new one will be created.
         *
         * @throws CodeCoverageException
         * @throws UtilException
         * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
         * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function run(?\PHPUnit\Framework\TestResult $result = null): \PHPUnit\Framework\TestResult {}

        /**
         * Returns a builder object to create mock objects using a fluent interface.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $className
         * @psalm-return MockBuilder<RealInstanceType>
         */
        public function getMockBuilder(string $className): \PHPUnit\Framework\MockObject\MockBuilder {}

        public function registerComparator(\SebastianBergmann\Comparator\Comparator $comparator): \void {}

        /**
         * @return string[]
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function doubledTypes(): array {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getGroups(): array {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setGroups(array $groups): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getAnnotations(): array {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getName(bool $withDataSet = true): string {}

        /**
         * Returns the size of the test.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getSize(): int {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function hasSize(): bool {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function isSmall(): bool {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function isMedium(): bool {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function isLarge(): bool {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getActualOutput(): string {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function hasOutput(): bool {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function doesNotPerformAssertions(): bool {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function hasExpectationOnOutput(): bool {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getExpectedException(): ?string {}

        /**
         * @return null|int|string
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getExpectedExceptionCode() {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getExpectedExceptionMessage(): ?string {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getExpectedExceptionMessageRegExp(): ?string {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setRegisterMockObjectsFromTestArgumentsRecursively(bool $flag): \void {}

        /**
         * @throws Throwable
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function runBare(): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setName(string $name): \void {}

        /**
         * @param list<ExecutionOrderDependency> $dependencies
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setDependencies(array $dependencies): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setDependencyInput(array $dependencyInput): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setBeStrictAboutChangesToGlobalState(?bool $beStrictAboutChangesToGlobalState): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setBackupGlobals(?bool $backupGlobals): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setBackupStaticAttributes(?bool $backupStaticAttributes): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setRunTestInSeparateProcess(bool $runTestInSeparateProcess): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setRunClassInSeparateProcess(bool $runClassInSeparateProcess): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setPreserveGlobalState(bool $preserveGlobalState): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setInIsolation(bool $inIsolation): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function isInIsolation(): bool {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getResult() {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setResult($result): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setOutputCallback(callable $callback): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getTestResultObject(): ?\PHPUnit\Framework\TestResult {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function setTestResultObject(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function registerMockObject(\PHPUnit\Framework\MockObject\MockObject $mockObject): \void {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function addToAssertionCount(int $count): \void {}

        /**
         * Returns the number of assertions performed by this test.
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getNumAssertions(): int {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function usesDataProvider(): bool {}

        /**
         * @return int|string
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function dataName() {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getDataSetAsString(bool $includeData = true): string {}

        /**
         * Gets the data set of a TestCase.
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function getProvidedData(): array {}

        /**
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        public function addWarning(string $warning): \void {}

        public function sortId(): string {}

        /**
         * Returns the normalized test name as class::method.
         *
         * @return list<ExecutionOrderDependency>
         */
        public function provides(): array {}

        /**
         * Returns a list of normalized dependency names, class::method.
         *
         * This list can differ from the raw dependencies as the resolver has
         * no need for the [!][shallow]clone prefix that is filtered out
         * during normalization.
         *
         * @return list<ExecutionOrderDependency>
         */
        public function requires(): array {}

        /**
         * Override to run the test and assert its state.
         *
         * @throws AssertionFailedError
         * @throws Exception
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
         * @throws Throwable
         */
        protected function runTest() {}

        /**
         * This method is a wrapper for the ini_set() function that automatically
         * resets the modified php.ini setting to its original value after the
         * test is run.
         *
         * @throws Exception
         */
        protected function iniSet(string $varName, string $newValue): \void {}

        /**
         * This method is a wrapper for the setlocale() function that automatically
         * resets the locale to its original value after the test is run.
         *
         * @throws Exception
         */
        protected function setLocale(...$args): \void {}

        /**
         * Makes configurable stub for the specified class.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param    class-string<RealInstanceType> $originalClassName
         * @psalm-return   Stub&RealInstanceType
         */
        protected function createStub(string $originalClassName): \PHPUnit\Framework\MockObject\Stub {}

        /**
         * Returns a mock object for the specified class.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function createMock(string $originalClassName): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a configured mock object for the specified class.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function createConfiguredMock(string $originalClassName, array $configuration): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a partial mock object for the specified class.
         *
         * @param string[] $methods
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function createPartialMock(string $originalClassName, array $methods): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a test proxy for the specified class.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function createTestProxy(string $originalClassName, array $constructorArguments = [/** value is missing */]): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Mocks the specified class and returns the name of the mocked class.
         *
         * @param null|array $methods $methods
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType>|string $originalClassName
         * @psalm-return class-string<MockObject&RealInstanceType>
         */
        protected function getMockClass(string $originalClassName, $methods = [/** value is missing */], array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = false, bool $callOriginalClone = true, bool $callAutoload = true, bool $cloneArguments = false): string {}

        /**
         * Returns a mock object for the specified abstract class with all abstract
         * methods of the class mocked. Concrete methods are not mocked by default.
         * To mock concrete methods, use the 7th parameter ($mockedMethods).
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function getMockForAbstractClass(string $originalClassName, array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true, array $mockedMethods = [/** value is missing */], bool $cloneArguments = false): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a mock object based on the given WSDL file.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType>|string $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        protected function getMockFromWsdl(string $wsdlFile, string $originalClassName = '', string $mockClassName = '', array $methods = [/** value is missing */], bool $callOriginalConstructor = true, array $options = [/** value is missing */]): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a mock object for the specified trait with all abstract methods
         * of the trait mocked. Concrete methods to mock can be specified with the
         * `$mockedMethods` parameter.
         *
         * @psalm-param trait-string $traitName
         */
        protected function getMockForTrait(string $traitName, array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true, array $mockedMethods = [/** value is missing */], bool $cloneArguments = false): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns an object for the specified trait.
         *
         * @psalm-param trait-string $traitName
         */
        protected function getObjectForTrait(string $traitName, array $arguments = [/** value is missing */], string $traitClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true): object {}

        /**
         * @throws \Prophecy\Exception\Doubler\ClassNotFoundException
         * @throws \Prophecy\Exception\Doubler\DoubleException
         * @throws \Prophecy\Exception\Doubler\InterfaceNotFoundException
         *
         * @psalm-param class-string|null $classOrInterface
         */
        protected function prophesize(?string $classOrInterface = null): \Prophecy\Prophecy\ObjectProphecy {}

        /**
         * Creates a default TestResult object.
         *
         * @internal This method is not covered by the backward compatibility promise for PHPUnit
         */
        protected function createResult(): \PHPUnit\Framework\TestResult {}

        /**
         * Performs assertions shared by all tests of a test case.
         *
         * This method is called between setUp() and test.
         */
        protected function assertPreConditions(): \void {}

        /**
         * Performs assertions shared by all tests of a test case.
         *
         * This method is called between test and tearDown().
         */
        protected function assertPostConditions(): \void {}

        /**
         * This method is called when a test method did not execute successfully.
         *
         * @throws Throwable
         */
        protected function onNotSuccessfulTest(\Throwable $t): \void {}

        protected function recordDoubledType(string $originalClassName): \void {}

        /**
         * @throws Throwable
         */
        private function verifyMockObjects(): \void {}

        /**
         * @throws Warning
         * @throws SkippedTestError
         * @throws SyntheticSkippedError
         */
        private function checkRequirements(): \void {}

        private function handleDependencies(): bool {}

        private function markSkippedForNotSpecifyingDependency(): \void {}

        private function markSkippedForMissingDependency(\PHPUnit\Framework\ExecutionOrderDependency $dependency): \void {}

        private function markWarningForUncallableDependency(\PHPUnit\Framework\ExecutionOrderDependency $dependency): \void {}

        /**
         * Get the mock object generator, creating it if it doesn't exist.
         */
        private function getMockObjectGenerator(): \PHPUnit\Framework\MockObject\Generator {}

        private function startOutputBuffering(): \void {}

        /**
         * @throws RiskyTestError
         */
        private function stopOutputBuffering(): \void {}

        private function snapshotGlobalState(): \void {}

        /**
         * @throws RiskyTestError
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function restoreGlobalState(): \void {}

        private function createGlobalStateSnapshot(bool $backupGlobals): \SebastianBergmann\GlobalState\Snapshot {}

        /**
         * @throws RiskyTestError
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function compareGlobalStateSnapshots(\SebastianBergmann\GlobalState\Snapshot $before, \SebastianBergmann\GlobalState\Snapshot $after): \void {}

        /**
         * @throws RiskyTestError
         */
        private function compareGlobalStateSnapshotPart(array $before, array $after, string $header): \void {}

        private function getProphet(): \Prophecy\Prophet {}

        /**
         * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
         */
        private function shouldInvocationMockerBeReset(\PHPUnit\Framework\MockObject\MockObject $mock): bool {}

        /**
         * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
         * @throws \SebastianBergmann\ObjectReflector\InvalidArgumentException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function registerMockObjectsFromTestArguments(array $testArguments, array &$visited = [/** value is missing */]): \void {}

        private function setDoesNotPerformAssertionsFromAnnotation(): \void {}

        private function unregisterCustomComparators(): \void {}

        private function cleanupIniSettings(): \void {}

        private function cleanupLocaleSettings(): \void {}

        /**
         * @throws Exception
         */
        private function checkExceptionExpectations(\Throwable $throwable): bool {}

        private function runInSeparateProcess(): bool {}

        private function isCallableTestMethod(string $dependency): bool {}

        /**
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         */
        private function createMockObject(string $originalClassName): \PHPUnit\Framework\MockObject\MockObject {}

    }
}

namespace PHPUnit\Framework
{
    use get_class;
    use sprintf;
    use trim;
    use PHPUnit\Framework\Error\Error;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestFailure
    {
        /**
         * @var null|Test
         */
        private $failedTest;

        /**
         * @var Throwable
         */
        private $thrownException;

        /**
         * @var string
         */
        private $testName;

        /**
         * Returns a description for an exception.
         */
        public static function exceptionToString(\Throwable $e): string {}

        /**
         * Constructs a TestFailure with the given test and exception.
         */
        public function __construct(\PHPUnit\Framework\Test $failedTest, \Throwable $t) {}

        /**
         * Returns a short description of the failure.
         */
        public function toString(): string {}

        /**
         * Returns a description for the thrown exception.
         */
        public function getExceptionAsString(): string {}

        /**
         * Returns the name of the failing test (including data set, if any).
         */
        public function getTestName(): string {}

        /**
         * Returns the failing test.
         *
         * Note: The test object is not set when the test is executed in process
         * isolation.
         *
         * @see Exception
         */
        public function failedTest(): ?\PHPUnit\Framework\Test {}

        /**
         * Gets the thrown exception.
         */
        public function thrownException(): \Throwable {}

        /**
         * Returns the exception's message.
         */
        public function exceptionMessage(): string {}

        /**
         * Returns true if the thrown exception
         * is of type AssertionFailedError.
         */
        public function isFailure(): bool {}

    }
}

namespace PHPUnit\Framework
{
    use Throwable;

    /**
     * @deprecated Use the `TestHook` interfaces instead
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface TestListener
    {
        /**
         * An error occurred.
         *
         * @deprecated Use `AfterTestErrorHook::executeAfterTestError` instead
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void;

        /**
         * A warning occurred.
         *
         * @deprecated Use `AfterTestWarningHook::executeAfterTestWarning` instead
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void;

        /**
         * A failure occurred.
         *
         * @deprecated Use `AfterTestFailureHook::executeAfterTestFailure` instead
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void;

        /**
         * Incomplete test.
         *
         * @deprecated Use `AfterIncompleteTestHook::executeAfterIncompleteTest` instead
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void;

        /**
         * Risky test.
         *
         * @deprecated Use `AfterRiskyTestHook::executeAfterRiskyTest` instead
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void;

        /**
         * Skipped test.
         *
         * @deprecated Use `AfterSkippedTestHook::executeAfterSkippedTest` instead
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void;

        /**
         * A test suite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void;

        /**
         * A test suite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void;

        /**
         * A test started.
         *
         * @deprecated Use `BeforeTestHook::executeBeforeTest` instead
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void;

        /**
         * A test ended.
         *
         * @deprecated Use `AfterTestHook::executeAfterTest` instead
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void;

    }
}

namespace PHPUnit\Framework
{
    use Throwable;

    /**
     * @deprecated The `TestListener` interface is deprecated
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    trait TestListenerDefaultImplementation
    {
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use count;
    use function_exists;
    use get_class;
    use sprintf;
    use AssertionError;
    use Countable;
    use Error;
    use PHPUnit\Framework\MockObject\Exception as MockObjectException;
    use PHPUnit\Util\ErrorHandler;
    use PHPUnit\Util\ExcludeList;
    use PHPUnit\Util\Printer;
    use PHPUnit\Util\Test as TestUtil;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Exception as OriginalCodeCoverageException;
    use SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException;
    use SebastianBergmann\Invoker\Invoker;
    use SebastianBergmann\Invoker\TimeoutException;
    use SebastianBergmann\ResourceOperations\ResourceOperations;
    use SebastianBergmann\Timer\Timer;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestResult
    {
        /**
         * @var array
         */
        private $passed = [/** value is missing */];

        /**
         * @var array<string>
         */
        private $passedTestClasses = [/** value is missing */];

        /**
         * @var bool
         */
        private $currentTestSuiteFailed = false;

        /**
         * @var TestFailure[]
         */
        private $errors = [/** value is missing */];

        /**
         * @var TestFailure[]
         */
        private $failures = [/** value is missing */];

        /**
         * @var TestFailure[]
         */
        private $warnings = [/** value is missing */];

        /**
         * @var TestFailure[]
         */
        private $notImplemented = [/** value is missing */];

        /**
         * @var TestFailure[]
         */
        private $risky = [/** value is missing */];

        /**
         * @var TestFailure[]
         */
        private $skipped = [/** value is missing */];

        /**
         * @deprecated Use the `TestHook` interfaces instead
         *
         * @var TestListener[]
         */
        private $listeners = [/** value is missing */];

        /**
         * @var int
         */
        private $runTests = 0;

        /**
         * @var float
         */
        private $time = 0;

        /**
         * @var TestSuite
         */
        private $topTestSuite;

        /**
         * Code Coverage information.
         *
         * @var CodeCoverage
         */
        private $codeCoverage;

        /**
         * @var bool
         */
        private $convertDeprecationsToExceptions = true;

        /**
         * @var bool
         */
        private $convertErrorsToExceptions = true;

        /**
         * @var bool
         */
        private $convertNoticesToExceptions = true;

        /**
         * @var bool
         */
        private $convertWarningsToExceptions = true;

        /**
         * @var bool
         */
        private $stop = false;

        /**
         * @var bool
         */
        private $stopOnError = false;

        /**
         * @var bool
         */
        private $stopOnFailure = false;

        /**
         * @var bool
         */
        private $stopOnWarning = false;

        /**
         * @var bool
         */
        private $beStrictAboutTestsThatDoNotTestAnything = true;

        /**
         * @var bool
         */
        private $beStrictAboutOutputDuringTests = false;

        /**
         * @var bool
         */
        private $beStrictAboutTodoAnnotatedTests = false;

        /**
         * @var bool
         */
        private $beStrictAboutResourceUsageDuringSmallTests = false;

        /**
         * @var bool
         */
        private $enforceTimeLimit = false;

        /**
         * @var bool
         */
        private $forceCoversAnnotation = false;

        /**
         * @var int
         */
        private $timeoutForSmallTests = 1;

        /**
         * @var int
         */
        private $timeoutForMediumTests = 10;

        /**
         * @var int
         */
        private $timeoutForLargeTests = 60;

        /**
         * @var bool
         */
        private $stopOnRisky = false;

        /**
         * @var bool
         */
        private $stopOnIncomplete = false;

        /**
         * @var bool
         */
        private $stopOnSkipped = false;

        /**
         * @var bool
         */
        private $lastTestFailed = false;

        /**
         * @var int
         */
        private $defaultTimeLimit = 0;

        /**
         * @var bool
         */
        private $stopOnDefect = false;

        /**
         * @var bool
         */
        private $registerMockObjectsFromTestArgumentsRecursively = false;

        /**
         * @deprecated Use the `TestHook` interfaces instead
         *
         * @codeCoverageIgnore
         *
         * Registers a TestListener.
         */
        public function addListener(\PHPUnit\Framework\TestListener $listener): \void {}

        /**
         * @deprecated Use the `TestHook` interfaces instead
         *
         * @codeCoverageIgnore
         *
         * Unregisters a TestListener.
         */
        public function removeListener(\PHPUnit\Framework\TestListener $listener): \void {}

        /**
         * @deprecated Use the `TestHook` interfaces instead
         *
         * @codeCoverageIgnore
         *
         * Flushes all flushable TestListeners.
         */
        public function flushListeners(): \void {}

        /**
         * Adds an error to the list of errors.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Adds a warning to the list of warnings.
         * The passed in exception caused the warning.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * Adds a failure to the list of failures.
         * The passed in exception caused the failure.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * Informs the result that a test suite will be started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * Informs the result that a test suite was completed.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * Informs the result that a test will be started.
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * Informs the result that a test was completed.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        /**
         * Returns true if no risky test occurred.
         */
        public function allHarmless(): bool {}

        /**
         * Gets the number of risky tests.
         */
        public function riskyCount(): int {}

        /**
         * Returns true if no incomplete test occurred.
         */
        public function allCompletelyImplemented(): bool {}

        /**
         * Gets the number of incomplete tests.
         */
        public function notImplementedCount(): int {}

        /**
         * Returns an array of TestFailure objects for the risky tests.
         *
         * @return TestFailure[]
         */
        public function risky(): array {}

        /**
         * Returns an array of TestFailure objects for the incomplete tests.
         *
         * @return TestFailure[]
         */
        public function notImplemented(): array {}

        /**
         * Returns true if no test has been skipped.
         */
        public function noneSkipped(): bool {}

        /**
         * Gets the number of skipped tests.
         */
        public function skippedCount(): int {}

        /**
         * Returns an array of TestFailure objects for the skipped tests.
         *
         * @return TestFailure[]
         */
        public function skipped(): array {}

        /**
         * Gets the number of detected errors.
         */
        public function errorCount(): int {}

        /**
         * Returns an array of TestFailure objects for the errors.
         *
         * @return TestFailure[]
         */
        public function errors(): array {}

        /**
         * Gets the number of detected failures.
         */
        public function failureCount(): int {}

        /**
         * Returns an array of TestFailure objects for the failures.
         *
         * @return TestFailure[]
         */
        public function failures(): array {}

        /**
         * Gets the number of detected warnings.
         */
        public function warningCount(): int {}

        /**
         * Returns an array of TestFailure objects for the warnings.
         *
         * @return TestFailure[]
         */
        public function warnings(): array {}

        /**
         * Returns the names of the tests that have passed.
         */
        public function passed(): array {}

        /**
         * Returns the names of the TestSuites that have passed.
         *
         * This enables @depends-annotations for TestClassName::class
         */
        public function passedClasses(): array {}

        /**
         * Returns the (top) test suite.
         */
        public function topTestSuite(): \PHPUnit\Framework\TestSuite {}

        /**
         * Returns whether code coverage information should be collected.
         */
        public function getCollectCodeCoverageInformation(): bool {}

        /**
         * Runs a TestCase.
         *
         * @throws CodeCoverageException
         * @throws UnintentionallyCoveredCodeException
         * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function run(\PHPUnit\Framework\Test $test): \void {}

        /**
         * Gets the number of run tests.
         */
        public function count(): int {}

        /**
         * Checks whether the test run should stop.
         */
        public function shouldStop(): bool {}

        /**
         * Marks that the test run should stop.
         */
        public function stop(): \void {}

        /**
         * Returns the code coverage object.
         */
        public function getCodeCoverage(): ?\SebastianBergmann\CodeCoverage\CodeCoverage {}

        /**
         * Sets the code coverage object.
         */
        public function setCodeCoverage(\SebastianBergmann\CodeCoverage\CodeCoverage $codeCoverage): \void {}

        /**
         * Enables or disables the deprecation-to-exception conversion.
         */
        public function convertDeprecationsToExceptions(bool $flag): \void {}

        /**
         * Returns the deprecation-to-exception conversion setting.
         */
        public function getConvertDeprecationsToExceptions(): bool {}

        /**
         * Enables or disables the error-to-exception conversion.
         */
        public function convertErrorsToExceptions(bool $flag): \void {}

        /**
         * Returns the error-to-exception conversion setting.
         */
        public function getConvertErrorsToExceptions(): bool {}

        /**
         * Enables or disables the notice-to-exception conversion.
         */
        public function convertNoticesToExceptions(bool $flag): \void {}

        /**
         * Returns the notice-to-exception conversion setting.
         */
        public function getConvertNoticesToExceptions(): bool {}

        /**
         * Enables or disables the warning-to-exception conversion.
         */
        public function convertWarningsToExceptions(bool $flag): \void {}

        /**
         * Returns the warning-to-exception conversion setting.
         */
        public function getConvertWarningsToExceptions(): bool {}

        /**
         * Enables or disables the stopping when an error occurs.
         */
        public function stopOnError(bool $flag): \void {}

        /**
         * Enables or disables the stopping when a failure occurs.
         */
        public function stopOnFailure(bool $flag): \void {}

        /**
         * Enables or disables the stopping when a warning occurs.
         */
        public function stopOnWarning(bool $flag): \void {}

        public function beStrictAboutTestsThatDoNotTestAnything(bool $flag): \void {}

        public function isStrictAboutTestsThatDoNotTestAnything(): bool {}

        public function beStrictAboutOutputDuringTests(bool $flag): \void {}

        public function isStrictAboutOutputDuringTests(): bool {}

        public function beStrictAboutResourceUsageDuringSmallTests(bool $flag): \void {}

        public function isStrictAboutResourceUsageDuringSmallTests(): bool {}

        public function enforceTimeLimit(bool $flag): \void {}

        public function enforcesTimeLimit(): bool {}

        public function beStrictAboutTodoAnnotatedTests(bool $flag): \void {}

        public function isStrictAboutTodoAnnotatedTests(): bool {}

        public function forceCoversAnnotation(): \void {}

        public function forcesCoversAnnotation(): bool {}

        /**
         * Enables or disables the stopping for risky tests.
         */
        public function stopOnRisky(bool $flag): \void {}

        /**
         * Enables or disables the stopping for incomplete tests.
         */
        public function stopOnIncomplete(bool $flag): \void {}

        /**
         * Enables or disables the stopping for skipped tests.
         */
        public function stopOnSkipped(bool $flag): \void {}

        /**
         * Enables or disables the stopping for defects: error, failure, warning.
         */
        public function stopOnDefect(bool $flag): \void {}

        /**
         * Returns the time spent running the tests.
         */
        public function time(): float {}

        /**
         * Returns whether the entire test was successful or not.
         */
        public function wasSuccessful(): bool {}

        public function wasSuccessfulIgnoringWarnings(): bool {}

        public function wasSuccessfulAndNoTestIsRiskyOrSkippedOrIncomplete(): bool {}

        /**
         * Sets the default timeout for tests.
         */
        public function setDefaultTimeLimit(int $timeout): \void {}

        /**
         * Sets the timeout for small tests.
         */
        public function setTimeoutForSmallTests(int $timeout): \void {}

        /**
         * Sets the timeout for medium tests.
         */
        public function setTimeoutForMediumTests(int $timeout): \void {}

        /**
         * Sets the timeout for large tests.
         */
        public function setTimeoutForLargeTests(int $timeout): \void {}

        /**
         * Returns the set timeout for large tests.
         */
        public function getTimeoutForLargeTests(): int {}

        public function setRegisterMockObjectsFromTestArgumentsRecursively(bool $flag): \void {}

    }
}

namespace PHPUnit\Framework
{
    use PHP_EOL;
    use array_diff;
    use array_keys;
    use array_merge;
    use array_unique;
    use basename;
    use call_user_func;
    use class_exists;
    use count;
    use dirname;
    use get_declared_classes;
    use implode;
    use is_bool;
    use is_callable;
    use is_file;
    use is_object;
    use is_string;
    use method_exists;
    use preg_match;
    use preg_quote;
    use sprintf;
    use strpos;
    use substr;
    use Iterator;
    use IteratorAggregate;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\Runner\Filter\Factory;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\Util\FileLoader;
    use PHPUnit\Util\Test as TestUtil;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionMethod;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class TestSuite
    {
        /**
         * Enable or disable the backup and restoration of the $GLOBALS array.
         *
         * @var bool
         */
        protected $backupGlobals;

        /**
         * Enable or disable the backup and restoration of static attributes.
         *
         * @var bool
         */
        protected $backupStaticAttributes;

        /**
         * @var bool
         */
        protected $runTestInSeparateProcess = false;

        /**
         * The name of the test suite.
         *
         * @var string
         */
        protected $name = '';

        /**
         * The test groups of the test suite.
         *
         * @var array
         */
        protected $groups = [/** value is missing */];

        /**
         * The tests in the test suite.
         *
         * @var Test[]
         */
        protected $tests = [/** value is missing */];

        /**
         * The number of tests in the test suite.
         *
         * @var int
         */
        protected $numTests;

        /**
         * @var bool
         */
        protected $testCase = false;

        /**
         * @var string[]
         */
        protected $foundClasses = [/** value is missing */];

        /**
         * @var null|list<ExecutionOrderDependency>
         */
        protected $providedTests;

        /**
         * @var null|list<ExecutionOrderDependency>
         */
        protected $requiredTests;

        /**
         * @var bool
         */
        private $beStrictAboutChangesToGlobalState;

        /**
         * @var Factory
         */
        private $iteratorFilter;

        /**
         * @var string[]
         */
        private $declaredClasses;

        /**
         * @psalm-var array<int,string>
         */
        private $warnings = [/** value is missing */];

        /**
         * Constructs a new TestSuite.
         *
         *   - PHPUnit\Framework\TestSuite() constructs an empty TestSuite.
         *
         *   - PHPUnit\Framework\TestSuite(ReflectionClass) constructs a
         *     TestSuite from the given class.
         *
         *   - PHPUnit\Framework\TestSuite(ReflectionClass, String)
         *     constructs a TestSuite from the given class with the given
         *     name.
         *
         *   - PHPUnit\Framework\TestSuite(String) either constructs a
         *     TestSuite from the given class (if the passed string is the
         *     name of an existing class) or constructs an empty TestSuite
         *     with the given name.
         *
         * @param ReflectionClass|string $theClass
         *
         * @throws Exception
         */
        public function __construct($theClass = '', string $name = '') {}

        /**
         * Returns a string representation of the test suite.
         */
        public function toString(): string {}

        /**
         * Adds a test to the suite.
         *
         * @param array $groups
         */
        public function addTest(\PHPUnit\Framework\Test $test, $groups = [/** value is missing */]): \void {}

        /**
         * Adds the tests from the given class to the suite.
         *
         * @psalm-param object|class-string $testClass
         *
         * @throws Exception
         */
        public function addTestSuite($testClass): \void {}

        public function addWarning(string $warning): \void {}

        /**
         * Wraps both <code>addTest()</code> and <code>addTestSuite</code>
         * as well as the separate import statements for the user's convenience.
         *
         * If the named file cannot be read or there are no new tests that can be
         * added, a <code>PHPUnit\Framework\WarningTestCase</code> will be created instead,
         * leaving the current test run untouched.
         *
         * @throws Exception
         */
        public function addTestFile(string $filename): \void {}

        /**
         * Wrapper for addTestFile() that adds multiple test files.
         *
         * @throws Exception
         */
        public function addTestFiles(\iterable $fileNames): \void {}

        /**
         * Counts the number of test cases that will be run by this test.
         *
         * @todo refactor usage of numTests in DefaultResultPrinter
         */
        public function count(): int {}

        /**
         * Returns the name of the suite.
         */
        public function getName(): string {}

        /**
         * Returns the test groups of the suite.
         */
        public function getGroups(): array {}

        public function getGroupDetails(): array {}

        /**
         * Set tests groups of the test case.
         */
        public function setGroupDetails(array $groups): \void {}

        /**
         * Runs the tests and collects their result in a TestResult.
         *
         * @throws \PHPUnit\Framework\CodeCoverageException
         * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
         * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Warning
         */
        public function run(?\PHPUnit\Framework\TestResult $result = null): \PHPUnit\Framework\TestResult {}

        public function setRunTestInSeparateProcess(bool $runTestInSeparateProcess): \void {}

        public function setName(string $name): \void {}

        /**
         * Returns the tests as an enumeration.
         *
         * @return Test[]
         */
        public function tests(): array {}

        /**
         * Set tests of the test suite.
         *
         * @param Test[] $tests
         */
        public function setTests(array $tests): \void {}

        /**
         * Mark the test suite as skipped.
         *
         * @param string $message
         *
         * @throws SkippedTestSuiteError
         *
         * @psalm-return never-return
         */
        public function markTestSuiteSkipped($message = ''): \void {}

        /**
         * @param bool $beStrictAboutChangesToGlobalState
         */
        public function setBeStrictAboutChangesToGlobalState($beStrictAboutChangesToGlobalState): \void {}

        /**
         * @param bool $backupGlobals
         */
        public function setBackupGlobals($backupGlobals): \void {}

        /**
         * @param bool $backupStaticAttributes
         */
        public function setBackupStaticAttributes($backupStaticAttributes): \void {}

        /**
         * Returns an iterator for this test suite.
         */
        public function getIterator(): \Iterator {}

        public function injectFilter(\PHPUnit\Runner\Filter\Factory $filter): \void {}

        /**
         * @psalm-return array<int,string>
         */
        public function warnings(): array {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function provides(): array {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function requires(): array {}

        public function sortId(): string {}

        /**
         * Creates a default TestResult object.
         */
        protected function createResult(): \PHPUnit\Framework\TestResult {}

        /**
         * @throws Exception
         */
        protected function addTestMethod(\ReflectionClass $class, \ReflectionMethod $method): \void {}

        private function clearCaches(): \void {}

        private function containsOnlyVirtualGroups(array $groups): bool {}

    }
}

namespace PHPUnit\Framework
{
    use assert;
    use count;
    use RecursiveIterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestSuiteIterator
    {
        /**
         * @var int
         */
        private $position = 0;

        /**
         * @var Test[]
         */
        private $tests;

        public function __construct(\PHPUnit\Framework\TestSuite $testSuite) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\Framework\Test {}

        public function next(): \void {}

        /**
         * @throws NoChildTestSuiteException
         */
        public function getChildren(): self {}

        public function hasChildren(): bool {}

    }
}

namespace PHPUnit\Framework
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class WarningTestCase extends \PHPUnit\Framework\TestCase
    {
        /**
         * @var bool
         */
        protected $backupGlobals = false;

        /**
         * @var bool
         */
        protected $backupStaticAttributes = false;

        /**
         * @var bool
         */
        protected $runTestInSeparateProcess = false;

        /**
         * @var bool
         */
        protected $useErrorHandler = false;

        /**
         * @var string
         */
        private $message;

        /**
         * @param string $message
         */
        public function __construct($message = '') {}

        public function getMessage(): string {}

        /**
         * Returns a string representation of the test case.
         */
        public function toString(): string {}

        /**
         * @throws Exception
         *
         * @psalm-return never-return
         */
        protected function runTest(): \void {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use PHPUnit\Framework\MockObject\Builder\InvocationMocker as InvocationMockerBuilder;
    use PHPUnit\Framework\MockObject\Rule\InvocationOrder;

    /**
     * @internal This trait is not covered by the backward compatibility promise for PHPUnit
     */
    trait Api
    {
        /**
         * @var ConfigurableMethod[]
         */
        private static $__phpunit_configurableMethods;

        /**
         * @var object
         */
        private $__phpunit_originalObject;

        /**
         * @var bool
         */
        private $__phpunit_returnValueGeneration = true;

        /**
         * @var InvocationHandler
         */
        private $__phpunit_invocationMocker;

        /** @noinspection MagicMethodsValidityInspection */
        public static function __phpunit_initConfigurableMethods(\PHPUnit\Framework\MockObject\ConfigurableMethod ...$configurableMethods): \void {}

        /** @noinspection MagicMethodsValidityInspection */
        public function __phpunit_setOriginalObject($originalObject): \void {}

        /** @noinspection MagicMethodsValidityInspection */
        public function __phpunit_setReturnValueGeneration(bool $returnValueGeneration): \void {}

        /** @noinspection MagicMethodsValidityInspection */
        public function __phpunit_getInvocationHandler(): \PHPUnit\Framework\MockObject\InvocationHandler {}

        /** @noinspection MagicMethodsValidityInspection */
        public function __phpunit_hasMatchers(): bool {}

        /** @noinspection MagicMethodsValidityInspection */
        public function __phpunit_verify(bool $unsetInvocationMocker = true): \void {}

        public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $matcher): \PHPUnit\Framework\MockObject\Builder\InvocationMocker {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use call_user_func_array;
    use func_get_args;
    use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;

    /**
     * @internal This trait is not covered by the backward compatibility promise for PHPUnit
     */
    trait Method
    {
        public function method() {}

    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This trait is not covered by the backward compatibility promise for PHPUnit
     */
    trait MockedCloneMethod
    {
        public function __clone() {}

    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This trait is not covered by the backward compatibility promise for PHPUnit
     */
    trait UnmockedCloneMethod
    {
        public function __clone() {}

    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class BadMethodCallException extends \BadMethodCallException
    {
    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConfigurableMethodsAlreadyInitializedException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
    {
    }
}

namespace PHPUnit\Framework\MockObject
{
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Exception
    {
    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IncompatibleReturnValueException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
    {
    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace PHPUnit\Framework\MockObject
{
    use SebastianBergmann\Type\Type;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConfigurableMethod
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var Type
         */
        private $returnType;

        public function __construct(string $name, \SebastianBergmann\Type\Type $returnType) {}

        public function getName(): string {}

        public function mayReturn($value): bool {}

        public function getReturnTypeDeclaration(): string {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use DIRECTORY_SEPARATOR;
    use PHP_EOL;
    use PHP_MAJOR_VERSION;
    use PREG_OFFSET_CAPTURE;
    use WSDL_CACHE_NONE;
    use array_diff_assoc;
    use array_merge;
    use array_pop;
    use array_unique;
    use class_exists;
    use count;
    use explode;
    use extension_loaded;
    use implode;
    use in_array;
    use interface_exists;
    use is_array;
    use is_object;
    use md5;
    use mt_rand;
    use preg_match;
    use preg_match_all;
    use range;
    use serialize;
    use sort;
    use sprintf;
    use str_replace;
    use strlen;
    use strpos;
    use strtolower;
    use substr;
    use trait_exists;
    use Doctrine\Instantiator\Exception\ExceptionInterface as InstantiatorException;
    use Doctrine\Instantiator\Instantiator;
    use Exception;
    use Iterator;
    use IteratorAggregate;
    use PHPUnit\Framework\InvalidArgumentException;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionMethod;
    use SebastianBergmann\Template\Template;
    use SoapClient;
    use SoapFault;
    use Throwable;
    use Traversable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Generator
    {
        /**
         * @var array
         */
        const EXCLUDED_METHOD_NAMES = [/** value is missing */];

        /**
         * @var array
         */
        private static $cache = [/** value is missing */];

        /**
         * @var Template[]
         */
        private static $templates = [/** value is missing */];

        /**
         * Returns a mock object for the specified class.
         *
         * @param null|array $methods
         *
         * @throws RuntimeException
         */
        public function getMock(string $type, $methods = [/** value is missing */], array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true, bool $cloneArguments = true, bool $callOriginalMethods = false, ?object $proxyTarget = null, bool $allowMockingUnknownTypes = true, bool $returnValueGeneration = true): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a mock object for the specified abstract class with all abstract
         * methods of the class mocked.
         *
         * Concrete methods to mock can be specified with the $mockedMethods parameter.
         *
         * @psalm-template RealInstanceType of object
         * @psalm-param class-string<RealInstanceType> $originalClassName
         * @psalm-return MockObject&RealInstanceType
         *
         * @throws RuntimeException
         */
        public function getMockForAbstractClass(string $originalClassName, array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true, ?array $mockedMethods = null, bool $cloneArguments = true): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns a mock object for the specified trait with all abstract methods
         * of the trait mocked. Concrete methods to mock can be specified with the
         * `$mockedMethods` parameter.
         *
         * @psalm-param trait-string $traitName
         *
         * @throws RuntimeException
         */
        public function getMockForTrait(string $traitName, array $arguments = [/** value is missing */], string $mockClassName = '', bool $callOriginalConstructor = true, bool $callOriginalClone = true, bool $callAutoload = true, ?array $mockedMethods = null, bool $cloneArguments = true): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Returns an object for the specified trait.
         *
         * @psalm-param trait-string $traitName
         *
         * @throws RuntimeException
         */
        public function getObjectForTrait(string $traitName, string $traitClassName = '', bool $callAutoload = true, bool $callOriginalConstructor = false, array $arguments = [/** value is missing */]): object {}

        public function generate(string $type, ?array $methods = null, string $mockClassName = '', bool $callOriginalClone = true, bool $callAutoload = true, bool $cloneArguments = true, bool $callOriginalMethods = false): \PHPUnit\Framework\MockObject\MockClass {}

        /**
         * @throws RuntimeException
         */
        public function generateClassFromWsdl(string $wsdlFile, string $className, array $methods = [/** value is missing */], array $options = [/** value is missing */]): string {}

        /**
         * @throws RuntimeException
         *
         * @return string[]
         */
        public function getClassMethods(string $className): array {}

        /**
         * @throws RuntimeException
         *
         * @return MockMethod[]
         */
        public function mockClassMethods(string $className, bool $callOriginalMethods, bool $cloneArguments): array {}

        /**
         * @throws RuntimeException
         *
         * @return MockMethod[]
         */
        public function mockInterfaceMethods(string $interfaceName, bool $cloneArguments): array {}

        /**
         * @psalm-param class-string $interfaceName
         *
         * @return ReflectionMethod[]
         */
        private function userDefinedInterfaceMethods(string $interfaceName): array {}

        private function getObject(\PHPUnit\Framework\MockObject\MockType $mockClass, $type = '', bool $callOriginalConstructor = false, bool $callAutoload = false, array $arguments = [/** value is missing */], bool $callOriginalMethods = false, ?object $proxyTarget = null, bool $returnValueGeneration = true) {}

        /**
         * @throws RuntimeException
         */
        private function generateMock(string $type, ?array $explicitMethods, string $mockClassName, bool $callOriginalClone, bool $callAutoload, bool $cloneArguments, bool $callOriginalMethods): \PHPUnit\Framework\MockObject\MockClass {}

        private function generateClassName(string $type, string $className, string $prefix): array {}

        private function generateMockClassDeclaration(array $mockClassName, bool $isInterface, array $additionalInterfaces = [/** value is missing */]): string {}

        private function canMockMethod(\ReflectionMethod $method): bool {}

        private function isMethodNameExcluded(string $name): bool {}

        private function getTemplate(string $template): \SebastianBergmann\Template\Template {}

        /**
         * @see https://github.com/sebastianbergmann/phpunit/issues/4139#issuecomment-605409765
         */
        private function isConstructor(\ReflectionMethod $method): bool {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use array_map;
    use explode;
    use get_class;
    use implode;
    use is_object;
    use sprintf;
    use strpos;
    use strtolower;
    use substr;
    use Doctrine\Instantiator\Instantiator;
    use PHPUnit\Framework\SelfDescribing;
    use PHPUnit\Util\Type;
    use SebastianBergmann\Exporter\Exporter;
    use stdClass;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Invocation implements \PHPUnit\Framework\SelfDescribing
    {
        /**
         * @var string
         */
        private $className;

        /**
         * @var string
         */
        private $methodName;

        /**
         * @var array
         */
        private $parameters;

        /**
         * @var string
         */
        private $returnType;

        /**
         * @var bool
         */
        private $isReturnTypeNullable = false;

        /**
         * @var bool
         */
        private $proxiedCall;

        /**
         * @var object
         */
        private $object;

        public function __construct(string $className, string $methodName, array $parameters, string $returnType, object $object, bool $cloneObjects = false, bool $proxiedCall = false) {}

        public function getClassName(): string {}

        public function getMethodName(): string {}

        public function getParameters(): array {}

        /**
         * @throws RuntimeException
         *
         * @return mixed Mocked return value
         */
        public function generateReturnValue() {}

        public function toString(): string {}

        public function getObject(): object {}

        private function cloneObject(object $original): object {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use sprintf;
    use strtolower;
    use Exception;
    use PHPUnit\Framework\MockObject\Builder\InvocationMocker;
    use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvocationHandler
    {
        /**
         * @var Matcher[]
         */
        private $matchers = [/** value is missing */];

        /**
         * @var Matcher[]
         */
        private $matcherMap = [/** value is missing */];

        /**
         * @var ConfigurableMethod[]
         */
        private $configurableMethods;

        /**
         * @var bool
         */
        private $returnValueGeneration;

        /**
         * @var Throwable
         */
        private $deferredError;

        public function __construct(array $configurableMethods, bool $returnValueGeneration) {}

        public function hasMatchers(): bool {}

        /**
         * Looks up the match builder with identification $id and returns it.
         *
         * @param string $id The identification of the match builder
         */
        public function lookupMatcher(string $id): ?\PHPUnit\Framework\MockObject\Matcher {}

        /**
         * Registers a matcher with the identification $id. The matcher can later be
         * looked up using lookupMatcher() to figure out if it has been invoked.
         *
         * @param string  $id      The identification of the matcher
         * @param Matcher $matcher The builder which is being registered
         *
         * @throws RuntimeException
         */
        public function registerMatcher(string $id, \PHPUnit\Framework\MockObject\Matcher $matcher): \void {}

        public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $rule): \PHPUnit\Framework\MockObject\Builder\InvocationMocker {}

        /**
         * @throws RuntimeException
         * @throws Exception
         */
        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        /**
         * @throws Throwable
         */
        public function verify(): \void {}

        private function addMatcher(\PHPUnit\Framework\MockObject\Matcher $matcher): \void {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use assert;
    use implode;
    use sprintf;
    use Exception;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;
    use PHPUnit\Framework\MockObject\Rule\AnyParameters;
    use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
    use PHPUnit\Framework\MockObject\Rule\InvokedCount;
    use PHPUnit\Framework\MockObject\Rule\MethodName;
    use PHPUnit\Framework\MockObject\Rule\ParametersRule;
    use PHPUnit\Framework\MockObject\Stub\Stub;
    use PHPUnit\Framework\TestFailure;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Matcher
    {
        /**
         * @var InvocationOrder
         */
        private $invocationRule;

        /**
         * @var mixed
         */
        private $afterMatchBuilderId;

        /**
         * @var bool
         */
        private $afterMatchBuilderIsInvoked = false;

        /**
         * @var MethodName
         */
        private $methodNameRule;

        /**
         * @var ParametersRule
         */
        private $parametersRule;

        /**
         * @var Stub
         */
        private $stub;

        public function __construct(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $rule) {}

        public function hasMatchers(): bool {}

        public function hasMethodNameRule(): bool {}

        public function getMethodNameRule(): \PHPUnit\Framework\MockObject\Rule\MethodName {}

        public function setMethodNameRule(\PHPUnit\Framework\MockObject\Rule\MethodName $rule): \void {}

        public function hasParametersRule(): bool {}

        public function setParametersRule(\PHPUnit\Framework\MockObject\Rule\ParametersRule $rule): \void {}

        public function setStub(\PHPUnit\Framework\MockObject\Stub\Stub $stub): \void {}

        public function setAfterMatchBuilderId(string $id): \void {}

        /**
         * @throws Exception
         * @throws RuntimeException
         * @throws ExpectationFailedException
         */
        public function invoked(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        /**
         * @throws RuntimeException
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        /**
         * @throws RuntimeException
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function verify(): \void {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use is_string;
    use sprintf;
    use strtolower;
    use PHPUnit\Framework\Constraint\Constraint;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MethodNameConstraint extends \PHPUnit\Framework\Constraint\Constraint
    {
        /**
         * @var string
         */
        private $methodName;

        public function __construct(string $methodName) {}

        public function toString(): string {}

        protected function matches($other): bool {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use array_diff;
    use array_merge;
    use sprintf;
    use PHPUnit\Framework\TestCase;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @psalm-template MockedType
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class MockBuilder
    {
        /**
         * @var TestCase
         */
        private $testCase;

        /**
         * @var string
         */
        private $type;

        /**
         * @var null|string[]
         */
        private $methods = [/** value is missing */];

        /**
         * @var bool
         */
        private $emptyMethodsArray = false;

        /**
         * @var string
         */
        private $mockClassName = '';

        /**
         * @var array
         */
        private $constructorArgs = [/** value is missing */];

        /**
         * @var bool
         */
        private $originalConstructor = true;

        /**
         * @var bool
         */
        private $originalClone = true;

        /**
         * @var bool
         */
        private $autoload = true;

        /**
         * @var bool
         */
        private $cloneArguments = false;

        /**
         * @var bool
         */
        private $callOriginalMethods = false;

        /**
         * @var ?object
         */
        private $proxyTarget;

        /**
         * @var bool
         */
        private $allowMockingUnknownTypes = true;

        /**
         * @var bool
         */
        private $returnValueGeneration = true;

        /**
         * @var Generator
         */
        private $generator;

        /**
         * @param string|string[] $type
         *
         * @psalm-param class-string<MockedType>|string|string[] $type
         */
        public function __construct(\PHPUnit\Framework\TestCase $testCase, $type) {}

        /**
         * Creates a mock object using a fluent interface.
         *
         * @throws RuntimeException
         *
         * @psalm-return MockObject&MockedType
         */
        public function getMock(): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Creates a mock object for an abstract class using a fluent interface.
         *
         * @throws \PHPUnit\Framework\Exception
         * @throws RuntimeException
         *
         * @psalm-return MockObject&MockedType
         */
        public function getMockForAbstractClass(): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Creates a mock object for a trait using a fluent interface.
         *
         * @throws \PHPUnit\Framework\Exception
         * @throws RuntimeException
         *
         * @psalm-return MockObject&MockedType
         */
        public function getMockForTrait(): \PHPUnit\Framework\MockObject\MockObject {}

        /**
         * Specifies the subset of methods to mock. Default is to mock none of them.
         *
         * @deprecated https://github.com/sebastianbergmann/phpunit/pull/3687
         *
         * @return $this
         */
        public function setMethods(?array $methods = null): self {}

        /**
         * Specifies the subset of methods to mock, requiring each to exist in the class.
         *
         * @param string[] $methods
         *
         * @throws RuntimeException
         *
         * @return $this
         */
        public function onlyMethods(array $methods): self {}

        /**
         * Specifies methods that don't exist in the class which you want to mock.
         *
         * @param string[] $methods
         *
         * @throws RuntimeException
         *
         * @return $this
         */
        public function addMethods(array $methods): self {}

        /**
         * Specifies the subset of methods to not mock. Default is to mock all of them.
         */
        public function setMethodsExcept(array $methods = [/** value is missing */]): self {}

        /**
         * Specifies the arguments for the constructor.
         *
         * @return $this
         */
        public function setConstructorArgs(array $args): self {}

        /**
         * Specifies the name for the mock class.
         *
         * @return $this
         */
        public function setMockClassName(string $name): self {}

        /**
         * Disables the invocation of the original constructor.
         *
         * @return $this
         */
        public function disableOriginalConstructor(): self {}

        /**
         * Enables the invocation of the original constructor.
         *
         * @return $this
         */
        public function enableOriginalConstructor(): self {}

        /**
         * Disables the invocation of the original clone constructor.
         *
         * @return $this
         */
        public function disableOriginalClone(): self {}

        /**
         * Enables the invocation of the original clone constructor.
         *
         * @return $this
         */
        public function enableOriginalClone(): self {}

        /**
         * Disables the use of class autoloading while creating the mock object.
         *
         * @return $this
         */
        public function disableAutoload(): self {}

        /**
         * Enables the use of class autoloading while creating the mock object.
         *
         * @return $this
         */
        public function enableAutoload(): self {}

        /**
         * Disables the cloning of arguments passed to mocked methods.
         *
         * @return $this
         */
        public function disableArgumentCloning(): self {}

        /**
         * Enables the cloning of arguments passed to mocked methods.
         *
         * @return $this
         */
        public function enableArgumentCloning(): self {}

        /**
         * Enables the invocation of the original methods.
         *
         * @return $this
         */
        public function enableProxyingToOriginalMethods(): self {}

        /**
         * Disables the invocation of the original methods.
         *
         * @return $this
         */
        public function disableProxyingToOriginalMethods(): self {}

        /**
         * Sets the proxy target.
         *
         * @return $this
         */
        public function setProxyTarget(object $object): self {}

        /**
         * @return $this
         */
        public function allowMockingUnknownTypes(): self {}

        /**
         * @return $this
         */
        public function disallowMockingUnknownTypes(): self {}

        /**
         * @return $this
         */
        public function enableAutoReturnValueGeneration(): self {}

        /**
         * @return $this
         */
        public function disableAutoReturnValueGeneration(): self {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use call_user_func;
    use class_exists;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MockClass implements \PHPUnit\Framework\MockObject\MockType
    {
        /**
         * @var string
         */
        private $classCode;

        /**
         * @var string
         */
        private $mockName;

        /**
         * @var ConfigurableMethod[]
         */
        private $configurableMethods;

        public function __construct(string $classCode, string $mockName, array $configurableMethods) {}

        public function generate(): string {}

        public function getClassCode(): string {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use DIRECTORY_SEPARATOR;
    use implode;
    use is_string;
    use preg_match;
    use preg_replace;
    use sprintf;
    use substr_count;
    use trim;
    use var_export;
    use ReflectionException;
    use ReflectionMethod;
    use ReflectionNamedType;
    use ReflectionParameter;
    use ReflectionUnionType;
    use SebastianBergmann\Template\Template;
    use SebastianBergmann\Type\ReflectionMapper;
    use SebastianBergmann\Type\Type;
    use SebastianBergmann\Type\UnknownType;
    use SebastianBergmann\Type\VoidType;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MockMethod
    {
        /**
         * @var Template[]
         */
        private static $templates = [/** value is missing */];

        /**
         * @var string
         */
        private $className;

        /**
         * @var string
         */
        private $methodName;

        /**
         * @var bool
         */
        private $cloneArguments;

        /**
         * @var string string
         */
        private $modifier;

        /**
         * @var string
         */
        private $argumentsForDeclaration;

        /**
         * @var string
         */
        private $argumentsForCall;

        /**
         * @var Type
         */
        private $returnType;

        /**
         * @var string
         */
        private $reference;

        /**
         * @var bool
         */
        private $callOriginalMethod;

        /**
         * @var bool
         */
        private $static;

        /**
         * @var ?string
         */
        private $deprecation;

        /**
         * @throws RuntimeException
         */
        public static function fromReflection(\ReflectionMethod $method, bool $callOriginalMethod, bool $cloneArguments): self {}

        public static function fromName(string $fullClassName, string $methodName, bool $cloneArguments): self {}

        public function __construct(string $className, string $methodName, bool $cloneArguments, string $modifier, string $argumentsForDeclaration, string $argumentsForCall, \SebastianBergmann\Type\Type $returnType, string $reference, bool $callOriginalMethod, bool $static, ?string $deprecation) {}

        public function getName(): string {}

        /**
         * @throws RuntimeException
         */
        public function generateCode(): string {}

        public function getReturnType(): \SebastianBergmann\Type\Type {}

        private function getTemplate(string $template): \SebastianBergmann\Template\Template {}

        /**
         * Returns the parameters of a function or method.
         *
         * @throws RuntimeException
         */
        private static function getMethodParametersForDeclaration(\ReflectionMethod $method): string {}

        /**
         * Returns the parameters of a function or method.
         *
         * @throws RuntimeException
         */
        private static function getMethodParametersForCall(\ReflectionMethod $method): string {}

        /**
         * @throws RuntimeException
         */
        private static function exportDefaultValue(\ReflectionParameter $parameter): string {}

        private static function unionTypeAsString(\ReflectionUnionType $union, string $self): string {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use array_key_exists;
    use array_values;
    use strtolower;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MockMethodSet
    {
        /**
         * @var MockMethod[]
         */
        private $methods = [/** value is missing */];

        public function addMethods(\PHPUnit\Framework\MockObject\MockMethod ...$methods): \void {}

        /**
         * @return MockMethod[]
         */
        public function asArray(): array {}

        public function hasMethod(string $methodName): bool {}

    }
}

namespace PHPUnit\Framework\MockObject
{
    use PHPUnit\Framework\MockObject\Builder\InvocationMocker as BuilderInvocationMocker;
    use PHPUnit\Framework\MockObject\Rule\InvocationOrder;

    /**
     * @method BuilderInvocationMocker method($constraint)
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface MockObject extends \PHPUnit\Framework\MockObject\Stub
    {
        public function __phpunit_setOriginalObject($originalObject): \void;

        public function __phpunit_verify(bool $unsetInvocationMocker = true): \void;

        public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $invocationRule): \PHPUnit\Framework\MockObject\Builder\InvocationMocker;

    }
}

namespace PHPUnit\Framework\MockObject
{
    use class_exists;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MockTrait implements \PHPUnit\Framework\MockObject\MockType
    {
        /**
         * @var string
         */
        private $classCode;

        /**
         * @var string
         */
        private $mockName;

        public function __construct(string $classCode, string $mockName) {}

        public function generate(): string {}

        public function getClassCode(): string {}

    }
}

namespace PHPUnit\Framework\MockObject
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface MockType
    {
        public function generate(): string;

    }
}

namespace PHPUnit\Framework\MockObject
{
    use PHPUnit\Framework\MockObject\Builder\InvocationStubber;

    /**
     * @method InvocationStubber method($constraint)
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface Stub
    {
        public function __phpunit_getInvocationHandler(): \PHPUnit\Framework\MockObject\InvocationHandler;

        public function __phpunit_hasMatchers(): bool;

        public function __phpunit_setReturnValueGeneration(bool $returnValueGeneration): \void;

    }
}

namespace PHPUnit\Framework\MockObject
{
    use PHPUnit\Framework\ExpectationFailedException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Verifiable
    {
        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void;

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Identity
    {
        /**
         * Sets the identification of the expectation to $id.
         *
         * @note The identifier is unique per mock object.
         *
         * @param string $id unique identification of expectation
         */
        public function id($id);

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{
    use array_map;
    use array_merge;
    use count;
    use get_class;
    use gettype;
    use in_array;
    use is_object;
    use is_string;
    use sprintf;
    use strtolower;
    use PHPUnit\Framework\Constraint\Constraint;
    use PHPUnit\Framework\MockObject\ConfigurableMethod;
    use PHPUnit\Framework\MockObject\IncompatibleReturnValueException;
    use PHPUnit\Framework\MockObject\InvocationHandler;
    use PHPUnit\Framework\MockObject\Matcher;
    use PHPUnit\Framework\MockObject\Rule;
    use PHPUnit\Framework\MockObject\RuntimeException;
    use PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls;
    use PHPUnit\Framework\MockObject\Stub\Exception;
    use PHPUnit\Framework\MockObject\Stub\ReturnArgument;
    use PHPUnit\Framework\MockObject\Stub\ReturnCallback;
    use PHPUnit\Framework\MockObject\Stub\ReturnReference;
    use PHPUnit\Framework\MockObject\Stub\ReturnSelf;
    use PHPUnit\Framework\MockObject\Stub\ReturnStub;
    use PHPUnit\Framework\MockObject\Stub\ReturnValueMap;
    use PHPUnit\Framework\MockObject\Stub\Stub;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class InvocationMocker implements \PHPUnit\Framework\MockObject\Builder\InvocationStubber, \PHPUnit\Framework\MockObject\Builder\MethodNameMatch
    {
        /**
         * @var InvocationHandler
         */
        private $invocationHandler;

        /**
         * @var Matcher
         */
        private $matcher;

        /**
         * @var ConfigurableMethod[]
         */
        private $configurableMethods;

        public function __construct(\PHPUnit\Framework\MockObject\InvocationHandler $handler, \PHPUnit\Framework\MockObject\Matcher $matcher, \PHPUnit\Framework\MockObject\ConfigurableMethod ...$configurableMethods) {}

        /**
         * @return $this
         */
        public function id($id): self {}

        /**
         * @return $this
         */
        public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub): \PHPUnit\Framework\MockObject\Builder\Identity {}

        public function willReturn($value, ...$nextValues): self {}

        public function willReturnReference(&$reference): self {}

        public function willReturnMap(array $valueMap): self {}

        public function willReturnArgument($argumentIndex): self {}

        public function willReturnCallback($callback): self {}

        public function willReturnSelf(): self {}

        public function willReturnOnConsecutiveCalls(...$values): self {}

        public function willThrowException(\Throwable $exception): self {}

        /**
         * @return $this
         */
        public function after($id): self {}

        /**
         * @throws RuntimeException
         *
         * @return $this
         */
        public function with(...$arguments): self {}

        /**
         * @param array ...$arguments
         *
         * @throws RuntimeException
         *
         * @return $this
         */
        public function withConsecutive(...$arguments): self {}

        /**
         * @throws RuntimeException
         *
         * @return $this
         */
        public function withAnyParameters(): self {}

        /**
         * @param Constraint|string $constraint
         *
         * @throws RuntimeException
         *
         * @return $this
         */
        public function method($constraint): self {}

        /**
         * Validate that a parameters rule can be defined, throw exceptions otherwise.
         *
         * @throws RuntimeException
         */
        private function canDefineParameters(): \void {}

        private function getConfiguredMethod(): ?\PHPUnit\Framework\MockObject\ConfigurableMethod {}

        private function ensureTypeOfReturnValues(array $values): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{
    use PHPUnit\Framework\MockObject\Stub\Stub;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface InvocationStubber
    {
        public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub): \PHPUnit\Framework\MockObject\Builder\Identity;

        /** @return self */
        public function willReturn($value, ...$nextValues);

        /**
         * @param mixed $reference
         *
         * @return self
         */
        public function willReturnReference(&$reference);

        /**
         * @param array<int, array<int, mixed>> $valueMap
         *
         * @return self
         */
        public function willReturnMap(array $valueMap);

        /**
         * @param int $argumentIndex
         *
         * @return self
         */
        public function willReturnArgument($argumentIndex);

        /**
         * @param callable $callback
         *
         * @return self
         */
        public function willReturnCallback($callback);

        /** @return self */
        public function willReturnSelf();

        /**
         * @param mixed $values
         *
         * @return self
         */
        public function willReturnOnConsecutiveCalls(...$values);

        /** @return self */
        public function willThrowException(\Throwable $exception);

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface MethodNameMatch extends \PHPUnit\Framework\MockObject\Builder\ParametersMatch
    {
        /**
         * Adds a new method name match and returns the parameter match object for
         * further matching possibilities.
         *
         * @param \PHPUnit\Framework\Constraint\Constraint $name Constraint for matching method, if a string is passed it will use the PHPUnit_Framework_Constraint_IsEqual
         *
         * @return ParametersMatch
         */
        public function method($name);

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface ParametersMatch extends \PHPUnit\Framework\MockObject\Builder\Stub
    {
        /**
         * Defines the expectation which must occur before the current is valid.
         *
         * @param string $id the identification of the expectation that should
         *                   occur before this one
         *
         * @return Stub
         */
        public function after($id);

        /**
         * Sets the parameters to match for, each parameter to this function will
         * be part of match. To perform specific matches or constraints create a
         * new PHPUnit\Framework\Constraint\Constraint and use it for the parameter.
         * If the parameter value is not a constraint it will use the
         * PHPUnit\Framework\Constraint\IsEqual for the value.
         *
         * Some examples:
         * <code>
         * // match first parameter with value 2
         * $b->with(2);
         * // match first parameter with value 'smock' and second identical to 42
         * $b->with('smock', new PHPUnit\Framework\Constraint\IsEqual(42));
         * </code>
         *
         * @return ParametersMatch
         */
        public function with(...$arguments);

        /**
         * Sets a rule which allows any kind of parameters.
         *
         * Some examples:
         * <code>
         * // match any number of parameters
         * $b->withAnyParameters();
         * </code>
         *
         * @return ParametersMatch
         */
        public function withAnyParameters();

    }
}

namespace PHPUnit\Framework\MockObject\Builder
{
    use PHPUnit\Framework\MockObject\Stub\Stub as BaseStub;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Stub extends \PHPUnit\Framework\MockObject\Builder\Identity
    {
        /**
         * Stubs the matching method with the stub object $stub. Any invocations of
         * the matched method will now be handled by the stub instead.
         */
        public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub): \PHPUnit\Framework\MockObject\Builder\Identity;

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class AnyInvokedCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        public function toString(): string {}

        public function verify(): \void {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class AnyParameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
    {
        public function toString(): string {}

        public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

        public function verify(): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use count;
    use gettype;
    use is_iterable;
    use sprintf;
    use PHPUnit\Framework\Constraint\Constraint;
    use PHPUnit\Framework\Constraint\IsEqual;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\InvalidParameterGroupException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConsecutiveParameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
    {
        /**
         * @var array
         */
        private $parameterGroups = [/** value is missing */];

        /**
         * @var array
         */
        private $invocations = [/** value is missing */];

        /**
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct(array $parameterGroups) {}

        public function toString(): string {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

        /**
         * @throws \PHPUnit\Framework\ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function verify(): \void {}

        /**
         * Verify a single invocation.
         *
         * @param int $callIndex
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function verifyInvocation(\PHPUnit\Framework\MockObject\Invocation $invocation, $callIndex): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use count;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
    use PHPUnit\Framework\MockObject\Verifiable;
    use PHPUnit\Framework\SelfDescribing;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class InvocationOrder implements \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\MockObject\Verifiable
    {
        /**
         * @var BaseInvocation[]
         */
        private $invocations = [/** value is missing */];

        public function getInvocationCount(): int {}

        public function hasBeenInvoked(): bool {}

        final public function invoked(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        abstract public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool;

        abstract protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation);

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use sprintf;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4297
     * @codeCoverageIgnore
     */
    final class InvokedAtIndex extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        /**
         * @var int
         */
        private $sequenceIndex;

        /**
         * @var int
         */
        private $currentIndex;

        /**
         * @param int $sequenceIndex
         */
        public function __construct($sequenceIndex) {}

        public function toString(): string {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void {}

        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvokedAtLeastCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        /**
         * @var int
         */
        private $requiredInvocations;

        /**
         * @param int $requiredInvocations
         */
        public function __construct($requiredInvocations) {}

        public function toString(): string {}

        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvokedAtLeastOnce extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        public function toString(): string {}

        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvokedAtMostCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        /**
         * @var int
         */
        private $allowedInvocations;

        /**
         * @param int $allowedInvocations
         */
        public function __construct($allowedInvocations) {}

        public function toString(): string {}

        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use sprintf;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvokedCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
    {
        /**
         * @var int
         */
        private $expectedCount;

        /**
         * @param int $expectedCount
         */
        public function __construct($expectedCount) {}

        public function isNever(): bool {}

        public function toString(): string {}

        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        /**
         * Verifies that the current expectation is valid. If everything is OK the
         * code should just return, if not it must throw an exception.
         *
         * @throws ExpectationFailedException
         */
        public function verify(): \void {}

        /**
         * @throws ExpectationFailedException
         */
        protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use is_string;
    use PHPUnit\Framework\Constraint\Constraint;
    use PHPUnit\Framework\InvalidArgumentException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
    use PHPUnit\Framework\MockObject\MethodNameConstraint;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MethodName
    {
        /**
         * @var Constraint
         */
        private $constraint;

        /**
         * @param Constraint|string $constraint
         *
         * @throws InvalidArgumentException
         */
        public function __construct($constraint) {}

        public function toString(): string {}

        /**
         * @throws \PHPUnit\Framework\ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation): bool {}

        public function matchesName(string $methodName): bool {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use count;
    use get_class;
    use sprintf;
    use Exception;
    use PHPUnit\Framework\Constraint\Constraint;
    use PHPUnit\Framework\Constraint\IsAnything;
    use PHPUnit\Framework\Constraint\IsEqual;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Parameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
    {
        /**
         * @var Constraint[]
         */
        private $parameters = [/** value is missing */];

        /**
         * @var BaseInvocation
         */
        private $invocation;

        /**
         * @var bool|ExpectationFailedException
         */
        private $parameterVerificationResult;

        /**
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct(array $parameters) {}

        public function toString(): string {}

        /**
         * @throws Exception
         */
        public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

        /**
         * Checks if the invocation $invocation matches the current rules. If it
         * does the rule will get the invoked() method called which should check
         * if an expectation is met.
         *
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function verify(): \void {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function doVerify(): bool {}

        /**
         * @throws ExpectationFailedException
         */
        private function guardAgainstDuplicateEvaluationOfParameterConstraints(): bool {}

    }
}

namespace PHPUnit\Framework\MockObject\Rule
{
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
    use PHPUnit\Framework\MockObject\Verifiable;
    use PHPUnit\Framework\SelfDescribing;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface ParametersRule extends \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\MockObject\Verifiable
    {
        /**
         * @throws ExpectationFailedException if the invocation violates the rule
         */
        public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation): \void;

        public function verify(): \void;

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use array_shift;
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;
    use SebastianBergmann\Exporter\Exporter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConsecutiveCalls implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @var array
         */
        private $stack;

        /**
         * @var mixed
         */
        private $value;

        public function __construct(array $stack) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;
    use SebastianBergmann\Exporter\Exporter;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        private $exception;

        public function __construct(\Throwable $exception) {}

        /**
         * @throws Throwable
         */
        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation): \void {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnArgument implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @var int
         */
        private $argumentIndex;

        public function __construct($argumentIndex) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use call_user_func_array;
    use get_class;
    use is_array;
    use is_object;
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnCallback implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        private $callback;

        public function __construct($callback) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;
    use SebastianBergmann\Exporter\Exporter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnReference implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @var mixed
         */
        private $reference;

        public function __construct(&$reference) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use PHPUnit\Framework\MockObject\Invocation;
    use PHPUnit\Framework\MockObject\RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnSelf implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @throws RuntimeException
         */
        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use sprintf;
    use PHPUnit\Framework\MockObject\Invocation;
    use SebastianBergmann\Exporter\Exporter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnStub implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @var mixed
         */
        private $value;

        public function __construct($value) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use array_pop;
    use count;
    use is_array;
    use PHPUnit\Framework\MockObject\Invocation;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ReturnValueMap implements \PHPUnit\Framework\MockObject\Stub\Stub
    {
        /**
         * @var array
         */
        private $valueMap;

        public function __construct(array $valueMap) {}

        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) {}

        public function toString(): string {}

    }
}

namespace PHPUnit\Framework\MockObject\Stub
{
    use PHPUnit\Framework\MockObject\Invocation;
    use PHPUnit\Framework\SelfDescribing;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Stub extends \PHPUnit\Framework\SelfDescribing
    {
        /**
         * Fakes the processing of the invocation $invocation by returning a
         * specific value.
         *
         * @param Invocation $invocation The invocation which was mocked and matched by the current method and argument matchers
         */
        public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation);

    }
}

namespace PHPUnit\Runner\Filter
{
    use in_array;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExcludeGroupFilterIterator extends \PHPUnit\Runner\Filter\GroupFilterIterator
    {
        protected function doAccept(string $hash): bool {}

    }
}

namespace PHPUnit\Runner\Filter
{
    use assert;
    use sprintf;
    use FilterIterator;
    use Iterator;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Runner\Exception;
    use RecursiveFilterIterator;
    use ReflectionClass;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Factory
    {
        /**
         * @psalm-var array<int,array{0: \ReflectionClass, 1: array|string}>
         */
        private $filters = [/** value is missing */];

        /**
         * @param array|string $args
         *
         * @throws Exception
         */
        public function addFilter(\ReflectionClass $filter, $args): \void {}

        public function factory(\Iterator $iterator, \PHPUnit\Framework\TestSuite $suite): \FilterIterator {}

    }
}

namespace PHPUnit\Runner\Filter
{
    use array_map;
    use array_merge;
    use in_array;
    use spl_object_hash;
    use PHPUnit\Framework\TestSuite;
    use RecursiveFilterIterator;
    use RecursiveIterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class GroupFilterIterator extends \RecursiveFilterIterator
    {
        /**
         * @var string[]
         */
        protected $groupTests = [/** value is missing */];

        public function __construct(\RecursiveIterator $iterator, array $groups, \PHPUnit\Framework\TestSuite $suite) {}

        public function accept(): bool {}

        abstract protected function doAccept(string $hash);

    }
}

namespace PHPUnit\Runner\Filter
{
    use in_array;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IncludeGroupFilterIterator extends \PHPUnit\Runner\Filter\GroupFilterIterator
    {
        protected function doAccept(string $hash): bool {}

    }
}

namespace PHPUnit\Runner\Filter
{
    use end;
    use implode;
    use preg_match;
    use sprintf;
    use str_replace;
    use Exception;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\WarningTestCase;
    use PHPUnit\Util\RegularExpression;
    use RecursiveFilterIterator;
    use RecursiveIterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class NameFilterIterator extends \RecursiveFilterIterator
    {
        /**
         * @var string
         */
        private $filter;

        /**
         * @var int
         */
        private $filterMin;

        /**
         * @var int
         */
        private $filterMax;

        /**
         * @throws Exception
         */
        public function __construct(\RecursiveIterator $iterator, string $filter) {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function accept(): bool {}

        /**
         * @throws Exception
         */
        private function setFilter(string $filter): \void {}

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterIncompleteTestHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterIncompleteTest(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterLastTestHook extends \PHPUnit\Runner\Hook
    {
        public function executeAfterLastTest(): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterRiskyTestHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterRiskyTest(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterSkippedTestHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterSkippedTest(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterSuccessfulTestHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterSuccessfulTest(string $test, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterTestErrorHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterTestError(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterTestFailureHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterTestFailure(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterTestHook extends \PHPUnit\Runner\TestHook
    {
        /**
         * This hook will fire after any test, regardless of the result.
         *
         * For more fine grained control, have a look at the other hooks
         * that extend PHPUnit\Runner\Hook.
         */
        public function executeAfterTest(string $test, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface AfterTestWarningHook extends \PHPUnit\Runner\TestHook
    {
        public function executeAfterTestWarning(string $test, string $message, float $time): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface BeforeFirstTestHook extends \PHPUnit\Runner\Hook
    {
        public function executeBeforeFirstTest(): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface BeforeTestHook extends \PHPUnit\Runner\TestHook
    {
        public function executeBeforeTest(string $test): \void;

    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface Hook
    {
    }
}

namespace PHPUnit\Runner
{

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface TestHook extends \PHPUnit\Runner\Hook
    {
    }
}

namespace PHPUnit\Runner
{
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestListener;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Util\Test as TestUtil;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestListenerAdapter implements \PHPUnit\Framework\TestListener
    {
        /**
         * @var TestHook[]
         */
        private $hooks = [/** value is missing */];

        /**
         * @var bool
         */
        private $lastTestWasNotSuccessful;

        public function add(\PHPUnit\Runner\TestHook $hook): \void {}

        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

    }
}

namespace PHPUnit\Runner
{
    use is_dir;
    use is_file;
    use substr;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\TestSuite;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\FileIterator\Facade as FileIteratorFacade;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class BaseTestRunner
    {
        /**
         * @var int
         */
        const STATUS_UNKNOWN = null;

        /**
         * @var int
         */
        const STATUS_PASSED = 0;

        /**
         * @var int
         */
        const STATUS_SKIPPED = 1;

        /**
         * @var int
         */
        const STATUS_INCOMPLETE = 2;

        /**
         * @var int
         */
        const STATUS_FAILURE = 3;

        /**
         * @var int
         */
        const STATUS_ERROR = 4;

        /**
         * @var int
         */
        const STATUS_RISKY = 5;

        /**
         * @var int
         */
        const STATUS_WARNING = 6;

        /**
         * @var string
         */
        const SUITE_METHODNAME = 'suite';

        /**
         * Returns the loader to be used.
         */
        public function getLoader(): \PHPUnit\Runner\TestSuiteLoader {}

        /**
         * Returns the Test corresponding to the given suite.
         * This is a template method, subclasses override
         * the runFailed() and clearStatus() methods.
         *
         * @param string|string[] $suffixes
         *
         * @throws Exception
         */
        public function getTest(string $suiteClassFile, $suffixes = ''): ?\PHPUnit\Framework\TestSuite {}

        /**
         * Returns the loaded ReflectionClass for a suite name.
         */
        protected function loadSuiteClass(string $suiteClassFile): \ReflectionClass {}

        /**
         * Clears the status message.
         */
        protected function clearStatus(): \void {}

        /**
         * Override to define how to handle a failed loading of
         * a test suite.
         */
        abstract protected function runFailed(string $message): \void;

    }
}

namespace PHPUnit\Runner
{
    use DIRECTORY_SEPARATOR;
    use assert;
    use defined;
    use dirname;
    use file_get_contents;
    use file_put_contents;
    use in_array;
    use is_dir;
    use is_file;
    use is_float;
    use is_int;
    use is_string;
    use serialize;
    use sprintf;
    use unserialize;
    use PHPUnit\Util\ErrorHandler;
    use PHPUnit\Util\Filesystem;
    use Serializable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class DefaultTestResultCache
    {
        /**
         * @var string
         */
        const DEFAULT_RESULT_CACHE_FILENAME = '.phpunit.result.cache';

        /**
         * Provide extra protection against incomplete or corrupt caches.
         *
         * @var int[]
         */
        const ALLOWED_CACHE_TEST_STATUSES = [/** value is missing */];

        /**
         * Path and filename for result cache file.
         *
         * @var string
         */
        private $cacheFilename;

        /**
         * The list of defective tests.
         *
         * <code>
         * // Mark a test skipped
         * $this->defects[$testName] = BaseTestRunner::TEST_SKIPPED;
         * </code>
         *
         * @var array<string, int>
         */
        private $defects = [/** value is missing */];

        /**
         * The list of execution duration of suites and tests (in seconds).
         *
         * <code>
         * // Record running time for test
         * $this->times[$testName] = 1.234;
         * </code>
         *
         * @var array<string, float>
         */
        private $times = [/** value is missing */];

        public function __construct(?string $filepath = null) {}

        /**
         * @throws Exception
         */
        public function persist(): \void {}

        /**
         * @throws Exception
         */
        public function saveToFile(): \void {}

        public function setState(string $testName, int $state): \void {}

        public function getState(string $testName): int {}

        public function setTime(string $testName, float $time): \void {}

        public function getTime(string $testName): float {}

        public function load(): \void {}

        public function copyStateToCache(self $targetCache): \void {}

        public function clear(): \void {}

        public function serialize(): string {}

        /**
         * @param string $serialized
         */
        public function unserialize($serialized): \void {}

    }
}

namespace PHPUnit\Runner
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\Runner
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class NullTestResultCache implements \PHPUnit\Runner\TestResultCache
    {
        public function setState(string $testName, int $state): \void {}

        public function getState(string $testName): int {}

        public function setTime(string $testName, float $time): \void {}

        public function getTime(string $testName): float {}

        public function load(): \void {}

        public function persist(): \void {}

    }
}

namespace PHPUnit\Runner
{
    use DEBUG_BACKTRACE_IGNORE_ARGS;
    use DIRECTORY_SEPARATOR;
    use array_merge;
    use basename;
    use debug_backtrace;
    use defined;
    use dirname;
    use explode;
    use extension_loaded;
    use file;
    use file_get_contents;
    use file_put_contents;
    use is_array;
    use is_file;
    use is_readable;
    use is_string;
    use ltrim;
    use phpversion;
    use preg_match;
    use preg_replace;
    use preg_split;
    use realpath;
    use rtrim;
    use sprintf;
    use str_replace;
    use strncasecmp;
    use strpos;
    use substr;
    use trim;
    use unlink;
    use unserialize;
    use var_export;
    use version_compare;
    use PHPUnit\Framework\Assert;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\ExecutionOrderDependency;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\IncompleteTestError;
    use PHPUnit\Framework\PHPTAssertionFailedError;
    use PHPUnit\Framework\Reorderable;
    use PHPUnit\Framework\SelfDescribing;
    use PHPUnit\Framework\SkippedTestError;
    use PHPUnit\Framework\SyntheticSkippedError;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Util\PHP\AbstractPhpProcess;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;
    use SebastianBergmann\Template\Template;
    use SebastianBergmann\Timer\Timer;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class PhptTestCase
    {
        /**
         * @var string
         */
        private $filename;

        /**
         * @var AbstractPhpProcess
         */
        private $phpUtil;

        /**
         * @var string
         */
        private $output = '';

        /**
         * Constructs a test case with the given filename.
         *
         * @throws Exception
         */
        public function __construct(string $filename, ?\PHPUnit\Util\PHP\AbstractPhpProcess $phpUtil = null) {}

        /**
         * Counts the number of test cases executed by run(TestResult result).
         */
        public function count(): int {}

        /**
         * Runs a test and collects its result in a TestResult instance.
         *
         * @throws Exception
         * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
         * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function run(?\PHPUnit\Framework\TestResult $result = null): \PHPUnit\Framework\TestResult {}

        /**
         * Returns the name of the test case.
         */
        public function getName(): string {}

        /**
         * Returns a string representation of the test case.
         */
        public function toString(): string {}

        public function usesDataProvider(): bool {}

        public function getNumAssertions(): int {}

        public function getActualOutput(): string {}

        public function hasOutput(): bool {}

        public function sortId(): string {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function provides(): array {}

        /**
         * @return list<ExecutionOrderDependency>
         */
        public function requires(): array {}

        /**
         * Parse --INI-- section key value pairs and return as array.
         *
         * @param array|string $content
         */
        private function parseIniSection($content, array $ini = [/** value is missing */]): array {}

        private function parseEnvSection(string $content): array {}

        /**
         * @throws ExpectationFailedException
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         * @throws Exception
         */
        private function assertPhptExpectation(array $sections, string $output): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function runSkip(array &$sections, \PHPUnit\Framework\TestResult $result, array $settings): bool {}

        private function runClean(array &$sections, bool $collectCoverage): \void {}

        /**
         * @throws Exception
         */
        private function parse(): array {}

        /**
         * @throws Exception
         */
        private function parseExternal(array &$sections): \void {}

        private function validate(array &$sections): bool {}

        private function render(string $code): string {}

        private function getCoverageFiles(): array {}

        private function renderForCoverage(string &$job, bool $pathCoverage, ?string $codeCoverageCacheDirectory): \void {}

        private function cleanupForCoverage(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        private function stringifyIni(array $ini): array {}

        private function getLocationHintFromDiff(string $message, array $sections): array {}

        private function getCleanDiffLine(string $line): string {}

        private function getLocationHint(string $needle, array $sections, ?string $sectionName = null): array {}

        /**
         * @psalm-return list<string>
         */
        private function settings(bool $collectCoverage): array {}

    }
}

namespace PHPUnit\Runner
{
    use preg_match;
    use round;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ResultCacheExtension implements \PHPUnit\Runner\AfterIncompleteTestHook, \PHPUnit\Runner\AfterLastTestHook, \PHPUnit\Runner\AfterRiskyTestHook, \PHPUnit\Runner\AfterSkippedTestHook, \PHPUnit\Runner\AfterSuccessfulTestHook, \PHPUnit\Runner\AfterTestErrorHook, \PHPUnit\Runner\AfterTestFailureHook, \PHPUnit\Runner\AfterTestWarningHook
    {
        /**
         * @var TestResultCache
         */
        private $cache;

        public function __construct(\PHPUnit\Runner\TestResultCache $cache) {}

        public function flush(): \void {}

        public function executeAfterSuccessfulTest(string $test, float $time): \void {}

        public function executeAfterIncompleteTest(string $test, string $message, float $time): \void {}

        public function executeAfterRiskyTest(string $test, string $message, float $time): \void {}

        public function executeAfterSkippedTest(string $test, string $message, float $time): \void {}

        public function executeAfterTestError(string $test, string $message, float $time): \void {}

        public function executeAfterTestFailure(string $test, string $message, float $time): \void {}

        public function executeAfterTestWarning(string $test, string $message, float $time): \void {}

        public function executeAfterLastTest(): \void {}

        /**
         * @param string $test A long description format of the current test
         *
         * @return string The test name without TestSuiteClassName:: and @dataprovider details
         */
        private function getTestName(string $test): string {}

    }
}

namespace PHPUnit\Runner
{
    use array_diff;
    use array_values;
    use basename;
    use class_exists;
    use get_declared_classes;
    use sprintf;
    use str_replace;
    use strlen;
    use substr;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Util\FileLoader;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
     */
    final class StandardTestSuiteLoader implements \PHPUnit\Runner\TestSuiteLoader
    {
        /**
         * @throws Exception
         */
        public function load(string $suiteClassFile): \ReflectionClass {}

        public function reload(\ReflectionClass $aClass): \ReflectionClass {}

        private function exceptionFor(string $className, string $filename): \PHPUnit\Runner\Exception {}

    }
}

namespace PHPUnit\Runner
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface TestResultCache
    {
        public function setState(string $testName, int $state): \void;

        public function getState(string $testName): int;

        public function setTime(string $testName, float $time): \void;

        public function getTime(string $testName): float;

        public function load(): \void;

        public function persist(): \void;

    }
}

namespace PHPUnit\Runner
{
    use ReflectionClass;

    /**
     * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface TestSuiteLoader
    {
        public function load(string $suiteClassFile): \ReflectionClass;

        public function reload(\ReflectionClass $aClass): \ReflectionClass;

    }
}

namespace PHPUnit\Runner
{
    use array_diff;
    use array_merge;
    use array_reverse;
    use array_splice;
    use count;
    use in_array;
    use max;
    use shuffle;
    use usort;
    use PHPUnit\Framework\DataProviderTestSuite;
    use PHPUnit\Framework\Reorderable;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Util\Test as TestUtil;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestSuiteSorter
    {
        /**
         * @var int
         */
        const ORDER_DEFAULT = 0;

        /**
         * @var int
         */
        const ORDER_RANDOMIZED = 1;

        /**
         * @var int
         */
        const ORDER_REVERSED = 2;

        /**
         * @var int
         */
        const ORDER_DEFECTS_FIRST = 3;

        /**
         * @var int
         */
        const ORDER_DURATION = 4;

        /**
         * Order tests by @size annotation 'small', 'medium', 'large'.
         *
         * @var int
         */
        const ORDER_SIZE = 5;

        /**
         * List of sorting weights for all test result codes. A higher number gives higher priority.
         */
        const DEFECT_SORT_WEIGHT = [/** value is missing */];

        const SIZE_SORT_WEIGHT = [/** value is missing */];

        /**
         * @var array<string, int> Associative array of (string => DEFECT_SORT_WEIGHT) elements
         */
        private $defectSortOrder = [/** value is missing */];

        /**
         * @var TestResultCache
         */
        private $cache;

        /**
         * @var array<string> A list of normalized names of tests before reordering
         */
        private $originalExecutionOrder = [/** value is missing */];

        /**
         * @var array<string> A list of normalized names of tests affected by reordering
         */
        private $executionOrder = [/** value is missing */];

        public function __construct(?\PHPUnit\Runner\TestResultCache $cache = null) {}

        /**
         * @throws Exception
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function reorderTestsInSuite(\PHPUnit\Framework\Test $suite, int $order, bool $resolveDependencies, int $orderDefects, bool $isRootTestSuite = true): \void {}

        public function getOriginalExecutionOrder(): array {}

        public function getExecutionOrder(): array {}

        private function sort(\PHPUnit\Framework\TestSuite $suite, int $order, bool $resolveDependencies, int $orderDefects): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function addSuiteToDefectSortOrder(\PHPUnit\Framework\TestSuite $suite): \void {}

        private function reverse(array $tests): array {}

        private function randomize(array $tests): array {}

        private function sortDefectsFirst(array $tests): array {}

        private function sortByDuration(array $tests): array {}

        private function sortBySize(array $tests): array {}

        /**
         * Comparator callback function to sort tests for "reach failure as fast as possible".
         *
         * 1. sort tests by defect weight defined in self::DEFECT_SORT_WEIGHT
         * 2. when tests are equally defective, sort the fastest to the front
         * 3. do not reorder successful tests
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function cmpDefectPriorityAndTime(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b): int {}

        /**
         * Compares test duration for sorting tests by duration ascending.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function cmpDuration(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b): int {}

        /**
         * Compares test size for sorting tests small->medium->large->unknown.
         */
        private function cmpSize(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b): int {}

        /**
         * Reorder Tests within a TestCase in such a way as to resolve as many dependencies as possible.
         * The algorithm will leave the tests in original running order when it can.
         * For more details see the documentation for test dependencies.
         *
         * Short description of algorithm:
         * 1. Pick the next Test from remaining tests to be checked for dependencies.
         * 2. If the test has no dependencies: mark done, start again from the top
         * 3. If the test has dependencies but none left to do: mark done, start again from the top
         * 4. When we reach the end add any leftover tests to the end. These will be marked 'skipped' during execution.
         *
         * @param array<DataProviderTestSuite|TestCase> $tests
         *
         * @return array<DataProviderTestSuite|TestCase>
         */
        private function resolveDependencies(array $tests): array {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function calculateTestExecutionOrder(\PHPUnit\Framework\Test $suite): array {}

    }
}

namespace PHPUnit\Runner
{
    use array_slice;
    use dirname;
    use explode;
    use implode;
    use strpos;
    use SebastianBergmann\Version as VersionId;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class Version
    {
        /**
         * @var string
         */
        private static $pharVersion = '';

        /**
         * @var string
         */
        private static $version = '';

        /**
         * Returns the current version of PHPUnit.
         */
        public static function id(): string {}

        public static function series(): string {}

        public static function getVersionString(): string {}

    }
}

namespace PHPUnit\TextUI\CliArguments
{
    use array_map;
    use array_merge;
    use class_exists;
    use explode;
    use is_numeric;
    use str_replace;
    use PHPUnit\Runner\TestSuiteSorter;
    use PHPUnit\TextUI\DefaultResultPrinter;
    use PHPUnit\TextUI\XmlConfiguration\Extension;
    use PHPUnit\Util\Log\TeamCity;
    use PHPUnit\Util\TestDox\CliTestDoxPrinter;
    use SebastianBergmann\CliParser\Exception as CliParserException;
    use SebastianBergmann\CliParser\Parser as CliParser;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Builder
    {
        const LONG_OPTIONS = [/** value is missing */];

        const SHORT_OPTIONS = 'd:c:hv';

        public function fromParameters(array $parameters, array $additionalLongOptions): \PHPUnit\TextUI\CliArguments\Configuration {}

    }
}

namespace PHPUnit\TextUI\CliArguments
{
    use PHPUnit\TextUI\XmlConfiguration\Extension;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Configuration
    {
        /**
         * @var ?string
         */
        private $argument;

        /**
         * @var ?string
         */
        private $atLeastVersion;

        /**
         * @var ?bool
         */
        private $backupGlobals;

        /**
         * @var ?bool
         */
        private $backupStaticAttributes;

        /**
         * @var ?bool
         */
        private $beStrictAboutChangesToGlobalState;

        /**
         * @var ?bool
         */
        private $beStrictAboutResourceUsageDuringSmallTests;

        /**
         * @var ?string
         */
        private $bootstrap;

        /**
         * @var ?bool
         */
        private $cacheResult;

        /**
         * @var ?string
         */
        private $cacheResultFile;

        /**
         * @var ?bool
         */
        private $checkVersion;

        /**
         * @var ?string
         */
        private $colors;

        /**
         * @var null|int|string
         */
        private $columns;

        /**
         * @var ?string
         */
        private $configuration;

        /**
         * @var null|string[]
         */
        private $coverageFilter;

        /**
         * @var ?string
         */
        private $coverageClover;

        /**
         * @var ?string
         */
        private $coverageCobertura;

        /**
         * @var ?string
         */
        private $coverageCrap4J;

        /**
         * @var ?string
         */
        private $coverageHtml;

        /**
         * @var ?string
         */
        private $coveragePhp;

        /**
         * @var ?string
         */
        private $coverageText;

        /**
         * @var ?bool
         */
        private $coverageTextShowUncoveredFiles;

        /**
         * @var ?bool
         */
        private $coverageTextShowOnlySummary;

        /**
         * @var ?string
         */
        private $coverageXml;

        /**
         * @var ?bool
         */
        private $pathCoverage;

        /**
         * @var ?string
         */
        private $coverageCacheDirectory;

        /**
         * @var ?bool
         */
        private $warmCoverageCache;

        /**
         * @var ?bool
         */
        private $debug;

        /**
         * @var ?int
         */
        private $defaultTimeLimit;

        /**
         * @var ?bool
         */
        private $disableCodeCoverageIgnore;

        /**
         * @var ?bool
         */
        private $disallowTestOutput;

        /**
         * @var ?bool
         */
        private $disallowTodoAnnotatedTests;

        /**
         * @var ?bool
         */
        private $enforceTimeLimit;

        /**
         * @var null|string[]
         */
        private $excludeGroups;

        /**
         * @var ?int
         */
        private $executionOrder;

        /**
         * @var ?int
         */
        private $executionOrderDefects;

        /**
         * @var null|Extension[]
         */
        private $extensions;

        /**
         * @var null|string[]
         */
        private $unavailableExtensions;

        /**
         * @var ?bool
         */
        private $failOnEmptyTestSuite;

        /**
         * @var ?bool
         */
        private $failOnIncomplete;

        /**
         * @var ?bool
         */
        private $failOnRisky;

        /**
         * @var ?bool
         */
        private $failOnSkipped;

        /**
         * @var ?bool
         */
        private $failOnWarning;

        /**
         * @var ?string
         */
        private $filter;

        /**
         * @var ?bool
         */
        private $generateConfiguration;

        /**
         * @var ?bool
         */
        private $migrateConfiguration;

        /**
         * @var null|string[]
         */
        private $groups;

        /**
         * @var null|string[]
         */
        private $testsCovering;

        /**
         * @var null|string[]
         */
        private $testsUsing;

        /**
         * @var ?bool
         */
        private $help;

        /**
         * @var ?string
         */
        private $includePath;

        /**
         * @var null|string[]
         */
        private $iniSettings;

        /**
         * @var ?string
         */
        private $junitLogfile;

        /**
         * @var ?bool
         */
        private $listGroups;

        /**
         * @var ?bool
         */
        private $listSuites;

        /**
         * @var ?bool
         */
        private $listTests;

        /**
         * @var ?string
         */
        private $listTestsXml;

        /**
         * @var ?string
         */
        private $loader;

        /**
         * @var ?bool
         */
        private $noCoverage;

        /**
         * @var ?bool
         */
        private $noExtensions;

        /**
         * @var ?bool
         */
        private $noInteraction;

        /**
         * @var ?bool
         */
        private $noLogging;

        /**
         * @var ?string
         */
        private $printer;

        /**
         * @var ?bool
         */
        private $processIsolation;

        /**
         * @var ?int
         */
        private $randomOrderSeed;

        /**
         * @var ?int
         */
        private $repeat;

        /**
         * @var ?bool
         */
        private $reportUselessTests;

        /**
         * @var ?bool
         */
        private $resolveDependencies;

        /**
         * @var ?bool
         */
        private $reverseList;

        /**
         * @var ?bool
         */
        private $stderr;

        /**
         * @var ?bool
         */
        private $strictCoverage;

        /**
         * @var ?bool
         */
        private $stopOnDefect;

        /**
         * @var ?bool
         */
        private $stopOnError;

        /**
         * @var ?bool
         */
        private $stopOnFailure;

        /**
         * @var ?bool
         */
        private $stopOnIncomplete;

        /**
         * @var ?bool
         */
        private $stopOnRisky;

        /**
         * @var ?bool
         */
        private $stopOnSkipped;

        /**
         * @var ?bool
         */
        private $stopOnWarning;

        /**
         * @var ?string
         */
        private $teamcityLogfile;

        /**
         * @var null|string[]
         */
        private $testdoxExcludeGroups;

        /**
         * @var null|string[]
         */
        private $testdoxGroups;

        /**
         * @var ?string
         */
        private $testdoxHtmlFile;

        /**
         * @var ?string
         */
        private $testdoxTextFile;

        /**
         * @var ?string
         */
        private $testdoxXmlFile;

        /**
         * @var null|string[]
         */
        private $testSuffixes;

        /**
         * @var ?string
         */
        private $testSuite;

        /**
         * @var string[]
         */
        private $unrecognizedOptions;

        /**
         * @var ?string
         */
        private $unrecognizedOrderBy;

        /**
         * @var ?bool
         */
        private $useDefaultConfiguration;

        /**
         * @var ?bool
         */
        private $verbose;

        /**
         * @var ?bool
         */
        private $version;

        /**
         * @var ?string
         */
        private $xdebugFilterFile;

        /**
         * @param null|int|string $columns
         */
        public function __construct(?string $argument, ?string $atLeastVersion, ?bool $backupGlobals, ?bool $backupStaticAttributes, ?bool $beStrictAboutChangesToGlobalState, ?bool $beStrictAboutResourceUsageDuringSmallTests, ?string $bootstrap, ?bool $cacheResult, ?string $cacheResultFile, ?bool $checkVersion, ?string $colors, $columns, ?string $configuration, ?string $coverageClover, ?string $coverageCobertura, ?string $coverageCrap4J, ?string $coverageHtml, ?string $coveragePhp, ?string $coverageText, ?bool $coverageTextShowUncoveredFiles, ?bool $coverageTextShowOnlySummary, ?string $coverageXml, ?bool $pathCoverage, ?string $coverageCacheDirectory, ?bool $warmCoverageCache, ?bool $debug, ?int $defaultTimeLimit, ?bool $disableCodeCoverageIgnore, ?bool $disallowTestOutput, ?bool $disallowTodoAnnotatedTests, ?bool $enforceTimeLimit, ?array $excludeGroups, ?int $executionOrder, ?int $executionOrderDefects, ?array $extensions, ?array $unavailableExtensions, ?bool $failOnEmptyTestSuite, ?bool $failOnIncomplete, ?bool $failOnRisky, ?bool $failOnSkipped, ?bool $failOnWarning, ?string $filter, ?bool $generateConfiguration, ?bool $migrateConfiguration, ?array $groups, ?array $testsCovering, ?array $testsUsing, ?bool $help, ?string $includePath, ?array $iniSettings, ?string $junitLogfile, ?bool $listGroups, ?bool $listSuites, ?bool $listTests, ?string $listTestsXml, ?string $loader, ?bool $noCoverage, ?bool $noExtensions, ?bool $noInteraction, ?bool $noLogging, ?string $printer, ?bool $processIsolation, ?int $randomOrderSeed, ?int $repeat, ?bool $reportUselessTests, ?bool $resolveDependencies, ?bool $reverseList, ?bool $stderr, ?bool $strictCoverage, ?bool $stopOnDefect, ?bool $stopOnError, ?bool $stopOnFailure, ?bool $stopOnIncomplete, ?bool $stopOnRisky, ?bool $stopOnSkipped, ?bool $stopOnWarning, ?string $teamcityLogfile, ?array $testdoxExcludeGroups, ?array $testdoxGroups, ?string $testdoxHtmlFile, ?string $testdoxTextFile, ?string $testdoxXmlFile, ?array $testSuffixes, ?string $testSuite, array $unrecognizedOptions, ?string $unrecognizedOrderBy, ?bool $useDefaultConfiguration, ?bool $verbose, ?bool $version, ?array $coverageFilter, ?string $xdebugFilterFile) {}

        public function hasArgument(): bool {}

        /**
         * @throws Exception
         */
        public function argument(): string {}

        public function hasAtLeastVersion(): bool {}

        /**
         * @throws Exception
         */
        public function atLeastVersion(): string {}

        public function hasBackupGlobals(): bool {}

        /**
         * @throws Exception
         */
        public function backupGlobals(): bool {}

        public function hasBackupStaticAttributes(): bool {}

        /**
         * @throws Exception
         */
        public function backupStaticAttributes(): bool {}

        public function hasBeStrictAboutChangesToGlobalState(): bool {}

        /**
         * @throws Exception
         */
        public function beStrictAboutChangesToGlobalState(): bool {}

        public function hasBeStrictAboutResourceUsageDuringSmallTests(): bool {}

        /**
         * @throws Exception
         */
        public function beStrictAboutResourceUsageDuringSmallTests(): bool {}

        public function hasBootstrap(): bool {}

        /**
         * @throws Exception
         */
        public function bootstrap(): string {}

        public function hasCacheResult(): bool {}

        /**
         * @throws Exception
         */
        public function cacheResult(): bool {}

        public function hasCacheResultFile(): bool {}

        /**
         * @throws Exception
         */
        public function cacheResultFile(): string {}

        public function hasCheckVersion(): bool {}

        /**
         * @throws Exception
         */
        public function checkVersion(): bool {}

        public function hasColors(): bool {}

        /**
         * @throws Exception
         */
        public function colors(): string {}

        public function hasColumns(): bool {}

        /**
         * @throws Exception
         */
        public function columns() {}

        public function hasConfiguration(): bool {}

        /**
         * @throws Exception
         */
        public function configuration(): string {}

        public function hasCoverageFilter(): bool {}

        /**
         * @throws Exception
         */
        public function coverageFilter(): array {}

        public function hasCoverageClover(): bool {}

        /**
         * @throws Exception
         */
        public function coverageClover(): string {}

        public function hasCoverageCobertura(): bool {}

        /**
         * @throws Exception
         */
        public function coverageCobertura(): string {}

        public function hasCoverageCrap4J(): bool {}

        /**
         * @throws Exception
         */
        public function coverageCrap4J(): string {}

        public function hasCoverageHtml(): bool {}

        /**
         * @throws Exception
         */
        public function coverageHtml(): string {}

        public function hasCoveragePhp(): bool {}

        /**
         * @throws Exception
         */
        public function coveragePhp(): string {}

        public function hasCoverageText(): bool {}

        /**
         * @throws Exception
         */
        public function coverageText(): string {}

        public function hasCoverageTextShowUncoveredFiles(): bool {}

        /**
         * @throws Exception
         */
        public function coverageTextShowUncoveredFiles(): bool {}

        public function hasCoverageTextShowOnlySummary(): bool {}

        /**
         * @throws Exception
         */
        public function coverageTextShowOnlySummary(): bool {}

        public function hasCoverageXml(): bool {}

        /**
         * @throws Exception
         */
        public function coverageXml(): string {}

        public function hasPathCoverage(): bool {}

        /**
         * @throws Exception
         */
        public function pathCoverage(): bool {}

        public function hasCoverageCacheDirectory(): bool {}

        /**
         * @throws Exception
         */
        public function coverageCacheDirectory(): string {}

        public function hasWarmCoverageCache(): bool {}

        /**
         * @throws Exception
         */
        public function warmCoverageCache(): bool {}

        public function hasDebug(): bool {}

        /**
         * @throws Exception
         */
        public function debug(): bool {}

        public function hasDefaultTimeLimit(): bool {}

        /**
         * @throws Exception
         */
        public function defaultTimeLimit(): int {}

        public function hasDisableCodeCoverageIgnore(): bool {}

        /**
         * @throws Exception
         */
        public function disableCodeCoverageIgnore(): bool {}

        public function hasDisallowTestOutput(): bool {}

        /**
         * @throws Exception
         */
        public function disallowTestOutput(): bool {}

        public function hasDisallowTodoAnnotatedTests(): bool {}

        /**
         * @throws Exception
         */
        public function disallowTodoAnnotatedTests(): bool {}

        public function hasEnforceTimeLimit(): bool {}

        /**
         * @throws Exception
         */
        public function enforceTimeLimit(): bool {}

        public function hasExcludeGroups(): bool {}

        /**
         * @throws Exception
         */
        public function excludeGroups(): array {}

        public function hasExecutionOrder(): bool {}

        /**
         * @throws Exception
         */
        public function executionOrder(): int {}

        public function hasExecutionOrderDefects(): bool {}

        /**
         * @throws Exception
         */
        public function executionOrderDefects(): int {}

        public function hasFailOnEmptyTestSuite(): bool {}

        /**
         * @throws Exception
         */
        public function failOnEmptyTestSuite(): bool {}

        public function hasFailOnIncomplete(): bool {}

        /**
         * @throws Exception
         */
        public function failOnIncomplete(): bool {}

        public function hasFailOnRisky(): bool {}

        /**
         * @throws Exception
         */
        public function failOnRisky(): bool {}

        public function hasFailOnSkipped(): bool {}

        /**
         * @throws Exception
         */
        public function failOnSkipped(): bool {}

        public function hasFailOnWarning(): bool {}

        /**
         * @throws Exception
         */
        public function failOnWarning(): bool {}

        public function hasFilter(): bool {}

        /**
         * @throws Exception
         */
        public function filter(): string {}

        public function hasGenerateConfiguration(): bool {}

        /**
         * @throws Exception
         */
        public function generateConfiguration(): bool {}

        public function hasMigrateConfiguration(): bool {}

        /**
         * @throws Exception
         */
        public function migrateConfiguration(): bool {}

        public function hasGroups(): bool {}

        /**
         * @throws Exception
         */
        public function groups(): array {}

        public function hasTestsCovering(): bool {}

        /**
         * @throws Exception
         */
        public function testsCovering(): array {}

        public function hasTestsUsing(): bool {}

        /**
         * @throws Exception
         */
        public function testsUsing(): array {}

        public function hasHelp(): bool {}

        /**
         * @throws Exception
         */
        public function help(): bool {}

        public function hasIncludePath(): bool {}

        /**
         * @throws Exception
         */
        public function includePath(): string {}

        public function hasIniSettings(): bool {}

        /**
         * @throws Exception
         */
        public function iniSettings(): array {}

        public function hasJunitLogfile(): bool {}

        /**
         * @throws Exception
         */
        public function junitLogfile(): string {}

        public function hasListGroups(): bool {}

        /**
         * @throws Exception
         */
        public function listGroups(): bool {}

        public function hasListSuites(): bool {}

        /**
         * @throws Exception
         */
        public function listSuites(): bool {}

        public function hasListTests(): bool {}

        /**
         * @throws Exception
         */
        public function listTests(): bool {}

        public function hasListTestsXml(): bool {}

        /**
         * @throws Exception
         */
        public function listTestsXml(): string {}

        public function hasLoader(): bool {}

        /**
         * @throws Exception
         */
        public function loader(): string {}

        public function hasNoCoverage(): bool {}

        /**
         * @throws Exception
         */
        public function noCoverage(): bool {}

        public function hasNoExtensions(): bool {}

        /**
         * @throws Exception
         */
        public function noExtensions(): bool {}

        public function hasExtensions(): bool {}

        /**
         * @throws Exception
         */
        public function extensions(): array {}

        public function hasUnavailableExtensions(): bool {}

        /**
         * @throws Exception
         */
        public function unavailableExtensions(): array {}

        public function hasNoInteraction(): bool {}

        /**
         * @throws Exception
         */
        public function noInteraction(): bool {}

        public function hasNoLogging(): bool {}

        /**
         * @throws Exception
         */
        public function noLogging(): bool {}

        public function hasPrinter(): bool {}

        /**
         * @throws Exception
         */
        public function printer(): string {}

        public function hasProcessIsolation(): bool {}

        /**
         * @throws Exception
         */
        public function processIsolation(): bool {}

        public function hasRandomOrderSeer(): bool {}

        /**
         * @throws Exception
         */
        public function randomOrderSeed(): int {}

        public function hasRepeat(): bool {}

        /**
         * @throws Exception
         */
        public function repeat(): int {}

        public function hasReportUselessTests(): bool {}

        /**
         * @throws Exception
         */
        public function reportUselessTests(): bool {}

        public function hasResolveDependencies(): bool {}

        /**
         * @throws Exception
         */
        public function resolveDependencies(): bool {}

        public function hasReverseList(): bool {}

        /**
         * @throws Exception
         */
        public function reverseList(): bool {}

        public function hasStderr(): bool {}

        /**
         * @throws Exception
         */
        public function stderr(): bool {}

        public function hasStrictCoverage(): bool {}

        /**
         * @throws Exception
         */
        public function strictCoverage(): bool {}

        public function hasStopOnDefect(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnDefect(): bool {}

        public function hasStopOnError(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnError(): bool {}

        public function hasStopOnFailure(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnFailure(): bool {}

        public function hasStopOnIncomplete(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnIncomplete(): bool {}

        public function hasStopOnRisky(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnRisky(): bool {}

        public function hasStopOnSkipped(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnSkipped(): bool {}

        public function hasStopOnWarning(): bool {}

        /**
         * @throws Exception
         */
        public function stopOnWarning(): bool {}

        public function hasTeamcityLogfile(): bool {}

        /**
         * @throws Exception
         */
        public function teamcityLogfile(): string {}

        public function hasTestdoxExcludeGroups(): bool {}

        /**
         * @throws Exception
         */
        public function testdoxExcludeGroups(): array {}

        public function hasTestdoxGroups(): bool {}

        /**
         * @throws Exception
         */
        public function testdoxGroups(): array {}

        public function hasTestdoxHtmlFile(): bool {}

        /**
         * @throws Exception
         */
        public function testdoxHtmlFile(): string {}

        public function hasTestdoxTextFile(): bool {}

        /**
         * @throws Exception
         */
        public function testdoxTextFile(): string {}

        public function hasTestdoxXmlFile(): bool {}

        /**
         * @throws Exception
         */
        public function testdoxXmlFile(): string {}

        public function hasTestSuffixes(): bool {}

        /**
         * @throws Exception
         */
        public function testSuffixes(): array {}

        public function hasTestSuite(): bool {}

        /**
         * @throws Exception
         */
        public function testSuite(): string {}

        public function unrecognizedOptions(): array {}

        public function hasUnrecognizedOrderBy(): bool {}

        /**
         * @throws Exception
         */
        public function unrecognizedOrderBy(): string {}

        public function hasUseDefaultConfiguration(): bool {}

        /**
         * @throws Exception
         */
        public function useDefaultConfiguration(): bool {}

        public function hasVerbose(): bool {}

        /**
         * @throws Exception
         */
        public function verbose(): bool {}

        public function hasVersion(): bool {}

        /**
         * @throws Exception
         */
        public function version(): bool {}

        public function hasXdebugFilterFile(): bool {}

        /**
         * @throws Exception
         */
        public function xdebugFilterFile(): string {}

    }
}

namespace PHPUnit\TextUI\CliArguments
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\TextUI\CliArguments
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Mapper
    {
        /**
         * @throws Exception
         */
        public function mapToLegacyArray(\PHPUnit\TextUI\CliArguments\Configuration $arguments): array {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Directory
    {
        /**
         * @var string
         */
        private $path;

        /**
         * @var string
         */
        private $prefix;

        /**
         * @var string
         */
        private $suffix;

        /**
         * @var string
         */
        private $group;

        public function __construct(string $path, string $prefix, string $suffix, string $group) {}

        public function path(): string {}

        public function prefix(): string {}

        public function suffix(): string {}

        public function group(): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class DirectoryCollection
    {
        /**
         * @var Directory[]
         */
        private $directories;

        /**
         * @param Directory[] $directories
         */
        public static function fromArray(array $directories): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory ...$directories) {}

        /**
         * @return Directory[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class DirectoryCollectionIterator
    {
        /**
         * @var Directory[]
         */
        private $directories;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $directories) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Clover
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Cobertura
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Crap4j
    {
        /**
         * @var File
         */
        private $target;

        /**
         * @var int
         */
        private $threshold;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target, int $threshold) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

        public function threshold(): int {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\Directory;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Html
    {
        /**
         * @var Directory
         */
        private $target;

        /**
         * @var int
         */
        private $lowUpperBound;

        /**
         * @var int
         */
        private $highLowerBound;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory $target, int $lowUpperBound, int $highLowerBound) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\Directory {}

        public function lowUpperBound(): int {}

        public function highLowerBound(): int {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Php
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Text
    {
        /**
         * @var File
         */
        private $target;

        /**
         * @var bool
         */
        private $showUncoveredFiles;

        /**
         * @var bool
         */
        private $showOnlySummary;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target, bool $showUncoveredFiles, bool $showOnlySummary) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

        public function showUncoveredFiles(): bool {}

        public function showOnlySummary(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report
{
    use PHPUnit\TextUI\XmlConfiguration\Directory;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Xml
    {
        /**
         * @var Directory
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\Directory {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage
{
    use count;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml;
    use PHPUnit\TextUI\XmlConfiguration\Directory;
    use PHPUnit\TextUI\XmlConfiguration\Exception;
    use PHPUnit\TextUI\XmlConfiguration\FileCollection;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class CodeCoverage
    {
        /**
         * @var ?Directory
         */
        private $cacheDirectory;

        /**
         * @var DirectoryCollection
         */
        private $directories;

        /**
         * @var FileCollection
         */
        private $files;

        /**
         * @var DirectoryCollection
         */
        private $excludeDirectories;

        /**
         * @var FileCollection
         */
        private $excludeFiles;

        /**
         * @var bool
         */
        private $pathCoverage;

        /**
         * @var bool
         */
        private $includeUncoveredFiles;

        /**
         * @var bool
         */
        private $processUncoveredFiles;

        /**
         * @var bool
         */
        private $ignoreDeprecatedCodeUnits;

        /**
         * @var bool
         */
        private $disableCodeCoverageIgnore;

        /**
         * @var ?Clover
         */
        private $clover;

        /**
         * @var ?Cobertura
         */
        private $cobertura;

        /**
         * @var ?Crap4j
         */
        private $crap4j;

        /**
         * @var ?Html
         */
        private $html;

        /**
         * @var ?Php
         */
        private $php;

        /**
         * @var ?Text
         */
        private $text;

        /**
         * @var ?Xml
         */
        private $xml;

        public function __construct(?\PHPUnit\TextUI\XmlConfiguration\Directory $cacheDirectory, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $directories, \PHPUnit\TextUI\XmlConfiguration\FileCollection $files, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $excludeDirectories, \PHPUnit\TextUI\XmlConfiguration\FileCollection $excludeFiles, bool $pathCoverage, bool $includeUncoveredFiles, bool $processUncoveredFiles, bool $ignoreDeprecatedCodeUnits, bool $disableCodeCoverageIgnore, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover $clover, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura $cobertura, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j $crap4j, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html $html, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php $php, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text $text, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml $xml) {}

        /**
         * @psalm-assert-if-true !null $this->cacheDirectory
         */
        public function hasCacheDirectory(): bool {}

        /**
         * @throws Exception
         */
        public function cacheDirectory(): \PHPUnit\TextUI\XmlConfiguration\Directory {}

        public function hasNonEmptyListOfFilesToBeIncludedInCodeCoverageReport(): bool {}

        public function directories(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection {}

        public function files(): \PHPUnit\TextUI\XmlConfiguration\FileCollection {}

        public function excludeDirectories(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection {}

        public function excludeFiles(): \PHPUnit\TextUI\XmlConfiguration\FileCollection {}

        public function pathCoverage(): bool {}

        public function includeUncoveredFiles(): bool {}

        public function ignoreDeprecatedCodeUnits(): bool {}

        public function disableCodeCoverageIgnore(): bool {}

        public function processUncoveredFiles(): bool {}

        /**
         * @psalm-assert-if-true !null $this->clover
         */
        public function hasClover(): bool {}

        /**
         * @throws Exception
         */
        public function clover(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover {}

        /**
         * @psalm-assert-if-true !null $this->cobertura
         */
        public function hasCobertura(): bool {}

        /**
         * @throws Exception
         */
        public function cobertura(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura {}

        /**
         * @psalm-assert-if-true !null $this->crap4j
         */
        public function hasCrap4j(): bool {}

        /**
         * @throws Exception
         */
        public function crap4j(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j {}

        /**
         * @psalm-assert-if-true !null $this->html
         */
        public function hasHtml(): bool {}

        /**
         * @throws Exception
         */
        public function html(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html {}

        /**
         * @psalm-assert-if-true !null $this->php
         */
        public function hasPhp(): bool {}

        /**
         * @throws Exception
         */
        public function php(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php {}

        /**
         * @psalm-assert-if-true !null $this->text
         */
        public function hasText(): bool {}

        /**
         * @throws Exception
         */
        public function text(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text {}

        /**
         * @psalm-assert-if-true !null $this->xml
         */
        public function hasXml(): bool {}

        /**
         * @throws Exception
         */
        public function xml(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage
{
    use SebastianBergmann\CodeCoverage\Filter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class FilterMapper
    {
        public function map(\SebastianBergmann\CodeCoverage\Filter $filter, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $configuration): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Directory
    {
        /**
         * @var string
         */
        private $path;

        public function __construct(string $path) {}

        public function path(): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class DirectoryCollection
    {
        /**
         * @var Directory[]
         */
        private $directories;

        /**
         * @param Directory[] $directories
         */
        public static function fromArray(array $directories): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory ...$directories) {}

        /**
         * @return Directory[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\DirectoryCollectionIterator {}

        public function isEmpty(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class DirectoryCollectionIterator
    {
        /**
         * @var Directory[]
         */
        private $directories;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $directories) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\Directory {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class File
    {
        /**
         * @var string
         */
        private $path;

        public function __construct(string $path) {}

        public function path(): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class FileCollection
    {
        /**
         * @var File[]
         */
        private $files;

        /**
         * @param File[] $files
         */
        public static function fromArray(array $files): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\File ...$files) {}

        /**
         * @return File[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\FileCollectionIterator {}

        public function isEmpty(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class FileCollectionIterator
    {
        /**
         * @var File[]
         */
        private $files;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\FileCollection $files) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\File {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Group
    {
        /**
         * @var string
         */
        private $name;

        public function __construct(string $name) {}

        public function name(): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class GroupCollection
    {
        /**
         * @var Group[]
         */
        private $groups;

        /**
         * @param Group[] $groups
         */
        public static function fromArray(array $groups): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\Group ...$groups) {}

        /**
         * @return Group[]
         */
        public function asArray(): array {}

        /**
         * @return string[]
         */
        public function asArrayOfStrings(): array {}

        public function isEmpty(): bool {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\GroupCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class GroupCollectionIterator
    {
        /**
         * @var Group[]
         */
        private $groups;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\GroupCollection $groups) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\Group {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Groups
    {
        /**
         * @var GroupCollection
         */
        private $include;

        /**
         * @var GroupCollection
         */
        private $exclude;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\GroupCollection $include, \PHPUnit\TextUI\XmlConfiguration\GroupCollection $exclude) {}

        public function hasInclude(): bool {}

        public function include(): \PHPUnit\TextUI\XmlConfiguration\GroupCollection {}

        public function hasExclude(): bool {}

        public function exclude(): \PHPUnit\TextUI\XmlConfiguration\GroupCollection {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConvertLogTypes implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoverageCloverToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoverageCrap4jToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoverageHtmlToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoveragePhpToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoverageTextToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class CoverageXmlToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
    {
        protected function forType(): string {}

        protected function toReportFormat(\DOMElement $logNode): \DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IntroduceCoverageElement implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use sprintf;
    use DOMDocument;
    use DOMElement;
    use DOMXPath;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class LogToReportMigration implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

        protected function migrateAttributes(\DOMElement $src, \DOMElement $dest, array $attributes): \void {}

        abstract protected function forType(): string;

        abstract protected function toReportFormat(\DOMElement $logNode): \DOMElement;

        private function findLogNode(\DOMDocument $document): ?\DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Migration
    {
        public function migrate(\DOMDocument $document): \void;

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MoveAttributesFromFilterWhitelistToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MoveAttributesFromRootToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Util\Xml\SnapshotNodeList;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MoveWhitelistDirectoriesToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Util\Xml\SnapshotNodeList;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MoveWhitelistExcludesToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class RemoveCacheTokensAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use sprintf;
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class RemoveEmptyFilter implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        /**
         * @throws MigrationException
         */
        public function migrate(\DOMDocument $document): \void {}

        /**
         * @throws MigrationException
         */
        private function ensureEmpty(\DOMElement $element): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Util\Xml\SnapshotNodeList;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class RemoveLogTypes implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class UpdateSchemaLocationTo93 implements \PHPUnit\TextUI\XmlConfiguration\Migration
    {
        public function migrate(\DOMDocument $document): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use array_key_exists;
    use sprintf;
    use version_compare;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MigrationBuilder
    {
        const AVAILABLE_MIGRATIONS = [/** value is missing */];

        /**
         * @throws MigrationBuilderException
         */
        public function build(string $fromVersion): array {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MigrationBuilderException extends \RuntimeException
    {
    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class MigrationException extends \RuntimeException
    {
    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use sprintf;
    use PHPUnit\Util\Xml\Exception as XmlException;
    use PHPUnit\Util\Xml\Loader as XmlLoader;
    use PHPUnit\Util\Xml\SchemaDetector;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Migrator
    {
        /**
         * @throws MigrationBuilderException
         * @throws MigrationException
         * @throws Exception
         * @throws XmlException
         */
        public function migrate(string $filename): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Constant
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var mixed
         */
        private $value;

        public function __construct(string $name, $value) {}

        public function name(): string {}

        public function value() {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class ConstantCollection
    {
        /**
         * @var Constant[]
         */
        private $constants;

        /**
         * @param Constant[] $constants
         */
        public static function fromArray(array $constants): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\Constant ...$constants) {}

        /**
         * @return Constant[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\ConstantCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ConstantCollectionIterator
    {
        /**
         * @var Constant[]
         */
        private $constants;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\Constant {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class IniSetting
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var string
         */
        private $value;

        public function __construct(string $name, string $value) {}

        public function name(): string {}

        public function value(): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class IniSettingCollection
    {
        /**
         * @var IniSetting[]
         */
        private $iniSettings;

        /**
         * @param IniSetting[] $iniSettings
         */
        public static function fromArray(array $iniSettings): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\IniSetting ...$iniSettings) {}

        /**
         * @return IniSetting[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\IniSettingCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class IniSettingCollectionIterator
    {
        /**
         * @var IniSetting[]
         */
        private $iniSettings;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\IniSetting {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Php
    {
        /**
         * @var DirectoryCollection
         */
        private $includePaths;

        /**
         * @var IniSettingCollection
         */
        private $iniSettings;

        /**
         * @var ConstantCollection
         */
        private $constants;

        /**
         * @var VariableCollection
         */
        private $globalVariables;

        /**
         * @var VariableCollection
         */
        private $envVariables;

        /**
         * @var VariableCollection
         */
        private $postVariables;

        /**
         * @var VariableCollection
         */
        private $getVariables;

        /**
         * @var VariableCollection
         */
        private $cookieVariables;

        /**
         * @var VariableCollection
         */
        private $serverVariables;

        /**
         * @var VariableCollection
         */
        private $filesVariables;

        /**
         * @var VariableCollection
         */
        private $requestVariables;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $includePaths, \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings, \PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $globalVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $envVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $postVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $getVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $cookieVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $serverVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $filesVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $requestVariables) {}

        public function includePaths(): \PHPUnit\TextUI\XmlConfiguration\DirectoryCollection {}

        public function iniSettings(): \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection {}

        public function constants(): \PHPUnit\TextUI\XmlConfiguration\ConstantCollection {}

        public function globalVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function envVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function postVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function getVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function cookieVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function serverVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function filesVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

        public function requestVariables(): \PHPUnit\TextUI\XmlConfiguration\VariableCollection {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use PATH_SEPARATOR;
    use constant;
    use define;
    use defined;
    use getenv;
    use implode;
    use ini_get;
    use ini_set;
    use putenv;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class PhpHandler
    {
        public function handle(\PHPUnit\TextUI\XmlConfiguration\Php $configuration): \void {}

        private function handleIncludePaths(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $includePaths): \void {}

        private function handleIniSettings(\PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings): \void {}

        private function handleConstants(\PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants): \void {}

        private function handleGlobalVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables): \void {}

        private function handleServerVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables): \void {}

        private function handleVariables(string $target, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables): \void {}

        private function handleEnvVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Variable
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var mixed
         */
        private $value;

        /**
         * @var bool
         */
        private $force;

        public function __construct(string $name, $value, bool $force) {}

        public function name(): string {}

        public function value() {}

        public function force(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class VariableCollection
    {
        /**
         * @var Variable[]
         */
        private $variables;

        /**
         * @param Variable[] $variables
         */
        public static function fromArray(array $variables): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\Variable ...$variables) {}

        /**
         * @return Variable[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\VariableCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class VariableCollectionIterator
    {
        /**
         * @var Variable[]
         */
        private $variables;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\Variable {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Extension
    {
        /**
         * @var string
         * @psalm-var class-string
         */
        private $className;

        /**
         * @var string
         */
        private $sourceFile;

        /**
         * @var array
         */
        private $arguments;

        /**
         * @psalm-param class-string $className
         */
        public function __construct(string $className, string $sourceFile, array $arguments) {}

        /**
         * @psalm-return class-string
         */
        public function className(): string {}

        public function hasSourceFile(): bool {}

        public function sourceFile(): string {}

        public function hasArguments(): bool {}

        public function arguments(): array {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class ExtensionCollection
    {
        /**
         * @var Extension[]
         */
        private $extensions;

        /**
         * @param Extension[] $extensions
         */
        public static function fromArray(array $extensions): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\Extension ...$extensions) {}

        /**
         * @return Extension[]
         */
        public function asArray(): array {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\ExtensionCollectionIterator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExtensionCollectionIterator
    {
        /**
         * @var Extension[]
         */
        private $extensions;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $extensions) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\Extension {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use class_exists;
    use sprintf;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\TestListener;
    use PHPUnit\Runner\Hook;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ExtensionHandler
    {
        public function createHookInstance(\PHPUnit\TextUI\XmlConfiguration\Extension $extension): \PHPUnit\Runner\Hook {}

        public function createTestListenerInstance(\PHPUnit\TextUI\XmlConfiguration\Extension $extension): \PHPUnit\Framework\TestListener {}

        private function createInstance(\PHPUnit\TextUI\XmlConfiguration\Extension $extension): object {}

        /**
         * @throws Exception
         */
        private function ensureClassExists(\PHPUnit\TextUI\XmlConfiguration\Extension $extension): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class PHPUnit
    {
        /**
         * @var bool
         */
        private $cacheResult;

        /**
         * @var ?string
         */
        private $cacheResultFile;

        /**
         * @var int|string
         */
        private $columns;

        /**
         * @var string
         */
        private $colors;

        /**
         * @var bool
         */
        private $stderr;

        /**
         * @var bool
         */
        private $noInteraction;

        /**
         * @var bool
         */
        private $verbose;

        /**
         * @var bool
         */
        private $reverseDefectList;

        /**
         * @var bool
         */
        private $convertDeprecationsToExceptions;

        /**
         * @var bool
         */
        private $convertErrorsToExceptions;

        /**
         * @var bool
         */
        private $convertNoticesToExceptions;

        /**
         * @var bool
         */
        private $convertWarningsToExceptions;

        /**
         * @var bool
         */
        private $forceCoversAnnotation;

        /**
         * @var ?string
         */
        private $bootstrap;

        /**
         * @var bool
         */
        private $processIsolation;

        /**
         * @var bool
         */
        private $failOnEmptyTestSuite;

        /**
         * @var bool
         */
        private $failOnIncomplete;

        /**
         * @var bool
         */
        private $failOnRisky;

        /**
         * @var bool
         */
        private $failOnSkipped;

        /**
         * @var bool
         */
        private $failOnWarning;

        /**
         * @var bool
         */
        private $stopOnDefect;

        /**
         * @var bool
         */
        private $stopOnError;

        /**
         * @var bool
         */
        private $stopOnFailure;

        /**
         * @var bool
         */
        private $stopOnWarning;

        /**
         * @var bool
         */
        private $stopOnIncomplete;

        /**
         * @var bool
         */
        private $stopOnRisky;

        /**
         * @var bool
         */
        private $stopOnSkipped;

        /**
         * @var ?string
         */
        private $extensionsDirectory;

        /**
         * @var ?string
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        private $testSuiteLoaderClass;

        /**
         * @var ?string
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        private $testSuiteLoaderFile;

        /**
         * @var ?string
         */
        private $printerClass;

        /**
         * @var ?string
         */
        private $printerFile;

        /**
         * @var bool
         */
        private $beStrictAboutChangesToGlobalState;

        /**
         * @var bool
         */
        private $beStrictAboutOutputDuringTests;

        /**
         * @var bool
         */
        private $beStrictAboutResourceUsageDuringSmallTests;

        /**
         * @var bool
         */
        private $beStrictAboutTestsThatDoNotTestAnything;

        /**
         * @var bool
         */
        private $beStrictAboutTodoAnnotatedTests;

        /**
         * @var bool
         */
        private $beStrictAboutCoversAnnotation;

        /**
         * @var bool
         */
        private $enforceTimeLimit;

        /**
         * @var int
         */
        private $defaultTimeLimit;

        /**
         * @var int
         */
        private $timeoutForSmallTests;

        /**
         * @var int
         */
        private $timeoutForMediumTests;

        /**
         * @var int
         */
        private $timeoutForLargeTests;

        /**
         * @var ?string
         */
        private $defaultTestSuite;

        /**
         * @var int
         */
        private $executionOrder;

        /**
         * @var bool
         */
        private $resolveDependencies;

        /**
         * @var bool
         */
        private $defectsFirst;

        /**
         * @var bool
         */
        private $backupGlobals;

        /**
         * @var bool
         */
        private $backupStaticAttributes;

        /**
         * @var bool
         */
        private $registerMockObjectsFromTestArgumentsRecursively;

        /**
         * @var bool
         */
        private $conflictBetweenPrinterClassAndTestdox;

        public function __construct(bool $cacheResult, ?string $cacheResultFile, $columns, string $colors, bool $stderr, bool $noInteraction, bool $verbose, bool $reverseDefectList, bool $convertDeprecationsToExceptions, bool $convertErrorsToExceptions, bool $convertNoticesToExceptions, bool $convertWarningsToExceptions, bool $forceCoversAnnotation, ?string $bootstrap, bool $processIsolation, bool $failOnEmptyTestSuite, bool $failOnIncomplete, bool $failOnRisky, bool $failOnSkipped, bool $failOnWarning, bool $stopOnDefect, bool $stopOnError, bool $stopOnFailure, bool $stopOnWarning, bool $stopOnIncomplete, bool $stopOnRisky, bool $stopOnSkipped, ?string $extensionsDirectory, ?string $testSuiteLoaderClass, ?string $testSuiteLoaderFile, ?string $printerClass, ?string $printerFile, bool $beStrictAboutChangesToGlobalState, bool $beStrictAboutOutputDuringTests, bool $beStrictAboutResourceUsageDuringSmallTests, bool $beStrictAboutTestsThatDoNotTestAnything, bool $beStrictAboutTodoAnnotatedTests, bool $beStrictAboutCoversAnnotation, bool $enforceTimeLimit, int $defaultTimeLimit, int $timeoutForSmallTests, int $timeoutForMediumTests, int $timeoutForLargeTests, ?string $defaultTestSuite, int $executionOrder, bool $resolveDependencies, bool $defectsFirst, bool $backupGlobals, bool $backupStaticAttributes, bool $registerMockObjectsFromTestArgumentsRecursively, bool $conflictBetweenPrinterClassAndTestdox) {}

        public function cacheResult(): bool {}

        /**
         * @psalm-assert-if-true !null $this->cacheResultFile
         */
        public function hasCacheResultFile(): bool {}

        /**
         * @throws Exception
         */
        public function cacheResultFile(): string {}

        public function columns() {}

        public function colors(): string {}

        public function stderr(): bool {}

        public function noInteraction(): bool {}

        public function verbose(): bool {}

        public function reverseDefectList(): bool {}

        public function convertDeprecationsToExceptions(): bool {}

        public function convertErrorsToExceptions(): bool {}

        public function convertNoticesToExceptions(): bool {}

        public function convertWarningsToExceptions(): bool {}

        public function forceCoversAnnotation(): bool {}

        /**
         * @psalm-assert-if-true !null $this->bootstrap
         */
        public function hasBootstrap(): bool {}

        /**
         * @throws Exception
         */
        public function bootstrap(): string {}

        public function processIsolation(): bool {}

        public function failOnEmptyTestSuite(): bool {}

        public function failOnIncomplete(): bool {}

        public function failOnRisky(): bool {}

        public function failOnSkipped(): bool {}

        public function failOnWarning(): bool {}

        public function stopOnDefect(): bool {}

        public function stopOnError(): bool {}

        public function stopOnFailure(): bool {}

        public function stopOnWarning(): bool {}

        public function stopOnIncomplete(): bool {}

        public function stopOnRisky(): bool {}

        public function stopOnSkipped(): bool {}

        /**
         * @psalm-assert-if-true !null $this->extensionsDirectory
         */
        public function hasExtensionsDirectory(): bool {}

        /**
         * @throws Exception
         */
        public function extensionsDirectory(): string {}

        /**
         * @psalm-assert-if-true !null $this->testSuiteLoaderClass
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        public function hasTestSuiteLoaderClass(): bool {}

        /**
         * @throws Exception
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        public function testSuiteLoaderClass(): string {}

        /**
         * @psalm-assert-if-true !null $this->testSuiteLoaderFile
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        public function hasTestSuiteLoaderFile(): bool {}

        /**
         * @throws Exception
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        public function testSuiteLoaderFile(): string {}

        /**
         * @psalm-assert-if-true !null $this->printerClass
         */
        public function hasPrinterClass(): bool {}

        /**
         * @throws Exception
         */
        public function printerClass(): string {}

        /**
         * @psalm-assert-if-true !null $this->printerFile
         */
        public function hasPrinterFile(): bool {}

        /**
         * @throws Exception
         */
        public function printerFile(): string {}

        public function beStrictAboutChangesToGlobalState(): bool {}

        public function beStrictAboutOutputDuringTests(): bool {}

        public function beStrictAboutResourceUsageDuringSmallTests(): bool {}

        public function beStrictAboutTestsThatDoNotTestAnything(): bool {}

        public function beStrictAboutTodoAnnotatedTests(): bool {}

        public function beStrictAboutCoversAnnotation(): bool {}

        public function enforceTimeLimit(): bool {}

        public function defaultTimeLimit(): int {}

        public function timeoutForSmallTests(): int {}

        public function timeoutForMediumTests(): int {}

        public function timeoutForLargeTests(): int {}

        /**
         * @psalm-assert-if-true !null $this->defaultTestSuite
         */
        public function hasDefaultTestSuite(): bool {}

        /**
         * @throws Exception
         */
        public function defaultTestSuite(): string {}

        public function executionOrder(): int {}

        public function resolveDependencies(): bool {}

        public function defectsFirst(): bool {}

        public function backupGlobals(): bool {}

        public function backupStaticAttributes(): bool {}

        public function registerMockObjectsFromTestArgumentsRecursively(): bool {}

        public function conflictBetweenPrinterClassAndTestdox(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use PHPUnit\Util\VersionComparisonOperator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestDirectory
    {
        /**
         * @var string
         */
        private $path;

        /**
         * @var string
         */
        private $prefix;

        /**
         * @var string
         */
        private $suffix;

        /**
         * @var string
         */
        private $phpVersion;

        /**
         * @var VersionComparisonOperator
         */
        private $phpVersionOperator;

        public function __construct(string $path, string $prefix, string $suffix, string $phpVersion, \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator) {}

        public function path(): string {}

        public function prefix(): string {}

        public function suffix(): string {}

        public function phpVersion(): string {}

        public function phpVersionOperator(): \PHPUnit\Util\VersionComparisonOperator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestDirectoryCollection
    {
        /**
         * @var TestDirectory[]
         */
        private $directories;

        /**
         * @param TestDirectory[] $directories
         */
        public static function fromArray(array $directories): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestDirectory ...$directories) {}

        /**
         * @return TestDirectory[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollectionIterator {}

        public function isEmpty(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestDirectoryCollectionIterator
    {
        /**
         * @var TestDirectory[]
         */
        private $directories;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection $directories) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\TestDirectory {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use PHPUnit\Util\VersionComparisonOperator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestFile
    {
        /**
         * @var string
         */
        private $path;

        /**
         * @var string
         */
        private $phpVersion;

        /**
         * @var VersionComparisonOperator
         */
        private $phpVersionOperator;

        public function __construct(string $path, string $phpVersion, \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator) {}

        public function path(): string {}

        public function phpVersion(): string {}

        public function phpVersionOperator(): \PHPUnit\Util\VersionComparisonOperator {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestFileCollection
    {
        /**
         * @var TestFile[]
         */
        private $files;

        /**
         * @param TestFile[] $files
         */
        public static function fromArray(array $files): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestFile ...$files) {}

        /**
         * @return TestFile[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\TestFileCollectionIterator {}

        public function isEmpty(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestFileCollectionIterator
    {
        /**
         * @var TestFile[]
         */
        private $files;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestFileCollection $files) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\TestFile {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestSuite
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var TestDirectoryCollection
         */
        private $directories;

        /**
         * @var TestFileCollection
         */
        private $files;

        /**
         * @var FileCollection
         */
        private $exclude;

        public function __construct(string $name, \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection $directories, \PHPUnit\TextUI\XmlConfiguration\TestFileCollection $files, \PHPUnit\TextUI\XmlConfiguration\FileCollection $exclude) {}

        public function name(): string {}

        public function directories(): \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection {}

        public function files(): \PHPUnit\TextUI\XmlConfiguration\TestFileCollection {}

        public function exclude(): \PHPUnit\TextUI\XmlConfiguration\FileCollection {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TestSuiteCollection
    {
        /**
         * @var TestSuite[]
         */
        private $testSuites;

        /**
         * @param TestSuite[] $testSuites
         */
        public static function fromArray(array $testSuites): self {}

        private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestSuite ...$testSuites) {}

        /**
         * @return TestSuite[]
         */
        public function asArray(): array {}

        public function count(): int {}

        public function getIterator(): \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollectionIterator {}

        public function isEmpty(): bool {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use count;
    use iterator_count;
    use Countable;
    use Iterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestSuiteCollectionIterator
    {
        /**
         * @var TestSuite[]
         */
        private $testSuites;

        /**
         * @var int
         */
        private $position;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $testSuites) {}

        public function count(): int {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PHPUnit\TextUI\XmlConfiguration\TestSuite {}

        public function next(): \void {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use PHP_VERSION;
    use explode;
    use in_array;
    use version_compare;
    use PHPUnit\Framework\TestSuite as TestSuiteObject;
    use SebastianBergmann\FileIterator\Facade;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestSuiteMapper
    {
        public function map(\PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $configuration, string $filter): \PHPUnit\Framework\TestSuite {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage;
    use PHPUnit\TextUI\XmlConfiguration\Logging\Logging;
    use PHPUnit\Util\Xml\ValidationResult;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Configuration
    {
        /**
         * @var string
         */
        private $filename;

        /**
         * @var ValidationResult
         */
        private $validationResult;

        /**
         * @var ExtensionCollection
         */
        private $extensions;

        /**
         * @var CodeCoverage
         */
        private $codeCoverage;

        /**
         * @var Groups
         */
        private $groups;

        /**
         * @var Groups
         */
        private $testdoxGroups;

        /**
         * @var ExtensionCollection
         */
        private $listeners;

        /**
         * @var Logging
         */
        private $logging;

        /**
         * @var Php
         */
        private $php;

        /**
         * @var PHPUnit
         */
        private $phpunit;

        /**
         * @var TestSuiteCollection
         */
        private $testSuite;

        public function __construct(string $filename, \PHPUnit\Util\Xml\ValidationResult $validationResult, \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $extensions, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $codeCoverage, \PHPUnit\TextUI\XmlConfiguration\Groups $groups, \PHPUnit\TextUI\XmlConfiguration\Groups $testdoxGroups, \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $listeners, \PHPUnit\TextUI\XmlConfiguration\Logging\Logging $logging, \PHPUnit\TextUI\XmlConfiguration\Php $php, \PHPUnit\TextUI\XmlConfiguration\PHPUnit $phpunit, \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $testSuite) {}

        public function filename(): string {}

        public function hasValidationErrors(): bool {}

        public function validationErrors(): string {}

        public function extensions(): \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection {}

        public function codeCoverage(): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage {}

        public function groups(): \PHPUnit\TextUI\XmlConfiguration\Groups {}

        public function testdoxGroups(): \PHPUnit\TextUI\XmlConfiguration\Groups {}

        public function listeners(): \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection {}

        public function logging(): \PHPUnit\TextUI\XmlConfiguration\Logging\Logging {}

        public function php(): \PHPUnit\TextUI\XmlConfiguration\Php {}

        public function phpunit(): \PHPUnit\TextUI\XmlConfiguration\PHPUnit {}

        public function testSuite(): \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use str_replace;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Generator
    {
        /**
         * @var string
         */
        const TEMPLATE = '<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/{phpunit_version}/phpunit.xsd"
         bootstrap="{bootstrap_script}"
         cacheResultFile="{cache_directory}/test-results"
         executionOrder="depends,defects"
         forceCoversAnnotation="true"
         beStrictAboutCoversAnnotation="true"
         beStrictAboutOutputDuringTests="true"
         beStrictAboutTodoAnnotatedTests="true"
         failOnRisky="true"
         failOnWarning="true"
         verbose="true">
    <testsuites>
        <testsuite name="default">
            <directory suffix="Test.php">{tests_directory}</directory>
        </testsuite>
    </testsuites>

    <coverage cacheDirectory="{cache_directory}/code-coverage"
              processUncoveredFiles="true">
        <include>
            <directory suffix=".php">{src_directory}</directory>
        </include>
    </coverage>
</phpunit>
';

        public function generateDefaultConfiguration(string $phpunitVersion, string $bootstrapScript, string $testsDirectory, string $srcDirectory, string $cacheDirectory): string {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration
{
    use DIRECTORY_SEPARATOR;
    use PHP_VERSION;
    use assert;
    use defined;
    use dirname;
    use explode;
    use is_file;
    use is_numeric;
    use preg_match;
    use stream_resolve_include_path;
    use strlen;
    use strpos;
    use strtolower;
    use substr;
    use trim;
    use DOMDocument;
    use DOMElement;
    use DOMNodeList;
    use DOMXPath;
    use PHPUnit\Runner\TestSuiteSorter;
    use PHPUnit\Runner\Version;
    use PHPUnit\TextUI\DefaultResultPrinter;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory as FilterDirectory;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection as FilterDirectoryCollection;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html as CodeCoverageHtml;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php as CodeCoveragePhp;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text as CodeCoverageText;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml as CodeCoverageXml;
    use PHPUnit\TextUI\XmlConfiguration\Logging\Junit;
    use PHPUnit\TextUI\XmlConfiguration\Logging\Logging;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html as TestDoxHtml;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text as TestDoxText;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml as TestDoxXml;
    use PHPUnit\TextUI\XmlConfiguration\Logging\Text;
    use PHPUnit\TextUI\XmlConfiguration\TestSuite as TestSuiteConfiguration;
    use PHPUnit\Util\TestDox\CliTestDoxPrinter;
    use PHPUnit\Util\VersionComparisonOperator;
    use PHPUnit\Util\Xml;
    use PHPUnit\Util\Xml\Exception as XmlException;
    use PHPUnit\Util\Xml\Loader as XmlLoader;
    use PHPUnit\Util\Xml\SchemaFinder;
    use PHPUnit\Util\Xml\Validator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Loader
    {
        /**
         * @throws Exception
         */
        public function load(string $filename): \PHPUnit\TextUI\XmlConfiguration\Configuration {}

        public function logging(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\Logging\Logging {}

        public function legacyLogging(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\Logging\Logging {}

        private function extensions(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection {}

        private function getElementConfigurationParameters(string $filename, \DOMElement $element): \PHPUnit\TextUI\XmlConfiguration\Extension {}

        private function toAbsolutePath(string $filename, string $path, bool $useIncludePath = false): string {}

        private function getConfigurationArguments(string $filename, \DOMNodeList $nodes): array {}

        private function codeCoverage(string $filename, \DOMXPath $xpath, \DOMDocument $document): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage {}

        /**
         * @deprecated
         */
        private function legacyCodeCoverage(string $filename, \DOMXPath $xpath, \DOMDocument $document): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage {}

        /**
         * If $value is 'false' or 'true', this returns the value that $value represents.
         * Otherwise, returns $default, which may be a string in rare cases.
         *
         * @see \PHPUnit\TextUI\XmlConfigurationTest::testPHPConfigurationIsReadCorrectly
         *
         * @param bool|string $default
         *
         * @return bool|string
         */
        private function getBoolean(string $value, $default) {}

        private function readFilterDirectories(string $filename, \DOMXPath $xpath, string $query): \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection {}

        private function readFilterFiles(string $filename, \DOMXPath $xpath, string $query): \PHPUnit\TextUI\XmlConfiguration\FileCollection {}

        private function groups(\DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\Groups {}

        private function testdoxGroups(\DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\Groups {}

        private function parseGroupConfiguration(\DOMXPath $xpath, string $root): \PHPUnit\TextUI\XmlConfiguration\Groups {}

        private function listeners(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection {}

        private function getBooleanAttribute(\DOMElement $element, string $attribute, bool $default): bool {}

        private function getIntegerAttribute(\DOMElement $element, string $attribute, int $default): int {}

        private function getStringAttribute(\DOMElement $element, string $attribute): ?string {}

        private function getInteger(string $value, int $default): int {}

        private function php(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\Php {}

        private function phpunit(string $filename, \DOMDocument $document): \PHPUnit\TextUI\XmlConfiguration\PHPUnit {}

        private function getColors(\DOMDocument $document): string {}

        /**
         * @return int|string
         */
        private function getColumns(\DOMDocument $document) {}

        private function testSuite(string $filename, \DOMXPath $xpath): \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection {}

        /**
         * @return DOMElement[]
         */
        private function getTestSuiteElements(\DOMXPath $xpath): array {}

        private function element(\DOMXPath $xpath, string $element): ?\DOMElement {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Html
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Text
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Xml
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Junit
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging
{
    use PHPUnit\TextUI\XmlConfiguration\Exception;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html as TestDoxHtml;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text as TestDoxText;
    use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml as TestDoxXml;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Logging
    {
        /**
         * @var ?Junit
         */
        private $junit;

        /**
         * @var ?Text
         */
        private $text;

        /**
         * @var ?TeamCity
         */
        private $teamCity;

        /**
         * @var ?TestDoxHtml
         */
        private $testDoxHtml;

        /**
         * @var ?TestDoxText
         */
        private $testDoxText;

        /**
         * @var ?TestDoxXml
         */
        private $testDoxXml;

        public function __construct(?\PHPUnit\TextUI\XmlConfiguration\Logging\Junit $junit, ?\PHPUnit\TextUI\XmlConfiguration\Logging\Text $text, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity $teamCity, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html $testDoxHtml, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text $testDoxText, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml $testDoxXml) {}

        public function hasJunit(): bool {}

        public function junit(): \PHPUnit\TextUI\XmlConfiguration\Logging\Junit {}

        public function hasText(): bool {}

        public function text(): \PHPUnit\TextUI\XmlConfiguration\Logging\Text {}

        public function hasTeamCity(): bool {}

        public function teamCity(): \PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity {}

        public function hasTestDoxHtml(): bool {}

        public function testDoxHtml(): \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html {}

        public function hasTestDoxText(): bool {}

        public function testDoxText(): \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text {}

        public function hasTestDoxXml(): bool {}

        public function testDoxXml(): \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class TeamCity
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI\XmlConfiguration\Logging
{
    use PHPUnit\TextUI\XmlConfiguration\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class Text
    {
        /**
         * @var File
         */
        private $target;

        public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target) {}

        public function target(): \PHPUnit\TextUI\XmlConfiguration\File {}

    }
}

namespace PHPUnit\TextUI
{
    use PATH_SEPARATOR;
    use PHP_EOL;
    use STDIN;
    use array_keys;
    use assert;
    use class_exists;
    use copy;
    use extension_loaded;
    use fgets;
    use file_get_contents;
    use file_put_contents;
    use getcwd;
    use ini_get;
    use ini_set;
    use is_callable;
    use is_dir;
    use is_file;
    use is_string;
    use printf;
    use realpath;
    use sort;
    use sprintf;
    use stream_resolve_include_path;
    use strpos;
    use trim;
    use version_compare;
    use PharIo\Manifest\ApplicationName;
    use PharIo\Manifest\Exception as ManifestException;
    use PharIo\Manifest\ManifestLoader;
    use PharIo\Version\Version as PharIoVersion;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Runner\StandardTestSuiteLoader;
    use PHPUnit\Runner\TestSuiteLoader;
    use PHPUnit\Runner\Version;
    use PHPUnit\TextUI\CliArguments\Builder;
    use PHPUnit\TextUI\CliArguments\Configuration;
    use PHPUnit\TextUI\CliArguments\Exception as ArgumentsException;
    use PHPUnit\TextUI\CliArguments\Mapper;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper;
    use PHPUnit\TextUI\XmlConfiguration\Generator;
    use PHPUnit\TextUI\XmlConfiguration\Loader;
    use PHPUnit\TextUI\XmlConfiguration\Migrator;
    use PHPUnit\TextUI\XmlConfiguration\PhpHandler;
    use PHPUnit\TextUI\XmlConfiguration\TestSuiteMapper;
    use PHPUnit\Util\FileLoader;
    use PHPUnit\Util\Filesystem;
    use PHPUnit\Util\Printer;
    use PHPUnit\Util\TextTestListRenderer;
    use PHPUnit\Util\Xml\SchemaDetector;
    use PHPUnit\Util\XmlTestListRenderer;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\CacheWarmer;
    use SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
    use SebastianBergmann\Timer\Timer;
    use Throwable;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    class Command
    {
        /**
         * @var array<string,mixed>
         */
        protected $arguments = [/** value is missing */];

        /**
         * @var array<string,mixed>
         */
        protected $longOptions = [/** value is missing */];

        /**
         * @var bool
         */
        private $versionStringPrinted = false;

        /**
         * @psalm-var list<string>
         */
        private $warnings = [/** value is missing */];

        /**
         * @throws Exception
         */
        public static function main(bool $exit = true): int {}

        /**
         * @throws Exception
         */
        public function run(array $argv, bool $exit = true): int {}

        /**
         * Create a TestRunner, override in subclasses.
         */
        protected function createRunner(): \PHPUnit\TextUI\TestRunner {}

        /**
         * Handles the command-line arguments.
         *
         * A child class of PHPUnit\TextUI\Command can hook into the argument
         * parsing by adding the switch(es) to the $longOptions array and point to a
         * callback method that handles the switch(es) in the child class like this
         *
         * <code>
         * <?php
         * class MyCommand extends PHPUnit\TextUI\Command
         * {
         *     public function __construct()
         *     {
         *         // my-switch won't accept a value, it's an on/off
         *         $this->longOptions['my-switch'] = 'myHandler';
         *         // my-secondswitch will accept a value - note the equals sign
         *         $this->longOptions['my-secondswitch='] = 'myOtherHandler';
         *     }
         *
         *     // --my-switch  -> myHandler()
         *     protected function myHandler()
         *     {
         *     }
         *
         *     // --my-secondswitch foo -> myOtherHandler('foo')
         *     protected function myOtherHandler ($value)
         *     {
         *     }
         *
         *     // You will also need this - the static keyword in the
         *     // PHPUnit\TextUI\Command will mean that it'll be
         *     // PHPUnit\TextUI\Command that gets instantiated,
         *     // not MyCommand
         *     public static function main($exit = true)
         *     {
         *         $command = new static;
         *
         *         return $command->run($_SERVER['argv'], $exit);
         *     }
         *
         * }
         * </code>
         *
         * @throws Exception
         */
        protected function handleArguments(array $argv): \void {}

        /**
         * Handles the loading of the PHPUnit\Runner\TestSuiteLoader implementation.
         *
         * @deprecated see https://github.com/sebastianbergmann/phpunit/issues/4039
         */
        protected function handleLoader(string $loaderClass, string $loaderFile = ''): ?\PHPUnit\Runner\TestSuiteLoader {}

        /**
         * Handles the loading of the PHPUnit\Util\Printer implementation.
         *
         * @return null|Printer|string
         */
        protected function handlePrinter(string $printerClass, string $printerFile = '') {}

        /**
         * Loads a bootstrap file.
         */
        protected function handleBootstrap(string $filename): \void {}

        protected function handleVersionCheck(): \void {}

        /**
         * Show the help message.
         */
        protected function showHelp(): \void {}

        /**
         * Custom callback for test suite discovery.
         */
        protected function handleCustomTestSuite(): \void {}

        private function printVersionString(): \void {}

        private function exitWithErrorMessage(string $message): \void {}

        private function handleExtensions(string $directory): \void {}

        private function handleListGroups(\PHPUnit\Framework\TestSuite $suite, bool $exit): int {}

        /**
         * @throws \PHPUnit\Framework\Exception
         * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
         */
        private function handleListSuites(bool $exit): int {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function handleListTests(\PHPUnit\Framework\TestSuite $suite, bool $exit): int {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function handleListTestsXml(\PHPUnit\Framework\TestSuite $suite, string $target, bool $exit): int {}

        private function generateConfiguration(): \void {}

        private function migrateConfiguration(string $filename): \void {}

        private function handleCustomOptions(array $unrecognizedOptions): \void {}

        private function handleWarmCoverageCache(\PHPUnit\TextUI\XmlConfiguration\Configuration $configuration): \void {}

        private function configurationFileInDirectory(string $directory): ?string {}

    }
}

namespace PHPUnit\TextUI
{
    use PHP_EOL;
    use array_map;
    use array_reverse;
    use count;
    use floor;
    use implode;
    use in_array;
    use is_int;
    use max;
    use preg_split;
    use sprintf;
    use str_pad;
    use str_repeat;
    use strlen;
    use vsprintf;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\InvalidArgumentException;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestFailure;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\Util\Color;
    use PHPUnit\Util\Printer;
    use SebastianBergmann\Environment\Console;
    use SebastianBergmann\Timer\ResourceUsageFormatter;
    use SebastianBergmann\Timer\Timer;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class DefaultResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\TextUI\ResultPrinter
    {
        const EVENT_TEST_START = 0;

        const EVENT_TEST_END = 1;

        const EVENT_TESTSUITE_START = 2;

        const EVENT_TESTSUITE_END = 3;

        const COLOR_NEVER = 'never';

        const COLOR_AUTO = 'auto';

        const COLOR_ALWAYS = 'always';

        const COLOR_DEFAULT = 'never';

        const AVAILABLE_COLORS = [/** value is missing */];

        /**
         * @var int
         */
        protected $column = 0;

        /**
         * @var int
         */
        protected $maxColumn;

        /**
         * @var bool
         */
        protected $lastTestFailed = false;

        /**
         * @var int
         */
        protected $numAssertions = 0;

        /**
         * @var int
         */
        protected $numTests;

        /**
         * @var int
         */
        protected $numTestsRun = 0;

        /**
         * @var int
         */
        protected $numTestsWidth;

        /**
         * @var bool
         */
        protected $colors = false;

        /**
         * @var bool
         */
        protected $debug = false;

        /**
         * @var bool
         */
        protected $verbose = false;

        /**
         * @var int
         */
        private $numberOfColumns;

        /**
         * @var bool
         */
        private $reverse;

        /**
         * @var bool
         */
        private $defectListPrinted = false;

        /**
         * @var Timer
         */
        private $timer;

        /**
         * Constructor.
         *
         * @param null|resource|string $out
         * @param int|string           $numberOfColumns
         *
         * @throws Exception
         */
        public function __construct($out = null, bool $verbose = false, string $colors = self::COLOR_DEFAULT, bool $debug = false, $numberOfColumns = 80, bool $reverse = false) {}

        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * An error occurred.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A failure occurred.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * A warning occurred.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * Incomplete test.
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Risky test.
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Skipped test.
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A testsuite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A testsuite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test started.
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * A test ended.
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        protected function printDefects(array $defects, string $type): \void {}

        protected function printDefect(\PHPUnit\Framework\TestFailure $defect, int $count): \void {}

        protected function printDefectHeader(\PHPUnit\Framework\TestFailure $defect, int $count): \void {}

        protected function printDefectTrace(\PHPUnit\Framework\TestFailure $defect): \void {}

        protected function printErrors(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printFailures(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printWarnings(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printIncompletes(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printRisky(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printSkipped(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printHeader(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printFooter(\PHPUnit\Framework\TestResult $result): \void {}

        protected function writeProgress(string $progress): \void {}

        protected function writeNewLine(): \void {}

        /**
         * Formats a buffer with a specified ANSI color sequence if colors are
         * enabled.
         */
        protected function colorizeTextBox(string $color, string $buffer): string {}

        /**
         * Writes a buffer out with a color sequence if colors are enabled.
         */
        protected function writeWithColor(string $color, string $buffer, bool $lf = true): \void {}

        /**
         * Writes progress with a color sequence if colors are enabled.
         */
        protected function writeProgressWithColor(string $color, string $buffer): \void {}

        private function writeCountString(int $count, string $name, string $color, bool $always = false): \void {}

    }
}

namespace PHPUnit\TextUI
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\TextUI
{
    use PHP_EOL;
    use count;
    use explode;
    use max;
    use preg_replace_callback;
    use str_pad;
    use str_repeat;
    use strlen;
    use wordwrap;
    use PHPUnit\Util\Color;
    use SebastianBergmann\Environment\Console;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Help
    {
        const LEFT_MARGIN = '  ';

        const HELP_TEXT = [/** value is missing */];

        /**
         * @var int Number of columns required to write the longest option name to the console
         */
        private $maxArgLength = 0;

        /**
         * @var int Number of columns left for the description field after padding and option
         */
        private $maxDescLength;

        /**
         * @var bool Use color highlights for sections, options and parameters
         */
        private $hasColor = false;

        public function __construct(?int $width = null, ?bool $withColor = null) {}

        /**
         * Write the help file to the CLI, adapting width and colors to the console.
         */
        public function writeToConsole(): \void {}

        private function writePlaintext(): \void {}

        private function writeWithColor(): \void {}

    }
}

namespace PHPUnit\TextUI
{
    use PHPUnit\Framework\TestListener;
    use PHPUnit\Framework\TestResult;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    interface ResultPrinter extends \PHPUnit\Framework\TestListener
    {
        public function printResult(\PHPUnit\Framework\TestResult $result): \void;

        public function write(string $buffer): \void;

    }
}

namespace PHPUnit\TextUI
{
    use PHP_EOL;
    use PHP_SAPI;
    use PHP_VERSION;
    use array_diff;
    use array_map;
    use assert;
    use class_exists;
    use count;
    use dirname;
    use file_put_contents;
    use htmlspecialchars;
    use is_array;
    use is_int;
    use is_string;
    use mt_srand;
    use range;
    use realpath;
    use sprintf;
    use time;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Runner\AfterLastTestHook;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\Runner\BeforeFirstTestHook;
    use PHPUnit\Runner\DefaultTestResultCache;
    use PHPUnit\Runner\Filter\ExcludeGroupFilterIterator;
    use PHPUnit\Runner\Filter\Factory;
    use PHPUnit\Runner\Filter\IncludeGroupFilterIterator;
    use PHPUnit\Runner\Filter\NameFilterIterator;
    use PHPUnit\Runner\Hook;
    use PHPUnit\Runner\NullTestResultCache;
    use PHPUnit\Runner\ResultCacheExtension;
    use PHPUnit\Runner\StandardTestSuiteLoader;
    use PHPUnit\Runner\TestHook;
    use PHPUnit\Runner\TestListenerAdapter;
    use PHPUnit\Runner\TestSuiteLoader;
    use PHPUnit\Runner\TestSuiteSorter;
    use PHPUnit\Runner\Version;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper;
    use PHPUnit\TextUI\XmlConfiguration\Configuration;
    use PHPUnit\TextUI\XmlConfiguration\ExtensionHandler;
    use PHPUnit\TextUI\XmlConfiguration\Loader;
    use PHPUnit\TextUI\XmlConfiguration\PhpHandler;
    use PHPUnit\Util\Filesystem;
    use PHPUnit\Util\Log\JUnit;
    use PHPUnit\Util\Log\TeamCity;
    use PHPUnit\Util\Printer;
    use PHPUnit\Util\TestDox\CliTestDoxPrinter;
    use PHPUnit\Util\TestDox\HtmlResultPrinter;
    use PHPUnit\Util\TestDox\TextResultPrinter;
    use PHPUnit\Util\TestDox\XmlResultPrinter;
    use PHPUnit\Util\XdebugFilterScriptGenerator;
    use PHPUnit\Util\Xml\SchemaDetector;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Driver\Selector;
    use SebastianBergmann\CodeCoverage\Exception as CodeCoverageException;
    use SebastianBergmann\CodeCoverage\Filter as CodeCoverageFilter;
    use SebastianBergmann\CodeCoverage\Report\Clover as CloverReport;
    use SebastianBergmann\CodeCoverage\Report\Cobertura as CoberturaReport;
    use SebastianBergmann\CodeCoverage\Report\Crap4j as Crap4jReport;
    use SebastianBergmann\CodeCoverage\Report\Html\Facade as HtmlReport;
    use SebastianBergmann\CodeCoverage\Report\PHP as PhpReport;
    use SebastianBergmann\CodeCoverage\Report\Text as TextReport;
    use SebastianBergmann\CodeCoverage\Report\Xml\Facade as XmlReport;
    use SebastianBergmann\Comparator\Comparator;
    use SebastianBergmann\Environment\Runtime;
    use SebastianBergmann\Invoker\Invoker;
    use SebastianBergmann\Timer\Timer;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TestRunner extends \PHPUnit\Runner\BaseTestRunner
    {
        const SUCCESS_EXIT = 0;

        const FAILURE_EXIT = 1;

        const EXCEPTION_EXIT = 2;

        /**
         * @var bool
         */
        private static $versionStringPrinted = false;

        /**
         * @var CodeCoverageFilter
         */
        private $codeCoverageFilter;

        /**
         * @var TestSuiteLoader
         */
        private $loader;

        /**
         * @var ResultPrinter
         */
        private $printer;

        /**
         * @var bool
         */
        private $messagePrinted = false;

        /**
         * @var Hook[]
         */
        private $extensions = [/** value is missing */];

        /**
         * @var Timer
         */
        private $timer;

        public function __construct(?\PHPUnit\Runner\TestSuiteLoader $loader = null, ?\SebastianBergmann\CodeCoverage\Filter $filter = null) {}

        /**
         * @throws \PHPUnit\Runner\Exception
         * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
         * @throws Exception
         */
        public function run(\PHPUnit\Framework\TestSuite $suite, array $arguments = [/** value is missing */], array $warnings = [/** value is missing */], bool $exit = true): \PHPUnit\Framework\TestResult {}

        /**
         * Returns the loader to be used.
         */
        public function getLoader(): \PHPUnit\Runner\TestSuiteLoader {}

        public function addExtension(\PHPUnit\Runner\Hook $extension): \void {}

        /**
         * Override to define how to handle a failed loading of
         * a test suite.
         */
        protected function runFailed(string $message): \void {}

        private function createTestResult(): \PHPUnit\Framework\TestResult {}

        private function write(string $buffer): \void {}

        /**
         * @throws Exception
         * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
         */
        private function handleConfiguration(array &$arguments): \void {}

        private function processSuiteFilters(\PHPUnit\Framework\TestSuite $suite, array $arguments): \void {}

        private function writeMessage(string $type, string $message): \void {}

        private function createPrinter(string $class, array $arguments): \PHPUnit\TextUI\ResultPrinter {}

        private function codeCoverageGenerationStart(string $format): \void {}

        private function codeCoverageGenerationSucceeded(): \void {}

        private function codeCoverageGenerationFailed(\Exception $e): \void {}

    }
}

namespace PHPUnit\Util\Annotation
{
    use JSON_ERROR_NONE;
    use PREG_OFFSET_CAPTURE;
    use array_filter;
    use array_key_exists;
    use array_map;
    use array_merge;
    use array_pop;
    use array_slice;
    use array_values;
    use count;
    use explode;
    use file;
    use implode;
    use is_array;
    use is_int;
    use json_decode;
    use json_last_error;
    use json_last_error_msg;
    use preg_match;
    use preg_match_all;
    use preg_replace;
    use preg_split;
    use realpath;
    use rtrim;
    use sprintf;
    use str_replace;
    use strlen;
    use strpos;
    use strtolower;
    use substr;
    use trim;
    use PharIo\Version\VersionConstraintParser;
    use PHPUnit\Framework\InvalidDataProviderException;
    use PHPUnit\Framework\SkippedTestError;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Util\Exception;
    use PHPUnit\Util\InvalidDataSetException;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionFunctionAbstract;
    use ReflectionMethod;
    use Reflector;
    use Traversable;

    /**
     * This is an abstraction around a PHPUnit-specific docBlock,
     * allowing us to ask meaningful questions about a specific
     * reflection symbol.
     *
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class DocBlock
    {
        /**
         * @todo This constant should be private (it's public because of TestTest::testGetProvidedDataRegEx)
         */
        const REGEX_DATA_PROVIDER = '/@dataProvider\s+([a-zA-Z0-9._:-\\x7f-\xff]+)/';

        const REGEX_REQUIRES_VERSION = '/@requires\s+(?P<name>PHP(?:Unit)?)\s+(?P<operator>[<>=!]{0,2})\s*(?P<version>[\d\.-]+(dev|(RC|alpha|beta)[\d\.])?)[ \t]*\r?$/m';

        const REGEX_REQUIRES_VERSION_CONSTRAINT = '/@requires\s+(?P<name>PHP(?:Unit)?)\s+(?P<constraint>[\d\t \-.|~^]+)[ \t]*\r?$/m';

        const REGEX_REQUIRES_OS = '/@requires\s+(?P<name>OS(?:FAMILY)?)\s+(?P<value>.+?)[ \t]*\r?$/m';

        const REGEX_REQUIRES_SETTING = '/@requires\s+(?P<name>setting)\s+(?P<setting>([^ ]+?))\s*(?P<value>[\w\.-]+[\w\.]?)?[ \t]*\r?$/m';

        const REGEX_REQUIRES = '/@requires\s+(?P<name>function|extension)\s+(?P<value>([^\s<>=!]+))\s*(?P<operator>[<>=!]{0,2})\s*(?P<version>[\d\.-]+[\d\.]?)?[ \t]*\r?$/m';

        const REGEX_TEST_WITH = '/@testWith\s+/';

        /** @var string */
        private $docComment;

        /** @var bool */
        private $isMethod;

        /** @var array<string, array<int, string>> pre-parsed annotations indexed by name and occurrence index */
        private $symbolAnnotations;

        /**
         * @var null|array<string, mixed>
         *
         * @psalm-var null|(array{
         *   __OFFSET: array<string, int>&array{__FILE: string},
         *   setting?: array<string, string>,
         *   extension_versions?: array<string, array{version: string, operator: string}>
         * }&array<
         *   string,
         *   string|array{version: string, operator: string}|array{constraint: string}|array<int|string, string>
         * >)
         */
        private $parsedRequirements;

        /** @var int */
        private $startLine;

        /** @var int */
        private $endLine;

        /** @var string */
        private $fileName;

        /** @var string */
        private $name;

        /**
         * @var string
         *
         * @psalm-var class-string
         */
        private $className;

        public static function ofClass(\ReflectionClass $class): self {}

        /**
         * @psalm-param class-string $classNameInHierarchy
         */
        public static function ofMethod(\ReflectionMethod $method, string $classNameInHierarchy): self {}

        /**
         * Note: we do not preserve an instance of the reflection object, since it cannot be safely (de-)serialized.
         *
         * @param array<string, array<int, string>> $symbolAnnotations
         *
         * @psalm-param class-string $className
         */
        private function __construct(string $docComment, bool $isMethod, array $symbolAnnotations, int $startLine, int $endLine, string $fileName, string $name, string $className) {}

        /**
         * @psalm-return array{
         *   __OFFSET: array<string, int>&array{__FILE: string},
         *   setting?: array<string, string>,
         *   extension_versions?: array<string, array{version: string, operator: string}>
         * }&array<
         *   string,
         *   string|array{version: string, operator: string}|array{constraint: string}|array<int|string, string>
         * >
         *
         * @throws Warning if the requirements version constraint is not well-formed
         */
        public function requirements(): array {}

        /**
         * Returns the provided data for a method.
         *
         * @throws Exception
         */
        public function getProvidedData(): ?array {}

        /**
         * @psalm-return array<string, array{line: int, value: string}>
         */
        public function getInlineAnnotations(): array {}

        public function symbolAnnotations(): array {}

        public function isHookToBeExecutedBeforeClass(): bool {}

        public function isHookToBeExecutedAfterClass(): bool {}

        public function isToBeExecutedBeforeTest(): bool {}

        public function isToBeExecutedAfterTest(): bool {}

        public function isToBeExecutedAsPreCondition(): bool {}

        public function isToBeExecutedAsPostCondition(): bool {}

        private function getDataFromDataProviderAnnotation(string $docComment): ?array {}

        /**
         * @throws Exception
         */
        private function getDataFromTestWithAnnotation(string $docComment): ?array {}

        private function cleanUpMultiLineAnnotation(string $docComment): string {}

        /** @return array<string, array<int, string>> */
        private static function parseDocBlock(string $docBlock): array {}

        /** @param ReflectionClass|ReflectionFunctionAbstract $reflector */
        private static function extractAnnotationsFromReflector(\Reflector $reflector): array {}

    }
}

namespace PHPUnit\Util\Annotation
{
    use array_key_exists;
    use PHPUnit\Util\Exception;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionMethod;

    /**
     * Reflection information, and therefore DocBlock information, is static within
     * a single PHP process. It is therefore okay to use a Singleton registry here.
     *
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Registry
    {
        /** @var null|self */
        private static $instance;

        /** @var array<string, DocBlock> indexed by class name */
        private $classDocBlocks = [/** value is missing */];

        /** @var array<string, array<string, DocBlock>> indexed by class name and method name */
        private $methodDocBlocks = [/** value is missing */];

        public static function getInstance(): self {}

        private function __construct() {}

        /**
         * @throws Exception
         * @psalm-param class-string $class
         */
        public function forClassName(string $class): \PHPUnit\Util\Annotation\DocBlock {}

        /**
         * @throws Exception
         * @psalm-param class-string $classInHierarchy
         */
        public function forMethod(string $classInHierarchy, string $method): \PHPUnit\Util\Annotation\DocBlock {}

    }
}

namespace PHPUnit\Util\Log
{
    use class_exists;
    use get_class;
    use method_exists;
    use sprintf;
    use str_replace;
    use trim;
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\ExceptionWrapper;
    use PHPUnit\Framework\SelfDescribing;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestFailure;
    use PHPUnit\Framework\TestListener;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Util\Exception;
    use PHPUnit\Util\Filter;
    use PHPUnit\Util\Printer;
    use PHPUnit\Util\Xml;
    use ReflectionClass;
    use ReflectionException;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class JUnit extends \PHPUnit\Util\Printer implements \PHPUnit\Framework\TestListener
    {
        /**
         * @var DOMDocument
         */
        private $document;

        /**
         * @var DOMElement
         */
        private $root;

        /**
         * @var bool
         */
        private $reportRiskyTests = false;

        /**
         * @var DOMElement[]
         */
        private $testSuites = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteTests = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteAssertions = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteErrors = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteWarnings = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteFailures = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteSkipped = [/** value is missing */];

        /**
         * @var int[]
         */
        private $testSuiteTimes = [/** value is missing */];

        /**
         * @var int
         */
        private $testSuiteLevel = 0;

        /**
         * @var DOMElement
         */
        private $currentTestCase;

        /**
         * @param null|mixed $out
         */
        public function __construct($out = null, bool $reportRiskyTests = false) {}

        /**
         * Flush buffer and close output.
         */
        public function flush(): \void {}

        /**
         * An error occurred.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A warning occurred.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * A failure occurred.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * Incomplete test.
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Risky test.
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Skipped test.
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A testsuite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A testsuite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test started.
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * A test ended.
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        /**
         * Returns the XML as a string.
         */
        public function getXML(): string {}

        private function doAddFault(\PHPUnit\Framework\Test $test, \Throwable $t, string $type): \void {}

        private function doAddSkipped(): \void {}

    }
}

namespace PHPUnit\Util\Log
{
    use class_exists;
    use count;
    use explode;
    use get_class;
    use getmypid;
    use ini_get;
    use is_bool;
    use is_scalar;
    use method_exists;
    use print_r;
    use round;
    use str_replace;
    use stripos;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\ExceptionWrapper;
    use PHPUnit\Framework\ExpectationFailedException;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestFailure;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\TextUI\DefaultResultPrinter;
    use PHPUnit\Util\Exception;
    use PHPUnit\Util\Filter;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\Comparator\ComparisonFailure;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TeamCity extends \PHPUnit\TextUI\DefaultResultPrinter
    {
        /**
         * @var bool
         */
        private $isSummaryTestCountPrinted = false;

        /**
         * @var string
         */
        private $startedTestName;

        /**
         * @var false|int
         */
        private $flowId;

        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * An error occurred.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A warning occurred.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * A failure occurred.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * Incomplete test.
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Risky test.
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Skipped test.
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function printIgnoredTest(string $testName, \Throwable $t, float $time): \void {}

        /**
         * A testsuite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A testsuite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test started.
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * A test ended.
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        protected function writeProgress(string $progress): \void {}

        private function printEvent(string $eventName, array $params = [/** value is missing */]): \void {}

        private static function getMessage(\Throwable $t): string {}

        private static function getDetails(\Throwable $t): string {}

        private static function getPrimitiveValueAsString($value): ?string {}

        private static function escapeValue(string $text): string {}

        /**
         * @param string $className
         */
        private static function getFileName($className): string {}

        /**
         * @param float $time microseconds
         */
        private static function toMilliseconds(float $time): int {}

    }
}

namespace PHPUnit\Util\PHP
{
    use DIRECTORY_SEPARATOR;
    use PHP_SAPI;
    use array_keys;
    use array_merge;
    use assert;
    use escapeshellarg;
    use ini_get_all;
    use restore_error_handler;
    use set_error_handler;
    use sprintf;
    use str_replace;
    use strpos;
    use strrpos;
    use substr;
    use trim;
    use unserialize;
    use __PHP_Incomplete_Class;
    use ErrorException;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\SyntheticError;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestFailure;
    use PHPUnit\Framework\TestResult;
    use SebastianBergmann\Environment\Runtime;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class AbstractPhpProcess
    {
        /**
         * @var Runtime
         */
        protected $runtime;

        /**
         * @var bool
         */
        protected $stderrRedirection = false;

        /**
         * @var string
         */
        protected $stdin = '';

        /**
         * @var string
         */
        protected $args = '';

        /**
         * @var array<string, string>
         */
        protected $env = [/** value is missing */];

        /**
         * @var int
         */
        protected $timeout = 0;

        public static function factory(): self {}

        public function __construct() {}

        /**
         * Defines if should use STDERR redirection or not.
         *
         * Then $stderrRedirection is TRUE, STDERR is redirected to STDOUT.
         */
        public function setUseStderrRedirection(bool $stderrRedirection): \void {}

        /**
         * Returns TRUE if uses STDERR redirection or FALSE if not.
         */
        public function useStderrRedirection(): bool {}

        /**
         * Sets the input string to be sent via STDIN.
         */
        public function setStdin(string $stdin): \void {}

        /**
         * Returns the input string to be sent via STDIN.
         */
        public function getStdin(): string {}

        /**
         * Sets the string of arguments to pass to the php job.
         */
        public function setArgs(string $args): \void {}

        /**
         * Returns the string of arguments to pass to the php job.
         */
        public function getArgs(): string {}

        /**
         * Sets the array of environment variables to start the child process with.
         *
         * @param array<string, string> $env
         */
        public function setEnv(array $env): \void {}

        /**
         * Returns the array of environment variables to start the child process with.
         */
        public function getEnv(): array {}

        /**
         * Sets the amount of seconds to wait before timing out.
         */
        public function setTimeout(int $timeout): \void {}

        /**
         * Returns the amount of seconds to wait before timing out.
         */
        public function getTimeout(): int {}

        /**
         * Runs a single test in a separate PHP process.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function runTestJob(string $job, \PHPUnit\Framework\Test $test, \PHPUnit\Framework\TestResult $result): \void {}

        /**
         * Returns the command based into the configurations.
         */
        public function getCommand(array $settings, ?string $file = null): string {}

        /**
         * Runs a single job (PHP code) using a separate PHP process.
         */
        abstract public function runJob(string $job, array $settings = [/** value is missing */]): array;

        protected function settingsToParameters(array $settings): string {}

        /**
         * Processes the TestResult object from an isolated process.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function processChildResult(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\TestResult $result, string $stdout, string $stderr): \void {}

        /**
         * Gets the thrown exception from a PHPUnit\Framework\TestFailure.
         *
         * @see https://github.com/sebastianbergmann/phpunit/issues/74
         */
        private function getException(\PHPUnit\Framework\TestFailure $error): \PHPUnit\Framework\Exception {}

    }
}

namespace PHPUnit\Util\PHP
{
    use array_merge;
    use fclose;
    use file_put_contents;
    use fread;
    use fwrite;
    use is_array;
    use is_resource;
    use proc_close;
    use proc_open;
    use proc_terminate;
    use rewind;
    use sprintf;
    use stream_get_contents;
    use stream_select;
    use sys_get_temp_dir;
    use tempnam;
    use unlink;
    use PHPUnit\Framework\Exception;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class DefaultPhpProcess extends \PHPUnit\Util\PHP\AbstractPhpProcess
    {
        /**
         * @var string
         */
        protected $tempFile;

        /**
         * Runs a single job (PHP code) using a separate PHP process.
         *
         * @throws Exception
         */
        public function runJob(string $job, array $settings = [/** value is missing */]): array {}

        /**
         * Returns an array of file handles to be used in place of pipes.
         */
        protected function getHandles(): array {}

        /**
         * Handles creating the child process and returning the STDOUT and STDERR.
         *
         * @throws Exception
         */
        protected function runProcess(string $job, array $settings): array {}

        /**
         * @param resource $pipe
         */
        protected function process($pipe, string $job): \void {}

        protected function cleanup(): \void {}

        protected function useTemporaryFile(): bool {}

    }
}

namespace PHPUnit\Util\PHP
{
    use PHP_MAJOR_VERSION;
    use tmpfile;
    use PHPUnit\Framework\Exception;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @see https://bugs.php.net/bug.php?id=51800
     */
    final class WindowsPhpProcess extends \PHPUnit\Util\PHP\DefaultPhpProcess
    {
        public function getCommand(array $settings, ?string $file = null): string {}

        /**
         * @throws Exception
         */
        protected function getHandles(): array {}

        protected function useTemporaryFile(): bool {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use PHP_EOL;
    use array_map;
    use ceil;
    use count;
    use explode;
    use get_class;
    use implode;
    use preg_match;
    use sprintf;
    use strlen;
    use strpos;
    use trim;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\Util\Color;
    use SebastianBergmann\Timer\ResourceUsageFormatter;
    use SebastianBergmann\Timer\Timer;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class CliTestDoxPrinter extends \PHPUnit\Util\TestDox\TestDoxPrinter
    {
        /**
         * The default Testdox left margin for messages is a vertical line.
         */
        const PREFIX_SIMPLE = [/** value is missing */];

        /**
         * Colored Testdox use box-drawing for a more textured map of the message.
         */
        const PREFIX_DECORATED = [/** value is missing */];

        const SPINNER_ICONS = [/** value is missing */];

        const STATUS_STYLES = [/** value is missing */];

        /**
         * @var int[]
         */
        private $nonSuccessfulTestResults = [/** value is missing */];

        /**
         * @var Timer
         */
        private $timer;

        /**
         * @param null|resource|string $out
         * @param int|string           $numberOfColumns
         *
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct($out = null, bool $verbose = false, string $colors = self::COLOR_DEFAULT, bool $debug = false, $numberOfColumns = 80, bool $reverse = false) {}

        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        protected function printHeader(\PHPUnit\Framework\TestResult $result): \void {}

        protected function formatClassName(\PHPUnit\Framework\Test $test): string {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function registerTestResult(\PHPUnit\Framework\Test $test, ?\Throwable $t, int $status, float $time, bool $verbose): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function formatTestName(\PHPUnit\Framework\Test $test): string {}

        protected function writeTestResult(array $prevResult, array $result): \void {}

        protected function formatThrowable(\Throwable $t, ?int $status = null): string {}

        protected function colorizeMessageAndDiff(string $style, string $buffer): array {}

        protected function formatStacktrace(\Throwable $t): string {}

        protected function formatTestResultMessage(\Throwable $t, array $result, ?string $prefix = null): string {}

        protected function drawSpinner(): \void {}

        protected function undrawSpinner(): \void {}

        private function formatRuntime(float $time, string $color = ''): string {}

        private function printNonSuccessfulTestsSummary(int $numberOfExecutedTests): \void {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use sprintf;
    use PHPUnit\Framework\TestResult;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class HtmlResultPrinter extends \PHPUnit\Util\TestDox\ResultPrinter
    {
        /**
         * @var string
         */
        const PAGE_HEADER = '<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Test Documentation</title>
        <style>
            body {
                text-rendering: optimizeLegibility;
                font-variant-ligatures: common-ligatures;
                font-kerning: normal;
                margin-left: 2em;
            }

            body > ul > li {
                font-family: Source Serif Pro, PT Sans, Trebuchet MS, Helvetica, Arial;
                font-size: 2em;
            }

            h2 {
                font-family: Tahoma, Helvetica, Arial;
                font-size: 3em;
            }

            ul {
                list-style: none;
                margin-bottom: 1em;
            }
        </style>
    </head>
    <body>';

        /**
         * @var string
         */
        const CLASS_HEADER = '
        <h2 id="%s">%s</h2>
        <ul>
';

        /**
         * @var string
         */
        const CLASS_FOOTER = '        </ul>';

        /**
         * @var string
         */
        const PAGE_FOOTER = '
    </body>
</html>';

        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * Handler for 'start run' event.
         */
        protected function startRun(): \void {}

        /**
         * Handler for 'start class' event.
         */
        protected function startClass(string $name): \void {}

        /**
         * Handler for 'on test' event.
         */
        protected function onTest(string $name, bool $success = true): \void {}

        /**
         * Handler for 'end class' event.
         */
        protected function endClass(string $name): \void {}

        /**
         * Handler for 'end run' event.
         */
        protected function endRun(): \void {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use array_key_exists;
    use array_keys;
    use array_map;
    use array_pop;
    use array_values;
    use explode;
    use get_class;
    use gettype;
    use implode;
    use in_array;
    use is_bool;
    use is_float;
    use is_int;
    use is_numeric;
    use is_object;
    use is_scalar;
    use is_string;
    use mb_strtolower;
    use ord;
    use preg_quote;
    use preg_replace;
    use range;
    use sprintf;
    use str_replace;
    use strlen;
    use strpos;
    use strtolower;
    use strtoupper;
    use substr;
    use trim;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Util\Color;
    use PHPUnit\Util\Exception as UtilException;
    use PHPUnit\Util\Test;
    use ReflectionException;
    use ReflectionMethod;
    use ReflectionObject;
    use SebastianBergmann\Exporter\Exporter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class NamePrettifier
    {
        /**
         * @var string[]
         */
        private $strings = [/** value is missing */];

        /**
         * @var bool
         */
        private $useColor;

        public function __construct(bool $useColor = false) {}

        /**
         * Prettifies the name of a test class.
         *
         * @psalm-param class-string $className
         */
        public function prettifyTestClass(string $className): string {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function prettifyTestCase(\PHPUnit\Framework\TestCase $test): string {}

        public function prettifyDataSet(\PHPUnit\Framework\TestCase $test): string {}

        /**
         * Prettifies the name of a test method.
         */
        public function prettifyTestMethod(string $name): string {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        private function mapTestMethodParameterNamesToProvidedDataValues(\PHPUnit\Framework\TestCase $test): array {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use get_class;
    use in_array;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Framework\WarningTestCase;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\TextUI\ResultPrinter as ResultPrinterInterface;
    use PHPUnit\Util\Printer;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    abstract class ResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\TextUI\ResultPrinter
    {
        /**
         * @var NamePrettifier
         */
        protected $prettifier;

        /**
         * @var string
         */
        protected $testClass = '';

        /**
         * @var int
         */
        protected $testStatus;

        /**
         * @var array
         */
        protected $tests = [/** value is missing */];

        /**
         * @var int
         */
        protected $successful = 0;

        /**
         * @var int
         */
        protected $warned = 0;

        /**
         * @var int
         */
        protected $failed = 0;

        /**
         * @var int
         */
        protected $risky = 0;

        /**
         * @var int
         */
        protected $skipped = 0;

        /**
         * @var int
         */
        protected $incomplete = 0;

        /**
         * @var null|string
         */
        protected $currentTestClassPrettified;

        /**
         * @var null|string
         */
        protected $currentTestMethodPrettified;

        /**
         * @var array
         */
        private $groups;

        /**
         * @var array
         */
        private $excludeGroups;

        /**
         * @param resource $out
         *
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct($out = null, array $groups = [/** value is missing */], array $excludeGroups = [/** value is missing */]) {}

        /**
         * Flush buffer and close output.
         */
        public function flush(): \void {}

        /**
         * An error occurred.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A warning occurred.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * A failure occurred.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * Incomplete test.
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Risky test.
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Skipped test.
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A testsuite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A testsuite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test started.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * A test ended.
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        protected function doEndClass(): \void {}

        /**
         * Handler for 'start run' event.
         */
        protected function startRun(): \void {}

        /**
         * Handler for 'start class' event.
         */
        protected function startClass(string $name): \void {}

        /**
         * Handler for 'on test' event.
         */
        protected function onTest(string $name, bool $success = true): \void {}

        /**
         * Handler for 'end class' event.
         */
        protected function endClass(string $name): \void {}

        /**
         * Handler for 'end run' event.
         */
        protected function endRun(): \void {}

        private function isOfInterest(\PHPUnit\Framework\Test $test): bool {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use PHP_EOL;
    use array_map;
    use get_class;
    use implode;
    use method_exists;
    use preg_split;
    use trim;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Reorderable;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestResult;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Runner\BaseTestRunner;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\TextUI\DefaultResultPrinter;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class TestDoxPrinter extends \PHPUnit\TextUI\DefaultResultPrinter
    {
        /**
         * @var NamePrettifier
         */
        protected $prettifier;

        /**
         * @var int The number of test results received from the TestRunner
         */
        protected $testIndex = 0;

        /**
         * @var int The number of test results already sent to the output
         */
        protected $testFlushIndex = 0;

        /**
         * @var array<int, array> Buffer for test results
         */
        protected $testResults = [/** value is missing */];

        /**
         * @var array<string, int> Lookup table for testname to testResults[index]
         */
        protected $testNameResultIndex = [/** value is missing */];

        /**
         * @var bool
         */
        protected $enableOutputBuffer = false;

        /**
         * @var array array<string>
         */
        protected $originalExecutionOrder = [/** value is missing */];

        /**
         * @var int
         */
        protected $spinState = 0;

        /**
         * @var bool
         */
        protected $showProgress = true;

        /**
         * @param null|resource|string $out
         * @param int|string           $numberOfColumns
         *
         * @throws \PHPUnit\Framework\Exception
         */
        public function __construct($out = null, bool $verbose = false, string $colors = self::COLOR_DEFAULT, bool $debug = false, $numberOfColumns = 80, bool $reverse = false) {}

        public function setOriginalExecutionOrder(array $order): \void {}

        public function setShowProgressAnimation(bool $showProgress): \void {}

        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        public function writeProgress(string $progress): \void {}

        public function flush(): \void {}

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        protected function registerTestResult(\PHPUnit\Framework\Test $test, ?\Throwable $t, int $status, float $time, bool $verbose): \void {}

        protected function formatTestName(\PHPUnit\Framework\Test $test): string {}

        protected function formatClassName(\PHPUnit\Framework\Test $test): string {}

        protected function testHasPassed(): bool {}

        protected function flushOutputBuffer(bool $forceFlush = false): \void {}

        protected function showSpinner(): \void {}

        protected function hideSpinner(): \void {}

        protected function drawSpinner(): \void {}

        protected function undrawSpinner(): \void {}

        protected function writeTestResult(array $prevResult, array $result): \void {}

        protected function getEmptyTestResult(): array {}

        protected function getTestResultByName(?string $testName): array {}

        protected function formatThrowable(\Throwable $t, ?int $status = null): string {}

        protected function formatStacktrace(\Throwable $t): string {}

        protected function formatTestResultMessage(\Throwable $t, array $result, string $prefix = '│'): string {}

        protected function prefixLines(string $prefix, string $message): string {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use PHPUnit\Framework\TestResult;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TextResultPrinter extends \PHPUnit\Util\TestDox\ResultPrinter
    {
        public function printResult(\PHPUnit\Framework\TestResult $result): \void {}

        /**
         * Handler for 'start class' event.
         */
        protected function startClass(string $name): \void {}

        /**
         * Handler for 'on test' event.
         */
        protected function onTest(string $name, bool $success = true): \void {}

        /**
         * Handler for 'end class' event.
         */
        protected function endClass(string $name): \void {}

    }
}

namespace PHPUnit\Util\TestDox
{
    use array_filter;
    use get_class;
    use implode;
    use strpos;
    use DOMDocument;
    use DOMElement;
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\Test;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestListener;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Util\Printer;
    use ReflectionClass;
    use ReflectionException;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class XmlResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\Framework\TestListener
    {
        /**
         * @var DOMDocument
         */
        private $document;

        /**
         * @var DOMElement
         */
        private $root;

        /**
         * @var NamePrettifier
         */
        private $prettifier;

        /**
         * @var null|Throwable
         */
        private $exception;

        /**
         * @param resource|string $out
         *
         * @throws Exception
         */
        public function __construct($out = null) {}

        /**
         * Flush buffer and close output.
         */
        public function flush(): \void {}

        /**
         * An error occurred.
         */
        public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A warning occurred.
         */
        public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time): \void {}

        /**
         * A failure occurred.
         */
        public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time): \void {}

        /**
         * Incomplete test.
         */
        public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Risky test.
         */
        public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * Skipped test.
         */
        public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time): \void {}

        /**
         * A test suite started.
         */
        public function startTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test suite ended.
         */
        public function endTestSuite(\PHPUnit\Framework\TestSuite $suite): \void {}

        /**
         * A test started.
         */
        public function startTest(\PHPUnit\Framework\Test $test): \void {}

        /**
         * A test ended.
         *
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function endTest(\PHPUnit\Framework\Test $test, float $time): \void {}

    }
}

namespace PHPUnit\Util\Xml
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\Util\Xml
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @psalm-immutable
     */
    final class FailedSchemaDetectionResult extends \PHPUnit\Util\Xml\SchemaDetectionResult
    {
    }
}

namespace PHPUnit\Util\Xml
{
    use chdir;
    use dirname;
    use error_reporting;
    use file_get_contents;
    use getcwd;
    use libxml_get_errors;
    use libxml_use_internal_errors;
    use sprintf;
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Loader
    {
        /**
         * @throws Exception
         */
        public function loadFile(string $filename, bool $isHtml = false, bool $xinclude = false, bool $strict = false): \DOMDocument {}

        /**
         * @throws Exception
         */
        public function load(string $actual, bool $isHtml = false, string $filename = '', bool $xinclude = false, bool $strict = false): \DOMDocument {}

    }
}

namespace PHPUnit\Util\Xml
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @psalm-immutable
     */
    abstract class SchemaDetectionResult
    {
        public function detected(): bool {}

        /**
         * @throws Exception
         */
        public function version(): string {}

    }
}

namespace PHPUnit\Util\Xml
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SchemaDetector
    {
        /**
         * @throws Exception
         */
        public function detect(string $filename): \PHPUnit\Util\Xml\SchemaDetectionResult {}

    }
}

namespace PHPUnit\Util\Xml
{
    use defined;
    use is_file;
    use sprintf;
    use PHPUnit\Runner\Version;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SchemaFinder
    {
        /**
         * @throws Exception
         */
        public function find(string $version): string {}

        private function path(): string {}

    }
}

namespace PHPUnit\Util\Xml
{
    use ArrayIterator;
    use Countable;
    use DOMNode;
    use DOMNodeList;
    use IteratorAggregate;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class SnapshotNodeList
    {
        /**
         * @var DOMNode[]
         */
        private $nodes = [/** value is missing */];

        public static function fromNodeList(\DOMNodeList $list): self {}

        public function count(): int {}

        public function getIterator(): \ArrayIterator {}

    }
}

namespace PHPUnit\Util\Xml
{

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @psalm-immutable
     */
    final class SuccessfulSchemaDetectionResult extends \PHPUnit\Util\Xml\SchemaDetectionResult
    {
        /**
         * @var string
         */
        private $version;

        public function __construct(string $version) {}

        public function detected(): bool {}

        public function version(): string {}

    }
}

namespace PHPUnit\Util\Xml
{
    use sprintf;
    use trim;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @psalm-immutable
     */
    final class ValidationResult
    {
        /**
         * @psalm-var array<int,list<string>>
         */
        private $validationErrors = [/** value is missing */];

        /**
         * @psalm-param array<int,\LibXMLError> $errors
         */
        public static function fromArray(array $errors): self {}

        private function __construct(array $validationErrors) {}

        public function hasValidationErrors(): bool {}

        public function asString(): string {}

    }
}

namespace PHPUnit\Util\Xml
{
    use libxml_clear_errors;
    use libxml_get_errors;
    use libxml_use_internal_errors;
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Validator
    {
        public function validate(\DOMDocument $document, string $xsdFilename): \PHPUnit\Util\Xml\ValidationResult {}

    }
}

namespace PHPUnit\Util
{

    /**
     * @deprecated Use ExcludeList instead
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class Blacklist
    {
        public static function addDirectory(string $directory): \void {}

        /**
         * @throws Exception
         *
         * @return string[]
         */
        public function getBlacklistedDirectories(): array {}

        /**
         * @throws Exception
         */
        public function isBlacklisted(string $file): bool {}

    }
}

namespace PHPUnit\Util
{
    use DIRECTORY_SEPARATOR;
    use array_keys;
    use array_map;
    use array_values;
    use count;
    use explode;
    use implode;
    use min;
    use preg_replace;
    use preg_replace_callback;
    use sprintf;
    use strtr;
    use trim;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Color
    {
        /**
         * @var array<string,string>
         */
        const WHITESPACE_MAP = [/** value is missing */];

        /**
         * @var array<string,string>
         */
        const WHITESPACE_EOL_MAP = [/** value is missing */];

        /**
         * @var array<string,string>
         */
        private static $ansiCodes = [/** value is missing */];

        public static function colorize(string $color, string $buffer): string {}

        public static function colorizePath(string $path, ?string $prevPath = null, bool $colorizeFilename = false): string {}

        public static function dim(string $buffer): string {}

        public static function visualizeWhitespace(string $buffer, bool $visualizeEOL = false): string {}

        private static function optimizeColor(string $buffer): string {}

    }
}

namespace PHPUnit\Util
{
    use E_DEPRECATED;
    use E_NOTICE;
    use E_STRICT;
    use E_USER_DEPRECATED;
    use E_USER_NOTICE;
    use E_USER_WARNING;
    use E_WARNING;
    use error_reporting;
    use restore_error_handler;
    use set_error_handler;
    use PHPUnit\Framework\Error\Deprecated;
    use PHPUnit\Framework\Error\Error;
    use PHPUnit\Framework\Error\Notice;
    use PHPUnit\Framework\Error\Warning;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class ErrorHandler
    {
        /**
         * @var bool
         */
        private $convertDeprecationsToExceptions;

        /**
         * @var bool
         */
        private $convertErrorsToExceptions;

        /**
         * @var bool
         */
        private $convertNoticesToExceptions;

        /**
         * @var bool
         */
        private $convertWarningsToExceptions;

        /**
         * @var bool
         */
        private $registered = false;

        public static function invokeIgnoringWarnings(callable $callable) {}

        public function __construct(bool $convertDeprecationsToExceptions, bool $convertErrorsToExceptions, bool $convertNoticesToExceptions, bool $convertWarningsToExceptions) {}

        public function __invoke(int $errorNumber, string $errorString, string $errorFile, int $errorLine): bool {}

        public function register(): \void {}

        public function unregister(): \void {}

    }
}

namespace PHPUnit\Util
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Exception extends \RuntimeException
    {
    }
}

namespace PHPUnit\Util
{
    use DIRECTORY_SEPARATOR;
    use class_exists;
    use defined;
    use dirname;
    use is_dir;
    use realpath;
    use sprintf;
    use strpos;
    use sys_get_temp_dir;
    use Composer\Autoload\ClassLoader;
    use DeepCopy\DeepCopy;
    use Doctrine\Instantiator\Instantiator;
    use PharIo\Manifest\Manifest;
    use PharIo\Version\Version as PharIoVersion;
    use phpDocumentor\Reflection\DocBlock;
    use phpDocumentor\Reflection\Project;
    use phpDocumentor\Reflection\Type;
    use PhpParser\Parser;
    use PHPUnit\Framework\TestCase;
    use Prophecy\Prophet;
    use ReflectionClass;
    use ReflectionException;
    use SebastianBergmann\CliParser\Parser as CliParser;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeUnit\CodeUnit;
    use SebastianBergmann\CodeUnitReverseLookup\Wizard;
    use SebastianBergmann\Comparator\Comparator;
    use SebastianBergmann\Complexity\Calculator;
    use SebastianBergmann\Diff\Diff;
    use SebastianBergmann\Environment\Runtime;
    use SebastianBergmann\Exporter\Exporter;
    use SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
    use SebastianBergmann\GlobalState\Snapshot;
    use SebastianBergmann\Invoker\Invoker;
    use SebastianBergmann\LinesOfCode\Counter;
    use SebastianBergmann\ObjectEnumerator\Enumerator;
    use SebastianBergmann\RecursionContext\Context;
    use SebastianBergmann\ResourceOperations\ResourceOperations;
    use SebastianBergmann\Template\Template;
    use SebastianBergmann\Timer\Timer;
    use SebastianBergmann\Type\TypeName;
    use SebastianBergmann\Version;
    use Symfony\Polyfill\Ctype\Ctype;
    use TheSeer\Tokenizer\Tokenizer;
    use Webmozart\Assert\Assert;

    /**
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     */
    final class ExcludeList
    {
        /**
         * @var array<string,int>
         */
        const EXCLUDED_CLASS_NAMES = [/** value is missing */];

        /**
         * @var string[]
         */
        private static $directories;

        public static function addDirectory(string $directory): \void {}

        /**
         * @throws Exception
         *
         * @return string[]
         */
        public function getExcludedDirectories(): array {}

        /**
         * @throws Exception
         */
        public function isExcluded(string $file): bool {}

        /**
         * @throws Exception
         */
        private function initialize(): \void {}

    }
}

namespace PHPUnit\Util
{
    use DIRECTORY_SEPARATOR;
    use array_diff;
    use array_keys;
    use fopen;
    use get_defined_vars;
    use sprintf;
    use stream_resolve_include_path;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class FileLoader
    {
        /**
         * Checks if a PHP sourcecode file is readable. The sourcecode file is loaded through the load() method.
         *
         * As a fallback, PHP looks in the directory of the file executing the stream_resolve_include_path function.
         * We do not want to load the Test.php file here, so skip it if it found that.
         * PHP prioritizes the include_path setting, so if the current directory is in there, it will first look in the
         * current working directory.
         *
         * @throws Exception
         */
        public static function checkAndLoad(string $filename): string {}

        /**
         * Loads a PHP sourcefile.
         */
        public static function load(string $filename): \void {}

        /**
         * @see https://github.com/sebastianbergmann/phpunit/pull/2751
         */
        private static function isReadable(string $filename): bool {}

    }
}

namespace PHPUnit\Util
{
    use DIRECTORY_SEPARATOR;
    use is_dir;
    use mkdir;
    use str_replace;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Filesystem
    {
        /**
         * Maps class names to source file names.
         *
         *   - PEAR CS:   Foo_Bar_Baz -> Foo/Bar/Baz.php
         *   - Namespace: Foo\Bar\Baz -> Foo/Bar/Baz.php
         */
        public static function classNameToFilename(string $className): string {}

        public static function createDirectory(string $directory): bool {}

    }
}

namespace PHPUnit\Util
{
    use array_unshift;
    use defined;
    use in_array;
    use is_file;
    use realpath;
    use sprintf;
    use strpos;
    use PHPUnit\Framework\Exception;
    use PHPUnit\Framework\SyntheticError;
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Filter
    {
        /**
         * @throws Exception
         */
        public static function getFilteredStacktrace(\Throwable $t): string {}

        /**
         * @param false|string $prefix
         */
        private static function shouldPrintFrame(array $frame, $prefix, \PHPUnit\Util\ExcludeList $excludeList): bool {}

        private static function fileIsExcluded(string $file, \PHPUnit\Util\ExcludeList $excludeList): bool {}

        private static function frameExists(array $trace, string $file, int $line): bool {}

    }
}

namespace PHPUnit\Util
{
    use array_keys;
    use array_reverse;
    use defined;
    use get_defined_constants;
    use get_included_files;
    use in_array;
    use ini_get_all;
    use is_array;
    use is_file;
    use is_scalar;
    use preg_match;
    use serialize;
    use sprintf;
    use strpos;
    use var_export;
    use Closure;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class GlobalState
    {
        /**
         * @var string[]
         */
        const SUPER_GLOBAL_ARRAYS = [/** value is missing */];

        /**
         * @throws Exception
         */
        public static function getIncludedFilesAsString(): string {}

        /**
         * @param string[] $files
         *
         * @throws Exception
         */
        public static function processIncludedFilesAsString(array $files): string {}

        public static function getIniSettingsAsString(): string {}

        public static function getConstantsAsString(): string {}

        public static function getGlobalsAsString(): string {}

        private static function exportVariable($variable): string {}

        private static function arrayOnlyContainsScalars(array $array): bool {}

    }
}

namespace PHPUnit\Util
{
    use RuntimeException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class InvalidDataSetException extends \RuntimeException
    {
    }
}

namespace PHPUnit\Util
{
    use JSON_PRETTY_PRINT;
    use JSON_UNESCAPED_SLASHES;
    use JSON_UNESCAPED_UNICODE;
    use count;
    use is_array;
    use is_object;
    use json_decode;
    use json_encode;
    use json_last_error;
    use ksort;
    use PHPUnit\Framework\Exception;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Json
    {
        /**
         * Prettify json string.
         *
         * @throws \PHPUnit\Framework\Exception
         */
        public static function prettify(string $json): string {}

        /**
         * To allow comparison of JSON strings, first process them into a consistent
         * format so that they can be compared as strings.
         *
         * @return array ($error, $canonicalized_json)  The $error parameter is used
         *               to indicate an error decoding the json. This is used to avoid ambiguity
         *               with JSON strings consisting entirely of 'null' or 'false'.
         */
        public static function canonicalize(string $json): array {}

        /**
         * JSON object keys are unordered while PHP array keys are ordered.
         *
         * Sort all array keys to ensure both the expected and actual values have
         * their keys in the same order.
         */
        private static function recursiveSort(&$json): \void {}

    }
}

namespace PHPUnit\Util
{
    use ENT_COMPAT;
    use ENT_SUBSTITUTE;
    use PHP_SAPI;
    use assert;
    use count;
    use dirname;
    use explode;
    use fclose;
    use fopen;
    use fsockopen;
    use fwrite;
    use htmlspecialchars;
    use is_resource;
    use is_string;
    use sprintf;
    use str_replace;
    use strncmp;
    use strpos;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    class Printer
    {
        /**
         * @psalm-var closed-resource|resource
         */
        private $stream;

        /**
         * @var bool
         */
        private $isPhpStream;

        /**
         * @param null|resource|string $out
         *
         * @throws Exception
         */
        public function __construct($out = null) {}

        public function write(string $buffer): \void {}

        public function flush(): \void {}

    }
}

namespace PHPUnit\Util
{
    use preg_match;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class RegularExpression
    {
        /**
         * @return false|int
         */
        public static function safeMatch(string $pattern, string $subject) {}

    }
}

namespace PHPUnit\Util
{
    use PHP_OS;
    use PHP_VERSION;
    use addcslashes;
    use array_flip;
    use array_key_exists;
    use array_merge;
    use array_unique;
    use array_unshift;
    use class_exists;
    use count;
    use explode;
    use extension_loaded;
    use function_exists;
    use get_class;
    use ini_get;
    use interface_exists;
    use is_array;
    use is_int;
    use method_exists;
    use phpversion;
    use preg_match;
    use preg_replace;
    use sprintf;
    use strncmp;
    use strpos;
    use strtolower;
    use trim;
    use version_compare;
    use PHPUnit\Framework\Assert;
    use PHPUnit\Framework\CodeCoverageException;
    use PHPUnit\Framework\ExecutionOrderDependency;
    use PHPUnit\Framework\InvalidCoversTargetException;
    use PHPUnit\Framework\SelfDescribing;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\Warning;
    use PHPUnit\Runner\Version;
    use PHPUnit\Util\Annotation\Registry;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionMethod;
    use SebastianBergmann\CodeUnit\CodeUnitCollection;
    use SebastianBergmann\CodeUnit\InvalidCodeUnitException;
    use SebastianBergmann\CodeUnit\Mapper;
    use SebastianBergmann\Environment\OperatingSystem;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Test
    {
        /**
         * @var int
         */
        const UNKNOWN = null;

        /**
         * @var int
         */
        const SMALL = 0;

        /**
         * @var int
         */
        const MEDIUM = 1;

        /**
         * @var int
         */
        const LARGE = 2;

        /**
         * @var array
         */
        private static $hookMethods = [/** value is missing */];

        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public static function describe(\PHPUnit\Framework\Test $test): array {}

        public static function describeAsString(\PHPUnit\Framework\Test $test): string {}

        /**
         * @throws CodeCoverageException
         *
         * @return array|bool
         * @psalm-param class-string $className
         */
        public static function getLinesToBeCovered(string $className, string $methodName) {}

        /**
         * Returns lines of code specified with the @uses annotation.
         *
         * @throws CodeCoverageException
         * @psalm-param class-string $className
         */
        public static function getLinesToBeUsed(string $className, string $methodName): array {}

        public static function requiresCodeCoverageDataCollection(\PHPUnit\Framework\TestCase $test): bool {}

        /**
         * @throws Exception
         * @psalm-param class-string $className
         */
        public static function getRequirements(string $className, string $methodName): array {}

        /**
         * Returns the missing requirements for a test.
         *
         * @throws Exception
         * @throws Warning
         * @psalm-param class-string $className
         */
        public static function getMissingRequirements(string $className, string $methodName): array {}

        /**
         * Returns the provided data for a method.
         *
         * @throws Exception
         * @psalm-param class-string $className
         */
        public static function getProvidedData(string $className, string $methodName): ?array {}

        /**
         * @psalm-param class-string $className
         */
        public static function parseTestMethodAnnotations(string $className, ?string $methodName = ''): array {}

        /**
         * @psalm-param class-string $className
         */
        public static function getInlineAnnotations(string $className, string $methodName): array {}

        /** @psalm-param class-string $className */
        public static function getBackupSettings(string $className, string $methodName): array {}

        /**
         * @psalm-param class-string $className
         *
         * @return ExecutionOrderDependency[]
         */
        public static function getDependencies(string $className, string $methodName): array {}

        /** @psalm-param class-string $className */
        public static function getGroups(string $className, ?string $methodName = ''): array {}

        /** @psalm-param class-string $className */
        public static function getSize(string $className, ?string $methodName): int {}

        /** @psalm-param class-string $className */
        public static function getProcessIsolationSettings(string $className, string $methodName): bool {}

        /** @psalm-param class-string $className */
        public static function getClassProcessIsolationSettings(string $className, string $methodName): bool {}

        /** @psalm-param class-string $className */
        public static function getPreserveGlobalStateSettings(string $className, string $methodName): ?bool {}

        /** @psalm-param class-string $className */
        public static function getHookMethods(string $className): array {}

        public static function isTestMethod(\ReflectionMethod $method): bool {}

        /**
         * @throws CodeCoverageException
         * @psalm-param class-string $className
         */
        private static function getLinesToBeCoveredOrUsed(string $className, string $methodName, string $mode): array {}

        private static function emptyHookMethodsArray(): array {}

        /** @psalm-param class-string $className */
        private static function getBooleanAnnotationSetting(string $className, ?string $methodName, string $settingName): ?bool {}

        /**
         * Trims any extensions from version string that follows after
         * the <major>.<minor>[.<patch>] format.
         */
        private static function sanitizeVersionNumber(string $version) {}

        private static function shouldCoversAnnotationBeUsed(array $annotations): bool {}

        /**
         * Merge two arrays together.
         *
         * If an integer key exists in both arrays and preserveNumericKeys is false, the value
         * from the second array will be appended to the first array. If both values are arrays, they
         * are merged together, else the value of the second array overwrites the one of the first array.
         *
         * This implementation is copied from https://github.com/zendframework/zend-stdlib/blob/76b653c5e99b40eccf5966e3122c90615134ae46/src/ArrayUtils.php
         *
         * Zend Framework (http://framework.zend.com/)
         *
         * @link      http://github.com/zendframework/zf2 for the canonical source repository
         *
         * @copyright Copyright (c) 2005-2015 Zend Technologies USA Inc. (http://www.zend.com)
         * @license   http://framework.zend.com/license/new-bsd New BSD License
         */
        private static function mergeArraysRecursively(array $a, array $b): array {}

        private static function canonicalizeName(string $name): string {}

    }
}

namespace PHPUnit\Util
{
    use PHP_EOL;
    use get_class;
    use sprintf;
    use str_replace;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Runner\PhptTestCase;
    use RecursiveIteratorIterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class TextTestListRenderer
    {
        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function render(\PHPUnit\Framework\TestSuite $suite): string {}

    }
}

namespace PHPUnit\Util
{
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Type
    {
        public static function isType(string $type): bool {}

        public static function isCloneable(object $object): bool {}

    }
}

namespace PHPUnit\Util
{
    use in_array;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     * @psalm-immutable
     */
    final class VersionComparisonOperator
    {
        /**
         * @psalm-var '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne'
         */
        private $operator;

        public function __construct(string $operator) {}

        /**
         * @return '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne'
         */
        public function asString(): string {}

        /**
         * @throws Exception
         *
         * @psalm-assert '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne' $operator
         */
        private function ensureOperatorIsValid(string $operator): \void {}

    }
}

namespace PHPUnit\Util
{
    use DIRECTORY_SEPARATOR;
    use addslashes;
    use array_map;
    use implode;
    use is_string;
    use realpath;
    use sprintf;
    use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage as FilterConfiguration;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     *
     * @deprecated
     */
    final class XdebugFilterScriptGenerator
    {
        public function generate(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $filter): string {}

        private function getItems(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $filter): array {}

    }
}

namespace PHPUnit\Util
{
    use ENT_QUOTES;
    use assert;
    use class_exists;
    use htmlspecialchars;
    use mb_convert_encoding;
    use ord;
    use preg_replace;
    use settype;
    use strlen;
    use DOMCharacterData;
    use DOMDocument;
    use DOMElement;
    use DOMNode;
    use DOMText;
    use ReflectionClass;
    use ReflectionException;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class Xml
    {
        /**
         * @deprecated Only used by assertEqualXMLStructure()
         */
        public static function import(\DOMElement $element): \DOMElement {}

        /**
         * @deprecated Only used by assertEqualXMLStructure()
         */
        public static function removeCharacterDataNodes(\DOMNode $node): \void {}

        /**
         * Escapes a string for the use in XML documents.
         *
         * Any Unicode character is allowed, excluding the surrogate blocks, FFFE,
         * and FFFF (not even as character reference).
         *
         * @see https://www.w3.org/TR/xml/#charsets
         */
        public static function prepareString(string $string): string {}

        /**
         * "Convert" a DOMElement object into a PHP variable.
         */
        public static function xmlToVariable(\DOMElement $element) {}

        private static function convertToUtf8(string $string): string {}

        private static function isUtf8(string $string): bool {}

    }
}

namespace PHPUnit\Util
{
    use get_class;
    use implode;
    use str_replace;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Framework\TestSuite;
    use PHPUnit\Runner\PhptTestCase;
    use RecursiveIteratorIterator;
    use XMLWriter;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    final class XmlTestListRenderer
    {
        /**
         * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
         */
        public function render(\PHPUnit\Framework\TestSuite $suite): string {}

    }
}

namespace PHPUnit
{
    use Throwable;

    /**
     * @internal This class is not covered by the backward compatibility promise for PHPUnit
     */
    interface Exception
    {
    }
}

namespace Composer\Autoload
{

    /**
     * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
     *
     *     $loader = new \Composer\Autoload\ClassLoader();
     *
     *     // register classes with namespaces
     *     $loader->add('Symfony\Component', __DIR__.'/component');
     *     $loader->add('Symfony',           __DIR__.'/framework');
     *
     *     // activate the autoloader
     *     $loader->register();
     *
     *     // to enable searching the include path (eg. for PEAR packages)
     *     $loader->setUseIncludePath(true);
     *
     * In this example, if you try to use a class in the Symfony\Component
     * namespace or one of its children (Symfony\Component\Console for instance),
     * the autoloader will first look for the class under the component/
     * directory, and it will then fallback to the framework/ directory if not
     * found before giving up.
     *
     * This class is loosely based on the Symfony UniversalClassLoader.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Jordi Boggiano <j.boggiano@seld.be>
     * @see    http://www.php-fig.org/psr/psr-0/
     * @see    http://www.php-fig.org/psr/psr-4/
     */
    class ClassLoader
    {
        private $prefixLengthsPsr4 = [/** value is missing */];

        private $prefixDirsPsr4 = [/** value is missing */];

        private $fallbackDirsPsr4 = [/** value is missing */];

        private $prefixesPsr0 = [/** value is missing */];

        private $fallbackDirsPsr0 = [/** value is missing */];

        private $useIncludePath = false;

        private $classMap = [/** value is missing */];

        private $classMapAuthoritative = false;

        private $missingClasses = [/** value is missing */];

        private $apcuPrefix;

        public function getPrefixes() {}

        public function getPrefixesPsr4() {}

        public function getFallbackDirs() {}

        public function getFallbackDirsPsr4() {}

        public function getClassMap() {}

        /**
         * @param array $classMap Class to filename map
         */
        public function addClassMap(array $classMap) {}

        /**
         * Registers a set of PSR-0 directories for a given prefix, either
         * appending or prepending to the ones previously set for this prefix.
         *
         * @param string       $prefix  The prefix
         * @param array|string $paths   The PSR-0 root directories
         * @param bool         $prepend Whether to prepend the directories
         */
        public function add($prefix, $paths, $prepend = false) {}

        /**
         * Registers a set of PSR-4 directories for a given namespace, either
         * appending or prepending to the ones previously set for this namespace.
         *
         * @param string       $prefix  The prefix/namespace, with trailing '\\'
         * @param array|string $paths   The PSR-4 base directories
         * @param bool         $prepend Whether to prepend the directories
         *
         * @throws \InvalidArgumentException
         */
        public function addPsr4($prefix, $paths, $prepend = false) {}

        /**
         * Registers a set of PSR-0 directories for a given prefix,
         * replacing any others previously set for this prefix.
         *
         * @param string       $prefix The prefix
         * @param array|string $paths  The PSR-0 base directories
         */
        public function set($prefix, $paths) {}

        /**
         * Registers a set of PSR-4 directories for a given namespace,
         * replacing any others previously set for this namespace.
         *
         * @param string       $prefix The prefix/namespace, with trailing '\\'
         * @param array|string $paths  The PSR-4 base directories
         *
         * @throws \InvalidArgumentException
         */
        public function setPsr4($prefix, $paths) {}

        /**
         * Turns on searching the include path for class files.
         *
         * @param bool $useIncludePath
         */
        public function setUseIncludePath($useIncludePath) {}

        /**
         * Can be used to check if the autoloader uses the include path to check
         * for classes.
         *
         * @return bool
         */
        public function getUseIncludePath() {}

        /**
         * Turns off searching the prefix and fallback directories for classes
         * that have not been registered with the class map.
         *
         * @param bool $classMapAuthoritative
         */
        public function setClassMapAuthoritative($classMapAuthoritative) {}

        /**
         * Should class lookup fail if not found in the current class map?
         *
         * @return bool
         */
        public function isClassMapAuthoritative() {}

        /**
         * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
         *
         * @param string|null $apcuPrefix
         */
        public function setApcuPrefix($apcuPrefix) {}

        /**
         * The APCu prefix in use, or null if APCu caching is not enabled.
         *
         * @return string|null
         */
        public function getApcuPrefix() {}

        /**
         * Registers this instance as an autoloader.
         *
         * @param bool $prepend Whether to prepend the autoloader or not
         */
        public function register($prepend = false) {}

        /**
         * Unregisters this instance as an autoloader.
         */
        public function unregister() {}

        /**
         * Loads the given class or interface.
         *
         * @param  string    $class The name of the class
         * @return bool|null True if loaded, null otherwise
         */
        public function loadClass($class) {}

        /**
         * Finds the path to the file where the class is defined.
         *
         * @param string $class The name of the class
         *
         * @return string|false The path if found, false otherwise
         */
        public function findFile($class) {}

        private function findFileWithExtension($class, $ext) {}

    }
}

namespace Composer\Autoload
{

    class ComposerStaticInitdd83a7ee27459590b297489146651a64
    {
        public static $files = [/** value is missing */];

        public static $prefixLengthsPsr4 = [/** value is missing */];

        public static $prefixDirsPsr4 = [/** value is missing */];

        public static $classMap = [/** value is missing */];

        public static function getInitializer(\Composer\Autoload\ClassLoader $loader) {}

    }
}

namespace
{

    class ComposerAutoloaderInitdd83a7ee27459590b297489146651a64
    {
        private static $loader;

        public static function loadClassLoader($class) {}

        public static function getLoader() {}

    }
}

namespace Doctrine\Instantiator\Exception
{
    use Throwable;

    /**
     * Base exception marker interface for the instantiator component
     */
    interface ExceptionInterface
    {
    }
}

namespace Doctrine\Instantiator\Exception
{
    use InvalidArgumentException as BaseInvalidArgumentException;
    use ReflectionClass;
    use PHP_VERSION_ID;
    use interface_exists;
    use sprintf;
    use trait_exists;

    /**
     * Exception for invalid arguments provided to the instantiator
     */
    class InvalidArgumentException extends \InvalidArgumentException
    {
        public static function fromNonExistingClass(string $className): self {}

        public static function fromAbstractClass(\ReflectionClass $reflectionClass): self {}

    }
}

namespace Doctrine\Instantiator\Exception
{
    use Exception;
    use ReflectionClass;
    use UnexpectedValueException as BaseUnexpectedValueException;
    use sprintf;

    /**
     * Exception for given parameters causing invalid/unexpected state on instantiation
     */
    class UnexpectedValueException extends \UnexpectedValueException
    {
        public static function fromSerializationTriggeredException(\ReflectionClass $reflectionClass, \Exception $exception): self {}

        public static function fromUncleanUnSerialization(\ReflectionClass $reflectionClass, string $errorString, int $errorCode, string $errorFile, int $errorLine): self {}

    }
}

namespace Doctrine\Instantiator
{
    use ArrayIterator;
    use Doctrine\Instantiator\Exception\InvalidArgumentException;
    use Doctrine\Instantiator\Exception\UnexpectedValueException;
    use Exception;
    use ReflectionClass;
    use ReflectionException;
    use Serializable;
    use class_exists;
    use is_subclass_of;
    use restore_error_handler;
    use set_error_handler;
    use sprintf;
    use strlen;
    use unserialize;

    /**
     * {@inheritDoc}
     */
    final class Instantiator implements \Doctrine\Instantiator\InstantiatorInterface
    {
        /**
         * Markers used internally by PHP to define whether {@see \unserialize} should invoke
         * the method {@see \Serializable::unserialize()} when dealing with classes implementing
         * the {@see \Serializable} interface.
         */
        const SERIALIZATION_FORMAT_USE_UNSERIALIZER = 'C';

        const SERIALIZATION_FORMAT_AVOID_UNSERIALIZER = 'O';

        /**
         * Used to instantiate specific classes, indexed by class name.
         *
         * @var callable[]
         */
        private static $cachedInstantiators = [/** value is missing */];

        /**
         * Array of objects that can directly be cloned, indexed by class name.
         *
         * @var object[]
         */
        private static $cachedCloneables = [/** value is missing */];

        /**
         * {@inheritDoc}
         */
        public function instantiate($className) {}

        /**
         * Builds the requested object and caches it in static properties for performance
         *
         * @return object
         */
        private function buildAndCacheFromFactory(string $className) {}

        /**
         * Builds a callable capable of instantiating the given $className without
         * invoking its constructor.
         *
         * @throws InvalidArgumentException
         * @throws UnexpectedValueException
         * @throws ReflectionException
         */
        private function buildFactory(string $className): callable {}

        /**
         * @throws InvalidArgumentException
         * @throws ReflectionException
         */
        private function getReflectionClass(string $className): \ReflectionClass {}

        /**
         * @throws UnexpectedValueException
         */
        private function checkIfUnSerializationIsSupported(\ReflectionClass $reflectionClass, string $serializedString): \void {}

        /**
         * @throws UnexpectedValueException
         */
        private function attemptInstantiationViaUnSerialization(\ReflectionClass $reflectionClass, string $serializedString): \void {}

        private function isInstantiableViaReflection(\ReflectionClass $reflectionClass): bool {}

        /**
         * Verifies whether the given class is to be considered internal
         */
        private function hasInternalAncestors(\ReflectionClass $reflectionClass): bool {}

        /**
         * Checks if a class is cloneable
         *
         * Classes implementing `__clone` cannot be safely cloned, as that may cause side-effects.
         */
        private function isSafeToClone(\ReflectionClass $reflection): bool {}

    }
}

namespace Doctrine\Instantiator
{
    use Doctrine\Instantiator\Exception\ExceptionInterface;

    /**
     * Instantiator provides utility methods to build objects without invoking their constructors
     */
    interface InstantiatorInterface
    {
        /**
         * @param string $className
         *
         * @return object
         *
         * @throws ExceptionInterface
         */
        public function instantiate($className);

    }
}

namespace DeepCopy\Exception
{
    use UnexpectedValueException;

    class CloneException extends \UnexpectedValueException
    {
    }
}

namespace DeepCopy\Exception
{
    use ReflectionException;

    class PropertyException extends \ReflectionException
    {
    }
}

namespace DeepCopy\Filter\Doctrine
{
    use DeepCopy\Filter\Filter;
    use DeepCopy\Reflection\ReflectionHelper;

    /**
     * @final
     */
    class DoctrineCollectionFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * Copies the object property doctrine collection.
         *
         * {@inheritdoc}
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Filter\Doctrine
{
    use DeepCopy\Filter\Filter;
    use DeepCopy\Reflection\ReflectionHelper;
    use Doctrine\Common\Collections\ArrayCollection;

    /**
     * @final
     */
    class DoctrineEmptyCollectionFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * Sets the object property to an empty doctrine collection.
         *
         * @param object   $object
         * @param string   $property
         * @param callable $objectCopier
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Filter\Doctrine
{
    use DeepCopy\Filter\Filter;

    /**
     * @final
     */
    class DoctrineProxyFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * Triggers the magic method __load() on a Doctrine Proxy class to load the
         * actual entity from the database.
         *
         * {@inheritdoc}
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Filter
{

    /**
     * Filter to apply to a property while copying an object
     */
    interface Filter
    {
        /**
         * Applies the filter to the object.
         *
         * @param object   $object
         * @param string   $property
         * @param callable $objectCopier
         */
        public function apply($object, $property, $objectCopier);

    }
}

namespace DeepCopy\Filter
{

    class KeepFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * Keeps the value of the object property.
         *
         * {@inheritdoc}
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Filter
{
    use DeepCopy\Reflection\ReflectionHelper;

    /**
     * @final
     */
    class ReplaceFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * @var callable
         */
        protected $callback;

        /**
         * @param callable $callable Will be called to get the new value for each property to replace
         */
        public function __construct(callable $callable) {}

        /**
         * Replaces the object property by the result of the callback called with the object property.
         *
         * {@inheritdoc}
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Filter
{
    use DeepCopy\Reflection\ReflectionHelper;

    /**
     * @final
     */
    class SetNullFilter implements \DeepCopy\Filter\Filter
    {
        /**
         * Sets the object property to null.
         *
         * {@inheritdoc}
         */
        public function apply($object, $property, $objectCopier) {}

    }
}

namespace DeepCopy\Matcher\Doctrine
{
    use DeepCopy\Matcher\Matcher;
    use Doctrine\Common\Persistence\Proxy;

    /**
     * @final
     */
    class DoctrineProxyMatcher implements \DeepCopy\Matcher\Matcher
    {
        /**
         * Matches a Doctrine Proxy class.
         *
         * {@inheritdoc}
         */
        public function matches($object, $property) {}

    }
}

namespace DeepCopy\Matcher
{

    interface Matcher
    {
        /**
         * @param object $object
         * @param string $property
         *
         * @return boolean
         */
        public function matches($object, $property);

    }
}

namespace DeepCopy\Matcher
{

    /**
     * @final
     */
    class PropertyMatcher implements \DeepCopy\Matcher\Matcher
    {
        /**
         * @var string
         */
        private $class;

        /**
         * @var string
         */
        private $property;

        /**
         * @param string $class    Class name
         * @param string $property Property name
         */
        public function __construct($class, $property) {}

        /**
         * Matches a specific property of a specific class.
         *
         * {@inheritdoc}
         */
        public function matches($object, $property) {}

    }
}

namespace DeepCopy\Matcher
{

    /**
     * @final
     */
    class PropertyNameMatcher implements \DeepCopy\Matcher\Matcher
    {
        /**
         * @var string
         */
        private $property;

        /**
         * @param string $property Property name
         */
        public function __construct($property) {}

        /**
         * Matches a property by its name.
         *
         * {@inheritdoc}
         */
        public function matches($object, $property) {}

    }
}

namespace DeepCopy\Matcher
{
    use DeepCopy\Reflection\ReflectionHelper;
    use ReflectionException;

    /**
     * Matches a property by its type.
     *
     * It is recommended to use {@see DeepCopy\TypeFilter\TypeFilter} instead, as it applies on all occurrences
     * of given type in copied context (eg. array elements), not just on object properties.
     *
     * @final
     */
    class PropertyTypeMatcher implements \DeepCopy\Matcher\Matcher
    {
        /**
         * @var string
         */
        private $propertyType;

        /**
         * @param string $propertyType Property type
         */
        public function __construct($propertyType) {}

        /**
         * {@inheritdoc}
         */
        public function matches($object, $property) {}

    }
}

namespace DeepCopy\Reflection
{
    use DeepCopy\Exception\PropertyException;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionObject;
    use ReflectionProperty;

    class ReflectionHelper
    {
        /**
         * Retrieves all properties (including private ones), from object and all its ancestors.
         *
         * Standard \ReflectionClass->getProperties() does not return private properties from ancestor classes.
         *
         * @author muratyaman@gmail.com
         * @see http://php.net/manual/en/reflectionclass.getproperties.php
         *
         * @param ReflectionClass $ref
         *
         * @return ReflectionProperty[]
         */
        public static function getProperties(\ReflectionClass $ref) {}

        /**
         * Retrieves property by name from object and all its ancestors.
         *
         * @param object|string $object
         * @param string $name
         *
         * @throws PropertyException
         * @throws ReflectionException
         *
         * @return ReflectionProperty
         */
        public static function getProperty($object, $name) {}

    }
}

namespace DeepCopy\TypeFilter\Date
{
    use DateInterval;
    use DeepCopy\TypeFilter\TypeFilter;

    /**
     * @final
     *
     * @deprecated Will be removed in 2.0. This filter will no longer be necessary in PHP 7.1+.
     */
    class DateIntervalFilter implements \DeepCopy\TypeFilter\TypeFilter
    {
        /**
         * {@inheritdoc}
         *
         * @param DateInterval $element
         *
         * @see http://news.php.net/php.bugs/205076
         */
        public function apply($element) {}

    }
}

namespace DeepCopy\TypeFilter\Spl
{
    use DeepCopy\DeepCopy;
    use DeepCopy\TypeFilter\TypeFilter;

    /**
     * In PHP 7.4 the storage of an ArrayObject isn't returned as
     * ReflectionProperty. So we deep copy its array copy.
     */
    final class ArrayObjectFilter implements \DeepCopy\TypeFilter\TypeFilter
    {
        /**
         * @var DeepCopy
         */
        private $copier;

        public function __construct(\DeepCopy\DeepCopy $copier) {}

        /**
         * {@inheritdoc}
         */
        public function apply($arrayObject) {}

    }
}

namespace DeepCopy\TypeFilter\Spl
{

    /**
     * @deprecated Use {@see SplDoublyLinkedListFilter} instead.
     */
    class SplDoublyLinkedList extends \DeepCopy\TypeFilter\Spl\SplDoublyLinkedListFilter
    {
    }
}

namespace DeepCopy\TypeFilter\Spl
{
    use Closure;
    use DeepCopy\DeepCopy;
    use DeepCopy\TypeFilter\TypeFilter;
    use SplDoublyLinkedList;

    /**
     * @final
     */
    class SplDoublyLinkedListFilter implements \DeepCopy\TypeFilter\TypeFilter
    {
        private $copier;

        public function __construct(\DeepCopy\DeepCopy $copier) {}

        /**
         * {@inheritdoc}
         */
        public function apply($element) {}

        private function createCopyClosure() {}

    }
}

namespace DeepCopy\TypeFilter
{

    /**
     * @final
     */
    class ReplaceFilter implements \DeepCopy\TypeFilter\TypeFilter
    {
        /**
         * @var callable
         */
        protected $callback;

        /**
         * @param callable $callable Will be called to get the new value for each element to replace
         */
        public function __construct(callable $callable) {}

        /**
         * {@inheritdoc}
         */
        public function apply($element) {}

    }
}

namespace DeepCopy\TypeFilter
{

    /**
     * @final
     */
    class ShallowCopyFilter implements \DeepCopy\TypeFilter\TypeFilter
    {
        /**
         * {@inheritdoc}
         */
        public function apply($element) {}

    }
}

namespace DeepCopy\TypeFilter
{

    interface TypeFilter
    {
        /**
         * Applies the filter to the object.
         *
         * @param mixed $element
         */
        public function apply($element);

    }
}

namespace DeepCopy\TypeMatcher
{

    class TypeMatcher
    {
        /**
         * @var string
         */
        private $type;

        /**
         * @param string $type
         */
        public function __construct($type) {}

        /**
         * @param mixed $element
         *
         * @return boolean
         */
        public function matches($element) {}

    }
}

namespace DeepCopy
{
    use ArrayObject;
    use DateInterval;
    use DateTimeInterface;
    use DateTimeZone;
    use DeepCopy\Exception\CloneException;
    use DeepCopy\Filter\Filter;
    use DeepCopy\Matcher\Matcher;
    use DeepCopy\Reflection\ReflectionHelper;
    use DeepCopy\TypeFilter\Date\DateIntervalFilter;
    use DeepCopy\TypeFilter\Spl\ArrayObjectFilter;
    use DeepCopy\TypeFilter\Spl\SplDoublyLinkedListFilter;
    use DeepCopy\TypeFilter\TypeFilter;
    use DeepCopy\TypeMatcher\TypeMatcher;
    use ReflectionObject;
    use ReflectionProperty;
    use SplDoublyLinkedList;

    /**
     * @final
     */
    class DeepCopy
    {
        /**
         * @var object[] List of objects copied.
         */
        private $hashMap = [/** value is missing */];

        /**
         * Filters to apply.
         *
         * @var array Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
         */
        private $filters = [/** value is missing */];

        /**
         * Type Filters to apply.
         *
         * @var array Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
         */
        private $typeFilters = [/** value is missing */];

        /**
         * @var bool
         */
        private $skipUncloneable = false;

        /**
         * @var bool
         */
        private $useCloneMethod;

        /**
         * @param bool $useCloneMethod   If set to true, when an object implements the __clone() function, it will be used
         *                               instead of the regular deep cloning.
         */
        public function __construct($useCloneMethod = false) {}

        /**
         * If enabled, will not throw an exception when coming across an uncloneable property.
         *
         * @param $skipUncloneable
         *
         * @return $this
         */
        public function skipUncloneable($skipUncloneable = true) {}

        /**
         * Deep copies the given object.
         *
         * @param mixed $object
         *
         * @return mixed
         */
        public function copy($object) {}

        public function addFilter(\DeepCopy\Filter\Filter $filter, \DeepCopy\Matcher\Matcher $matcher) {}

        public function prependFilter(\DeepCopy\Filter\Filter $filter, \DeepCopy\Matcher\Matcher $matcher) {}

        public function addTypeFilter(\DeepCopy\TypeFilter\TypeFilter $filter, \DeepCopy\TypeMatcher\TypeMatcher $matcher) {}

        private function recursiveCopy($var) {}

        /**
         * Copy an array
         * @param array $array
         * @return array
         */
        private function copyArray(array $array) {}

        /**
         * Copies an object.
         *
         * @param object $object
         *
         * @throws CloneException
         *
         * @return object
         */
        private function copyObject($object) {}

        private function copyObjectProperty($object, \ReflectionProperty $property) {}

        /**
         * Returns first filter that matches variable, `null` if no such filter found.
         *
         * @param array $filterRecords Associative array with 2 members: 'filter' with value of type {@see TypeFilter} and
         *                             'matcher' with value of type {@see TypeMatcher}
         * @param mixed $var
         *
         * @return TypeFilter|null
         */
        private function getFirstMatchedTypeFilter(array $filterRecords, $var) {}

        /**
         * Returns first element that matches predicate, `null` if no such element found.
         *
         * @param array    $elements Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
         * @param callable $predicate Predicate arguments are: element.
         *
         * @return array|null Associative array with 2 members: 'filter' with value of type {@see TypeFilter} and 'matcher'
         *                    with value of type {@see TypeMatcher} or `null`.
         */
        private function first(array $elements, callable $predicate) {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node\Name;
    use PhpParser\Node\Stmt;

    class Class_ extends \PhpParser\Builder\Declaration
    {
        protected $name;

        protected $extends;

        protected $implements = [/** value is missing */];

        protected $flags = 0;

        protected $uses = [/** value is missing */];

        protected $constants = [/** value is missing */];

        protected $properties = [/** value is missing */];

        protected $methods = [/** value is missing */];

        /**
         * Creates a class builder.
         *
         * @param string $name Name of the class
         */
        public function __construct(string $name) {}

        /**
         * Extends a class.
         *
         * @param Name|string $class Name of class to extend
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function extend($class) {}

        /**
         * Implements one or more interfaces.
         *
         * @param Name|string ...$interfaces Names of interfaces to implement
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function implement(...$interfaces) {}

        /**
         * Makes the class abstract.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeAbstract() {}

        /**
         * Makes the class final.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeFinal() {}

        /**
         * Adds a statement.
         *
         * @param Stmt|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built class node.
         *
         * @return Stmt\Class_ The built class node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;

    abstract class Declaration implements \PhpParser\Builder
    {
        protected $attributes = [/** value is missing */];

        abstract public function addStmt($stmt);

        /**
         * Adds multiple statements.
         *
         * @param array $stmts The statements to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmts(array $stmts) {}

        /**
         * Sets doc comment for the declaration.
         *
         * @param PhpParser\Comment\Doc|string $docComment Doc comment to set
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setDocComment($docComment) {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;

    abstract class FunctionLike extends \PhpParser\Builder\Declaration
    {
        protected $returnByRef = false;

        protected $params = [/** value is missing */];

        /** @var string|Node\Name|Node\NullableType|null */
        protected $returnType;

        /**
         * Make the function return by reference.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeReturnByRef() {}

        /**
         * Adds a parameter.
         *
         * @param Node\Param|Param $param The parameter to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addParam($param) {}

        /**
         * Adds multiple parameters.
         *
         * @param array $params The parameters to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addParams(array $params) {}

        /**
         * Sets the return type for PHP 7.
         *
         * @param string|Node\Name|Node\NullableType $type One of array, callable, string, int, float,
         *                                                 bool, iterable, or a class/interface name.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setReturnType($type) {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class Function_ extends \PhpParser\Builder\FunctionLike
    {
        protected $name;

        protected $stmts = [/** value is missing */];

        /**
         * Creates a function builder.
         *
         * @param string $name Name of the function
         */
        public function __construct(string $name) {}

        /**
         * Adds a statement.
         *
         * @param Node|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built function node.
         *
         * @return Stmt\Function_ The built function node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node\Name;
    use PhpParser\Node\Stmt;

    class Interface_ extends \PhpParser\Builder\Declaration
    {
        protected $name;

        protected $extends = [/** value is missing */];

        protected $constants = [/** value is missing */];

        protected $methods = [/** value is missing */];

        /**
         * Creates an interface builder.
         *
         * @param string $name Name of the interface
         */
        public function __construct(string $name) {}

        /**
         * Extends one or more interfaces.
         *
         * @param Name|string ...$interfaces Names of interfaces to extend
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function extend(...$interfaces) {}

        /**
         * Adds a statement.
         *
         * @param Stmt|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built interface node.
         *
         * @return Stmt\Interface_ The built interface node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class Method extends \PhpParser\Builder\FunctionLike
    {
        protected $name;

        protected $flags = 0;

        /** @var array|null */
        protected $stmts = [/** value is missing */];

        /**
         * Creates a method builder.
         *
         * @param string $name Name of the method
         */
        public function __construct(string $name) {}

        /**
         * Makes the method public.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePublic() {}

        /**
         * Makes the method protected.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeProtected() {}

        /**
         * Makes the method private.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePrivate() {}

        /**
         * Makes the method static.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeStatic() {}

        /**
         * Makes the method abstract.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeAbstract() {}

        /**
         * Makes the method final.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeFinal() {}

        /**
         * Adds a statement.
         *
         * @param Node|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built method node.
         *
         * @return Stmt\ClassMethod The built method node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class Namespace_ extends \PhpParser\Builder\Declaration
    {
        private $name;

        private $stmts = [/** value is missing */];

        /**
         * Creates a namespace builder.
         *
         * @param Node\Name|string|null $name Name of the namespace
         */
        public function __construct($name) {}

        /**
         * Adds a statement.
         *
         * @param Node|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built node.
         *
         * @return Node The built node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;

    class Param implements \PhpParser\Builder
    {
        protected $name;

        protected $default;

        /** @var Node\Identifier|Node\Name|Node\NullableType|null */
        protected $type;

        protected $byRef = false;

        protected $variadic = false;

        /**
         * Creates a parameter builder.
         *
         * @param string $name Name of the parameter
         */
        public function __construct(string $name) {}

        /**
         * Sets default value for the parameter.
         *
         * @param mixed $value Default value to use
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setDefault($value) {}

        /**
         * Sets type for the parameter.
         *
         * @param string|Node\Name|Node\NullableType|Node\UnionType $type Parameter type
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setType($type) {}

        /**
         * Sets type for the parameter.
         *
         * @param string|Node\Name|Node\NullableType|Node\UnionType $type Parameter type
         *
         * @return $this The builder instance (for fluid interface)
         *
         * @deprecated Use setType() instead
         */
        public function setTypeHint($type) {}

        /**
         * Make the parameter accept the value by reference.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeByRef() {}

        /**
         * Make the parameter variadic
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeVariadic() {}

        /**
         * Returns the built parameter node.
         *
         * @return Node\Param The built parameter node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;
    use PhpParser\Node\NullableType;
    use PhpParser\Node\Stmt;

    class Property implements \PhpParser\Builder
    {
        protected $name;

        protected $flags = 0;

        protected $default;

        protected $attributes = [/** value is missing */];

        /** @var null|Identifier|Name|NullableType */
        protected $type;

        /**
         * Creates a property builder.
         *
         * @param string $name Name of the property
         */
        public function __construct(string $name) {}

        /**
         * Makes the property public.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePublic() {}

        /**
         * Makes the property protected.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeProtected() {}

        /**
         * Makes the property private.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePrivate() {}

        /**
         * Makes the property static.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeStatic() {}

        /**
         * Sets default value for the property.
         *
         * @param mixed $value Default value to use
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setDefault($value) {}

        /**
         * Sets doc comment for the property.
         *
         * @param PhpParser\Comment\Doc|string $docComment Doc comment to set
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function setDocComment($docComment) {}

        /**
         * Sets the property type for PHP 7.4+.
         *
         * @param string|Name|NullableType|Identifier $type
         *
         * @return $this
         */
        public function setType($type) {}

        /**
         * Returns the built class node.
         *
         * @return Stmt\Property The built property node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser\Builder;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class TraitUse implements \PhpParser\Builder
    {
        protected $traits = [/** value is missing */];

        protected $adaptations = [/** value is missing */];

        /**
         * Creates a trait use builder.
         *
         * @param Node\Name|string ...$traits Names of used traits
         */
        public function __construct(...$traits) {}

        /**
         * Adds used trait.
         *
         * @param Node\Name|string $trait Trait name
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function and($trait) {}

        /**
         * Adds trait adaptation.
         *
         * @param Stmt\TraitUseAdaptation|Builder\TraitUseAdaptation $adaptation Trait adaptation
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function with($adaptation) {}

        /**
         * Returns the built node.
         *
         * @return Node The built node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser\Builder;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class TraitUseAdaptation implements \PhpParser\Builder
    {
        const TYPE_UNDEFINED = 0;

        const TYPE_ALIAS = 1;

        const TYPE_PRECEDENCE = 2;

        /** @var int Type of building adaptation */
        protected $type;

        protected $trait;

        protected $method;

        protected $modifier;

        protected $alias;

        protected $insteadof = [/** value is missing */];

        /**
         * Creates a trait use adaptation builder.
         *
         * @param Node\Name|string|null  $trait  Name of adaptated trait
         * @param Node\Identifier|string $method Name of adaptated method
         */
        public function __construct($trait, $method) {}

        /**
         * Sets alias of method.
         *
         * @param Node\Identifier|string $alias Alias for adaptated method
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function as($alias) {}

        /**
         * Sets adaptated method public.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePublic() {}

        /**
         * Sets adaptated method protected.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makeProtected() {}

        /**
         * Sets adaptated method private.
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function makePrivate() {}

        /**
         * Adds overwritten traits.
         *
         * @param Node\Name|string ...$traits Traits for overwrite
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function insteadof(...$traits) {}

        protected function setModifier(int $modifier) {}

        /**
         * Returns the built node.
         *
         * @return Node The built node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node\Stmt;

    class Trait_ extends \PhpParser\Builder\Declaration
    {
        protected $name;

        protected $uses = [/** value is missing */];

        protected $properties = [/** value is missing */];

        protected $methods = [/** value is missing */];

        /**
         * Creates an interface builder.
         *
         * @param string $name Name of the interface
         */
        public function __construct(string $name) {}

        /**
         * Adds a statement.
         *
         * @param Stmt|PhpParser\Builder $stmt The statement to add
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function addStmt($stmt) {}

        /**
         * Returns the built trait node.
         *
         * @return Stmt\Trait_ The built interface node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Builder
{
    use PhpParser\Builder;
    use PhpParser\BuilderHelpers;
    use PhpParser\Node;
    use PhpParser\Node\Stmt;

    class Use_ implements \PhpParser\Builder
    {
        protected $name;

        protected $type;

        protected $alias;

        /**
         * Creates a name use (alias) builder.
         *
         * @param Node\Name|string $name Name of the entity (namespace, class, function, constant) to alias
         * @param int              $type One of the Stmt\Use_::TYPE_* constants
         */
        public function __construct($name, int $type) {}

        /**
         * Sets alias for used name.
         *
         * @param string $alias Alias to use (last component of full name by default)
         *
         * @return $this The builder instance (for fluid interface)
         */
        public function as(string $alias) {}

        /**
         * Returns the built node.
         *
         * @return Node The built node
         */
        public function getNode(): \PhpParser\Node {}

    }
}

namespace PhpParser\Comment
{

    class Doc extends \PhpParser\Comment
    {
    }
}

namespace PhpParser\ErrorHandler
{
    use PhpParser\Error;
    use PhpParser\ErrorHandler;

    /**
     * Error handler that collects all errors into an array.
     *
     * This allows graceful handling of errors.
     */
    class Collecting
    {
        /** @var Error[] Collected errors */
        private $errors = [/** value is missing */];

        public function handleError(\PhpParser\Error $error) {}

        /**
         * Get collected errors.
         *
         * @return Error[]
         */
        public function getErrors(): array {}

        /**
         * Check whether there are any errors.
         *
         * @return bool
         */
        public function hasErrors(): bool {}

        /**
         * Reset/clear collected errors.
         */
        public function clearErrors() {}

    }
}

namespace PhpParser\ErrorHandler
{
    use PhpParser\Error;
    use PhpParser\ErrorHandler;

    /**
     * Error handler that handles all errors by throwing them.
     *
     * This is the default strategy used by all components.
     */
    class Throwing
    {
        public function handleError(\PhpParser\Error $error) {}

    }
}

namespace PhpParser\Internal
{

    /**
     * @internal
     */
    class DiffElem
    {
        const TYPE_KEEP = 0;

        const TYPE_REMOVE = 1;

        const TYPE_ADD = 2;

        const TYPE_REPLACE = 3;

        /** @var int One of the TYPE_* constants */
        public $type;

        /** @var mixed Is null for add operations */
        public $old;

        /** @var mixed Is null for remove operations */
        public $new;

        public function __construct(int $type, $old, $new) {}

    }
}

namespace PhpParser\Internal
{

    /**
     * Implements the Myers diff algorithm.
     *
     * Myers, Eugene W. "An O (ND) difference algorithm and its variations."
     * Algorithmica 1.1 (1986): 251-266.
     *
     * @internal
     */
    class Differ
    {
        private $isEqual;

        /**
         * Create differ over the given equality relation.
         *
         * @param callable $isEqual Equality relation with signature function($a, $b) : bool
         */
        public function __construct(callable $isEqual) {}

        /**
         * Calculate diff (edit script) from $old to $new.
         *
         * @param array $old Original array
         * @param array $new New array
         *
         * @return DiffElem[] Diff (edit script)
         */
        public function diff(array $old, array $new) {}

        /**
         * Calculate diff, including "replace" operations.
         *
         * If a sequence of remove operations is followed by the same number of add operations, these
         * will be coalesced into replace operations.
         *
         * @param array $old Original array
         * @param array $new New array
         *
         * @return DiffElem[] Diff (edit script), including replace operations
         */
        public function diffWithReplacements(array $old, array $new) {}

        private function calculateTrace(array $a, array $b) {}

        private function extractDiff(array $trace, int $x, int $y, array $a, array $b) {}

        /**
         * Coalesce equal-length sequences of remove+add into a replace operation.
         *
         * @param DiffElem[] $diff
         * @return DiffElem[]
         */
        private function coalesceReplacements(array $diff) {}

    }
}

namespace PhpParser\Internal
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;

    /**
     * This node is used internally by the format-preserving pretty printer to print anonymous classes.
     *
     * The normal anonymous class structure violates assumptions about the order of token offsets.
     * Namely, the constructor arguments are part of the Expr\New_ node and follow the class node, even
     * though they are actually interleaved with them. This special node type is used temporarily to
     * restore a sane token offset order.
     *
     * @internal
     */
    class PrintableNewAnonClassNode extends \PhpParser\Node\Expr
    {
        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /** @var Node\Arg[] Arguments */
        public $args;

        /** @var null|Node\Name Name of extended class */
        public $extends;

        /** @var Node\Name[] Names of implemented interfaces */
        public $implements;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        public function __construct(array $attrGroups, array $args, ?\PhpParser\Node\Name $extends = null, array $implements, array $stmts, array $attributes) {}

        public static function fromNewNode(\PhpParser\Node\Expr\New_ $newNode) {}

        public function getType(): string {}

        public function getSubNodeNames(): array {}

    }
}

namespace PhpParser\Internal
{

    /**
     * Provides operations on token streams, for use by pretty printer.
     *
     * @internal
     */
    class TokenStream
    {
        /** @var array Tokens (in token_get_all format) */
        private $tokens;

        /** @var int[] Map from position to indentation */
        private $indentMap;

        /**
         * Create token stream instance.
         *
         * @param array $tokens Tokens in token_get_all() format
         */
        public function __construct(array $tokens) {}

        /**
         * Whether the given position is immediately surrounded by parenthesis.
         *
         * @param int $startPos Start position
         * @param int $endPos   End position
         *
         * @return bool
         */
        public function haveParens(int $startPos, int $endPos): bool {}

        /**
         * Whether the given position is immediately surrounded by braces.
         *
         * @param int $startPos Start position
         * @param int $endPos   End position
         *
         * @return bool
         */
        public function haveBraces(int $startPos, int $endPos): bool {}

        /**
         * Check whether the position is directly preceded by a certain token type.
         *
         * During this check whitespace and comments are skipped.
         *
         * @param int        $pos               Position before which the token should occur
         * @param int|string $expectedTokenType Token to check for
         *
         * @return bool Whether the expected token was found
         */
        public function haveTokenImmediatelyBefore(int $pos, $expectedTokenType): bool {}

        /**
         * Check whether the position is directly followed by a certain token type.
         *
         * During this check whitespace and comments are skipped.
         *
         * @param int        $pos               Position after which the token should occur
         * @param int|string $expectedTokenType Token to check for
         *
         * @return bool Whether the expected token was found
         */
        public function haveTokenImmediatelyAfter(int $pos, $expectedTokenType): bool {}

        public function skipLeft(int $pos, $skipTokenType) {}

        public function skipRight(int $pos, $skipTokenType) {}

        /**
         * Return first non-whitespace token position smaller or equal to passed position.
         *
         * @param int $pos Token position
         * @return int Non-whitespace token position
         */
        public function skipLeftWhitespace(int $pos) {}

        /**
         * Return first non-whitespace position greater or equal to passed position.
         *
         * @param int $pos Token position
         * @return int Non-whitespace token position
         */
        public function skipRightWhitespace(int $pos) {}

        public function findRight(int $pos, $findTokenType) {}

        /**
         * Whether the given position range contains a certain token type.
         *
         * @param int $startPos Starting position (inclusive)
         * @param int $endPos Ending position (exclusive)
         * @param int|string $tokenType Token type to look for
         * @return bool Whether the token occurs in the given range
         */
        public function haveTokenInRange(int $startPos, int $endPos, $tokenType) {}

        public function haveBracesInRange(int $startPos, int $endPos) {}

        /**
         * Get indentation before token position.
         *
         * @param int $pos Token position
         *
         * @return int Indentation depth (in spaces)
         */
        public function getIndentationBefore(int $pos): int {}

        /**
         * Get the code corresponding to a token offset range, optionally adjusted for indentation.
         *
         * @param int $from   Token start position (inclusive)
         * @param int $to     Token end position (exclusive)
         * @param int $indent By how much the code should be indented (can be negative as well)
         *
         * @return string Code corresponding to token range, adjusted for indentation
         */
        public function getTokenCode(int $from, int $to, int $indent): string {}

        /**
         * Precalculate the indentation at every token position.
         *
         * @return int[] Token position to indentation map
         */
        private function calcIndentMap() {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class AttributeEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        public function reverseEmulate(string $code, array $tokens): array {}

        public function preprocessCode(string $code, array &$patches): string {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class CoaleseEqualTokenEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        public function reverseEmulate(string $code, array $tokens): array {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class FlexibleDocStringEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        const FLEXIBLE_DOC_STRING_REGEX = '/<<<[ \t]*(['"]?)([a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*)\1\r?\n
(?:.*\r?\n)*?
(?<indentation>\h*)\2(?![a-zA-Z0-9_\x80-\xff])(?<separator>(?:;?[\r\n])?)/x';

        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        public function reverseEmulate(string $code, array $tokens): array {}

        public function preprocessCode(string $code, array &$patches): string {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class FnTokenEmulator extends \PhpParser\Lexer\TokenEmulator\KeywordEmulator
    {
        public function getPhpVersion(): string {}

        public function getKeywordString(): string {}

        public function getKeywordToken(): int {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{

    abstract class KeywordEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        abstract public function getKeywordString(): string;

        abstract public function getKeywordToken(): int;

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        /**
         * @param mixed[] $tokens
         * @return mixed[]|null
         */
        private function getPreviousNonSpaceToken(array $tokens, int $start) {}

        public function reverseEmulate(string $code, array $tokens): array {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class MatchTokenEmulator extends \PhpParser\Lexer\TokenEmulator\KeywordEmulator
    {
        public function getPhpVersion(): string {}

        public function getKeywordString(): string {}

        public function getKeywordToken(): int {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class NullsafeTokenEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        public function reverseEmulate(string $code, array $tokens): array {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{
    use PhpParser\Lexer\Emulative;

    final class NumericLiteralSeparatorEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        const BIN = '(?:0b[01]+(?:_[01]+)*)';

        const HEX = '(?:0x[0-9a-f]+(?:_[0-9a-f]+)*)';

        const DEC = '(?:[0-9]+(?:_[0-9]+)*)';

        const SIMPLE_FLOAT = '(?:(?:[0-9]+(?:_[0-9]+)*)\.(?:[0-9]+(?:_[0-9]+)*)?|\.(?:[0-9]+(?:_[0-9]+)*))';

        const EXP = '(?:e[+-]?(?:[0-9]+(?:_[0-9]+)*))';

        const FLOAT = '(?:(?:(?:[0-9]+(?:_[0-9]+)*)\.(?:[0-9]+(?:_[0-9]+)*)?|\.(?:[0-9]+(?:_[0-9]+)*))(?:e[+-]?(?:[0-9]+(?:_[0-9]+)*))?|(?:[0-9]+(?:_[0-9]+)*)(?:e[+-]?(?:[0-9]+(?:_[0-9]+)*)))';

        const NUMBER = '~(?:(?:(?:[0-9]+(?:_[0-9]+)*)\.(?:[0-9]+(?:_[0-9]+)*)?|\.(?:[0-9]+(?:_[0-9]+)*))(?:e[+-]?(?:[0-9]+(?:_[0-9]+)*))?|(?:[0-9]+(?:_[0-9]+)*)(?:e[+-]?(?:[0-9]+(?:_[0-9]+)*)))|(?:0b[01]+(?:_[01]+)*)|(?:0x[0-9a-f]+(?:_[0-9a-f]+)*)|(?:[0-9]+(?:_[0-9]+)*)~iA';

        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        private function resolveIntegerOrFloatToken(string $str): int {}

        public function reverseEmulate(string $code, array $tokens): array {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{

    /**
     * Reverses emulation direction of the inner emulator.
     */
    final class ReverseEmulator extends \PhpParser\Lexer\TokenEmulator\TokenEmulator
    {
        /** @var TokenEmulator Inner emulator */
        private $emulator;

        public function __construct(\PhpParser\Lexer\TokenEmulator\TokenEmulator $emulator) {}

        public function getPhpVersion(): string {}

        public function isEmulationNeeded(string $code): bool {}

        public function emulate(string $code, array $tokens): array {}

        public function reverseEmulate(string $code, array $tokens): array {}

        public function preprocessCode(string $code, array &$patches): string {}

    }
}

namespace PhpParser\Lexer\TokenEmulator
{

    /** @internal */
    abstract class TokenEmulator
    {
        abstract public function getPhpVersion(): string;

        abstract public function isEmulationNeeded(string $code): bool;

        /**
         * @return array Modified Tokens
         */
        abstract public function emulate(string $code, array $tokens): array;

        /**
         * @return array Modified Tokens
         */
        abstract public function reverseEmulate(string $code, array $tokens): array;

        public function preprocessCode(string $code, array &$patches): string {}

    }
}

namespace PhpParser\Lexer
{
    use PhpParser\Error;
    use PhpParser\ErrorHandler;
    use PhpParser\Lexer;
    use PhpParser\Lexer\TokenEmulator\AttributeEmulator;
    use PhpParser\Lexer\TokenEmulator\CoaleseEqualTokenEmulator;
    use PhpParser\Lexer\TokenEmulator\FlexibleDocStringEmulator;
    use PhpParser\Lexer\TokenEmulator\FnTokenEmulator;
    use PhpParser\Lexer\TokenEmulator\MatchTokenEmulator;
    use PhpParser\Lexer\TokenEmulator\NullsafeTokenEmulator;
    use PhpParser\Lexer\TokenEmulator\NumericLiteralSeparatorEmulator;
    use PhpParser\Lexer\TokenEmulator\ReverseEmulator;
    use PhpParser\Lexer\TokenEmulator\TokenEmulator;
    use PhpParser\Parser\Tokens;

    class Emulative extends \PhpParser\Lexer
    {
        const PHP_7_3 = '7.3dev';

        const PHP_7_4 = '7.4dev';

        const PHP_8_0 = '8.0dev';

        /** @var mixed[] Patches used to reverse changes introduced in the code */
        private $patches = [/** value is missing */];

        /** @var TokenEmulator[] */
        private $emulators = [/** value is missing */];

        /** @var string */
        private $targetPhpVersion;

        /**
         * @param mixed[] $options Lexer options. In addition to the usual options,
         *                         accepts a 'phpVersion' string that specifies the
         *                         version to emulated. Defaults to newest supported.
         */
        public function __construct(array $options = [/** value is missing */]) {}

        public function startLexing(string $code, ?\PhpParser\ErrorHandler $errorHandler = null) {}

        private function isForwardEmulationNeeded(string $emulatorPhpVersion): bool {}

        private function isReverseEmulationNeeded(string $emulatorPhpVersion): bool {}

        private function sortPatches() {}

        private function fixupTokens() {}

        /**
         * Fixup line and position information in errors.
         *
         * @param Error[] $errors
         */
        private function fixupErrors(array $errors) {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class BitwiseAnd extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class BitwiseOr extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class BitwiseXor extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Coalesce extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Concat extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Div extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Minus extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Mod extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Mul extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Plus extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class Pow extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class ShiftLeft extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\AssignOp
{
    use PhpParser\Node\Expr\AssignOp;

    class ShiftRight extends \PhpParser\Node\Expr\AssignOp
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class BitwiseAnd extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class BitwiseOr extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class BitwiseXor extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class BooleanAnd extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class BooleanOr extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Coalesce extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Concat extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Div extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Equal extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Greater extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class GreaterOrEqual extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Identical extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class LogicalAnd extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class LogicalOr extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class LogicalXor extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Minus extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Mod extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Mul extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class NotEqual extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class NotIdentical extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Plus extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Pow extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class ShiftLeft extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class ShiftRight extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Smaller extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class SmallerOrEqual extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\BinaryOp
{
    use PhpParser\Node\Expr\BinaryOp;

    class Spaceship extends \PhpParser\Node\Expr\BinaryOp
    {
        public function getOperatorSigil(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Array_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Bool_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Double extends \PhpParser\Node\Expr\Cast
    {
        const KIND_DOUBLE = 1;

        const KIND_FLOAT = 2;

        const KIND_REAL = 3;

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Int_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Object_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class String_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr\Cast
{
    use PhpParser\Node\Expr\Cast;

    class Unset_ extends \PhpParser\Node\Expr\Cast
    {
        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class ArrayDimFetch extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /** @var null|Expr Array index / dim */
        public $dim;

        /**
         * Constructs an array index fetch node.
         *
         * @param Expr      $var        Variable
         * @param null|Expr $dim        Array index / dim
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, ?\PhpParser\Node\Expr $dim = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class ArrayItem extends \PhpParser\Node\Expr
    {
        /** @var null|Expr Key */
        public $key;

        /** @var Expr Value */
        public $value;

        /** @var bool Whether to assign by reference */
        public $byRef;

        /** @var bool Whether to unpack the argument */
        public $unpack;

        /**
         * Constructs an array item node.
         *
         * @param Expr      $value      Value
         * @param null|Expr $key        Key
         * @param bool      $byRef      Whether to assign by reference
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $value, ?\PhpParser\Node\Expr $key = null, bool $byRef = false, array $attributes = [/** value is missing */], bool $unpack = false) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Array_ extends \PhpParser\Node\Expr
    {
        const KIND_LONG = 1;

        const KIND_SHORT = 2;

        /** @var (ArrayItem|null)[] Items */
        public $items;

        /**
         * Constructs an array node.
         *
         * @param (ArrayItem|null)[] $items      Items of the array
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $items = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\FunctionLike;

    class ArrowFunction extends \PhpParser\Node\Expr
    {
        /** @var bool */
        public $static;

        /** @var bool */
        public $byRef;

        /** @var Node\Param[] */
        public $params = [/** value is missing */];

        /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType */
        public $returnType;

        /** @var Expr */
        public $expr;

        /** @var Node\AttributeGroup[] */
        public $attrGroups;

        /**
         * @param array $subNodes   Array of the following optional subnodes:
         *                          'static'     => false   : Whether the closure is static
         *                          'byRef'      => false   : Whether to return by reference
         *                          'params'     => array() : Parameters
         *                          'returnType' => null    : Return type
         *                          'expr'       => Expr    : Expression body
         *                          'attrGroups' => array() : PHP attribute groups
         * @param array $attributes Additional attributes
         */
        public function __construct(array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function returnsByRef(): bool {}

        public function getParams(): array {}

        public function getReturnType() {}

        public function getAttrGroups(): array {}

        /**
         * @return Node\Stmt\Return_[]
         */
        public function getStmts(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Assign extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs an assignment node.
         *
         * @param Expr  $var        Variable
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, \PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    abstract class AssignOp extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a compound assignment operation node.
         *
         * @param Expr  $var        Variable
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, \PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class AssignRef extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable reference is assigned to */
        public $var;

        /** @var Expr Variable which is referenced */
        public $expr;

        /**
         * Constructs an assignment node.
         *
         * @param Expr  $var        Variable
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, \PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    abstract class BinaryOp extends \PhpParser\Node\Expr
    {
        /** @var Expr The left hand side expression */
        public $left;

        /** @var Expr The right hand side expression */
        public $right;

        /**
         * Constructs a binary operator node.
         *
         * @param Expr  $left       The left hand side expression
         * @param Expr  $right      The right hand side expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $left, \PhpParser\Node\Expr $right, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Get the operator sigil for this binary operation.
         *
         * In the case there are multiple possible sigils for an operator, this method does not
         * necessarily return the one used in the parsed code.
         *
         * @return string
         */
        abstract public function getOperatorSigil(): string;

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class BitwiseNot extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a bitwise not node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class BooleanNot extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a boolean not node.
         *
         * @param Expr $expr       Expression
         * @param array               $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    abstract class Cast extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a cast node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;

    class ClassConstFetch extends \PhpParser\Node\Expr
    {
        /** @var Name|Expr Class name */
        public $class;

        /** @var Identifier|Error Constant name */
        public $name;

        /**
         * Constructs a class const fetch node.
         *
         * @param Name|Expr               $class      Class name
         * @param string|Identifier|Error $name       Constant name
         * @param array                   $attributes Additional attributes
         */
        public function __construct($class, $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Clone_ extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a clone node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\FunctionLike;

    class Closure extends \PhpParser\Node\Expr
    {
        /** @var bool Whether the closure is static */
        public $static;

        /** @var bool Whether to return by reference */
        public $byRef;

        /** @var Node\Param[] Parameters */
        public $params;

        /** @var ClosureUse[] use()s */
        public $uses;

        /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
        public $returnType;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /**
         * Constructs a lambda function node.
         *
         * @param array $subNodes   Array of the following optional subnodes:
         *                          'static'     => false  : Whether the closure is static
         *                          'byRef'      => false  : Whether to return by reference
         *                          'params'     => array(): Parameters
         *                          'uses'       => array(): use()s
         *                          'returnType' => null   : Return type
         *                          'stmts'      => array(): Statements
         *                          'attrGroups' => array(): PHP attributes groups
         * @param array $attributes Additional attributes
         */
        public function __construct(array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function returnsByRef(): bool {}

        public function getParams(): array {}

        public function getReturnType() {}

        /** @return Node\Stmt[] */
        public function getStmts(): array {}

        public function getAttrGroups(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class ClosureUse extends \PhpParser\Node\Expr
    {
        /** @var Expr\Variable Variable to use */
        public $var;

        /** @var bool Whether to use by reference */
        public $byRef;

        /**
         * Constructs a closure use node.
         *
         * @param Expr\Variable $var        Variable to use
         * @param bool          $byRef      Whether to use by reference
         * @param array         $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr\Variable $var, bool $byRef = false, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;

    class ConstFetch extends \PhpParser\Node\Expr
    {
        /** @var Name Constant name */
        public $name;

        /**
         * Constructs a const fetch node.
         *
         * @param Name  $name       Constant name
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Name $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Empty_ extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs an empty() node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    /**
     * Error node used during parsing with error recovery.
     *
     * An error node may be placed at a position where an expression is required, but an error occurred.
     * Error nodes will not be present if the parser is run in throwOnError mode (the default).
     */
    class Error extends \PhpParser\Node\Expr
    {
        /**
         * Constructs an error node.
         *
         * @param array $attributes Additional attributes
         */
        public function __construct(array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class ErrorSuppress extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs an error suppress node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Eval_ extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs an eval() node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Exit_ extends \PhpParser\Node\Expr
    {
        const KIND_EXIT = 1;

        const KIND_DIE = 2;

        /** @var null|Expr Expression */
        public $expr;

        /**
         * Constructs an exit() node.
         *
         * @param null|Expr $expr       Expression
         * @param array                    $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Expr $expr = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;

    class FuncCall extends \PhpParser\Node\Expr
    {
        /** @var Node\Name|Expr Function name */
        public $name;

        /** @var Node\Arg[] Arguments */
        public $args;

        /**
         * Constructs a function call node.
         *
         * @param Node\Name|Expr $name       Function name
         * @param Node\Arg[]     $args       Arguments
         * @param array          $attributes Additional attributes
         */
        public function __construct($name, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Include_ extends \PhpParser\Node\Expr
    {
        const TYPE_INCLUDE = 1;

        const TYPE_INCLUDE_ONCE = 2;

        const TYPE_REQUIRE = 3;

        const TYPE_REQUIRE_ONCE = 4;

        /** @var Expr Expression */
        public $expr;

        /** @var int Type of include */
        public $type;

        /**
         * Constructs an include node.
         *
         * @param Expr  $expr       Expression
         * @param int   $type       Type of include
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, int $type, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;

    class Instanceof_ extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /** @var Name|Expr Class name */
        public $class;

        /**
         * Constructs an instanceof check node.
         *
         * @param Expr      $expr       Expression
         * @param Name|Expr $class      Class name
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, $class, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Isset_ extends \PhpParser\Node\Expr
    {
        /** @var Expr[] Variables */
        public $vars;

        /**
         * Constructs an array node.
         *
         * @param Expr[] $vars       Variables
         * @param array  $attributes Additional attributes
         */
        public function __construct(array $vars, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class List_ extends \PhpParser\Node\Expr
    {
        /** @var (ArrayItem|null)[] List of items to assign to */
        public $items;

        /**
         * Constructs a list() destructuring node.
         *
         * @param (ArrayItem|null)[] $items      List of items to assign to
         * @param array              $attributes Additional attributes
         */
        public function __construct(array $items, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\MatchArm;

    class Match_ extends \PhpParser\Node\Expr
    {
        /** @var Node\Expr */
        public $cond;

        /** @var MatchArm[] */
        public $arms;

        /**
         * @param MatchArm[] $arms
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $arms = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Arg;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;

    class MethodCall extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable holding object */
        public $var;

        /** @var Identifier|Expr Method name */
        public $name;

        /** @var Arg[] Arguments */
        public $args;

        /**
         * Constructs a function call node.
         *
         * @param Expr                   $var        Variable holding object
         * @param string|Identifier|Expr $name       Method name
         * @param Arg[]                  $args       Arguments
         * @param array                  $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, $name, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;

    class New_ extends \PhpParser\Node\Expr
    {
        /** @var Node\Name|Expr|Node\Stmt\Class_ Class name */
        public $class;

        /** @var Node\Arg[] Arguments */
        public $args;

        /**
         * Constructs a function call node.
         *
         * @param Node\Name|Expr|Node\Stmt\Class_ $class      Class name (or class node for anonymous classes)
         * @param Node\Arg[]                      $args       Arguments
         * @param array                           $attributes Additional attributes
         */
        public function __construct($class, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Arg;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;

    class NullsafeMethodCall extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable holding object */
        public $var;

        /** @var Identifier|Expr Method name */
        public $name;

        /** @var Arg[] Arguments */
        public $args;

        /**
         * Constructs a nullsafe method call node.
         *
         * @param Expr                   $var        Variable holding object
         * @param string|Identifier|Expr $name       Method name
         * @param Arg[]                  $args       Arguments
         * @param array                  $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, $name, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;

    class NullsafePropertyFetch extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable holding object */
        public $var;

        /** @var Identifier|Expr Property name */
        public $name;

        /**
         * Constructs a nullsafe property fetch node.
         *
         * @param Expr                   $var        Variable holding object
         * @param string|Identifier|Expr $name       Property name
         * @param array                  $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class PostDec extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /**
         * Constructs a post decrement node.
         *
         * @param Expr  $var        Variable
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class PostInc extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /**
         * Constructs a post increment node.
         *
         * @param Expr  $var        Variable
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class PreDec extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /**
         * Constructs a pre decrement node.
         *
         * @param Expr  $var        Variable
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class PreInc extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable */
        public $var;

        /**
         * Constructs a pre increment node.
         *
         * @param Expr  $var        Variable
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Print_ extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs an print() node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;

    class PropertyFetch extends \PhpParser\Node\Expr
    {
        /** @var Expr Variable holding object */
        public $var;

        /** @var Identifier|Expr Property name */
        public $name;

        /**
         * Constructs a function call node.
         *
         * @param Expr                   $var        Variable holding object
         * @param string|Identifier|Expr $name       Property name
         * @param array                  $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $var, $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class ShellExec extends \PhpParser\Node\Expr
    {
        /** @var array Encapsed string array */
        public $parts;

        /**
         * Constructs a shell exec (backtick) node.
         *
         * @param array $parts      Encapsed string array
         * @param array $attributes Additional attributes
         */
        public function __construct(array $parts, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;

    class StaticCall extends \PhpParser\Node\Expr
    {
        /** @var Node\Name|Expr Class name */
        public $class;

        /** @var Identifier|Expr Method name */
        public $name;

        /** @var Node\Arg[] Arguments */
        public $args;

        /**
         * Constructs a static method call node.
         *
         * @param Node\Name|Expr         $class      Class name
         * @param string|Identifier|Expr $name       Method name
         * @param Node\Arg[]             $args       Arguments
         * @param array                  $attributes Additional attributes
         */
        public function __construct($class, $name, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;
    use PhpParser\Node\VarLikeIdentifier;

    class StaticPropertyFetch extends \PhpParser\Node\Expr
    {
        /** @var Name|Expr Class name */
        public $class;

        /** @var VarLikeIdentifier|Expr Property name */
        public $name;

        /**
         * Constructs a static property fetch node.
         *
         * @param Name|Expr                     $class      Class name
         * @param string|VarLikeIdentifier|Expr $name       Property name
         * @param array                         $attributes Additional attributes
         */
        public function __construct($class, $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Ternary extends \PhpParser\Node\Expr
    {
        /** @var Expr Condition */
        public $cond;

        /** @var null|Expr Expression for true */
        public $if;

        /** @var Expr Expression for false */
        public $else;

        /**
         * Constructs a ternary operator node.
         *
         * @param Expr      $cond       Condition
         * @param null|Expr $if         Expression for true
         * @param Expr      $else       Expression for false
         * @param array                    $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, $if, \PhpParser\Node\Expr $else, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node;

    class Throw_ extends \PhpParser\Node\Expr
    {
        /** @var Node\Expr Expression */
        public $expr;

        /**
         * Constructs a throw expression node.
         *
         * @param Node\Expr $expr       Expression
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class UnaryMinus extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a unary minus node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class UnaryPlus extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression */
        public $expr;

        /**
         * Constructs a unary plus node.
         *
         * @param Expr $expr       Expression
         * @param array               $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Variable extends \PhpParser\Node\Expr
    {
        /** @var string|Expr Name */
        public $name;

        /**
         * Constructs a variable node.
         *
         * @param string|Expr $name       Name
         * @param array                      $attributes Additional attributes
         */
        public function __construct($name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class YieldFrom extends \PhpParser\Node\Expr
    {
        /** @var Expr Expression to yield from */
        public $expr;

        /**
         * Constructs an "yield from" node.
         *
         * @param Expr  $expr       Expression
         * @param array $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Expr
{
    use PhpParser\Node\Expr;

    class Yield_ extends \PhpParser\Node\Expr
    {
        /** @var null|Expr Key expression */
        public $key;

        /** @var null|Expr Value expression */
        public $value;

        /**
         * Constructs a yield expression node.
         *
         * @param null|Expr $value      Value expression
         * @param null|Expr $key        Key expression
         * @param array     $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Expr $value = null, ?\PhpParser\Node\Expr $key = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Name
{

    class FullyQualified extends \PhpParser\Node\Name
    {
        /**
         * Checks whether the name is unqualified. (E.g. Name)
         *
         * @return bool Whether the name is unqualified
         */
        public function isUnqualified(): bool {}

        /**
         * Checks whether the name is qualified. (E.g. Name\Name)
         *
         * @return bool Whether the name is qualified
         */
        public function isQualified(): bool {}

        /**
         * Checks whether the name is fully qualified. (E.g. \Name)
         *
         * @return bool Whether the name is fully qualified
         */
        public function isFullyQualified(): bool {}

        /**
         * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
         *
         * @return bool Whether the name is relative
         */
        public function isRelative(): bool {}

        public function toCodeString(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Name
{

    class Relative extends \PhpParser\Node\Name
    {
        /**
         * Checks whether the name is unqualified. (E.g. Name)
         *
         * @return bool Whether the name is unqualified
         */
        public function isUnqualified(): bool {}

        /**
         * Checks whether the name is qualified. (E.g. Name\Name)
         *
         * @return bool Whether the name is qualified
         */
        public function isQualified(): bool {}

        /**
         * Checks whether the name is fully qualified. (E.g. \Name)
         *
         * @return bool Whether the name is fully qualified
         */
        public function isFullyQualified(): bool {}

        /**
         * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
         *
         * @return bool Whether the name is relative
         */
        public function isRelative(): bool {}

        public function toCodeString(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Class_ extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Dir extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class File extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Function_ extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Line extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Method extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Namespace_ extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar\MagicConst
{
    use PhpParser\Node\Scalar\MagicConst;

    class Trait_ extends \PhpParser\Node\Scalar\MagicConst
    {
        public function getName(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Node\Scalar;

    class DNumber extends \PhpParser\Node\Scalar
    {
        /** @var float Number value */
        public $value;

        /**
         * Constructs a float number scalar node.
         *
         * @param float $value      Value of the number
         * @param array $attributes Additional attributes
         */
        public function __construct(float $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * @internal
         *
         * Parses a DNUMBER token like PHP would.
         *
         * @param string $str A string number
         *
         * @return float The parsed number
         */
        public static function parse(string $str): float {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Scalar;

    class Encapsed extends \PhpParser\Node\Scalar
    {
        /** @var Expr[] list of string parts */
        public $parts;

        /**
         * Constructs an encapsed string node.
         *
         * @param Expr[] $parts      Encaps list
         * @param array  $attributes Additional attributes
         */
        public function __construct(array $parts, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Node\Scalar;

    class EncapsedStringPart extends \PhpParser\Node\Scalar
    {
        /** @var string String value */
        public $value;

        /**
         * Constructs a node representing a string part of an encapsed string.
         *
         * @param string $value      String value
         * @param array  $attributes Additional attributes
         */
        public function __construct(string $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Error;
    use PhpParser\Node\Scalar;

    class LNumber extends \PhpParser\Node\Scalar
    {
        const KIND_BIN = 2;

        const KIND_OCT = 8;

        const KIND_DEC = 10;

        const KIND_HEX = 16;

        /** @var int Number value */
        public $value;

        /**
         * Constructs an integer number scalar node.
         *
         * @param int   $value      Value of the number
         * @param array $attributes Additional attributes
         */
        public function __construct(int $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Constructs an LNumber node from a string number literal.
         *
         * @param string $str               String number literal (decimal, octal, hex or binary)
         * @param array  $attributes        Additional attributes
         * @param bool   $allowInvalidOctal Whether to allow invalid octal numbers (PHP 5)
         *
         * @return LNumber The constructed LNumber, including kind attribute
         */
        public static function fromString(string $str, array $attributes = [/** value is missing */], bool $allowInvalidOctal = false): \PhpParser\Node\Scalar\LNumber {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Node\Scalar;

    abstract class MagicConst extends \PhpParser\Node\Scalar
    {
        /**
         * Constructs a magic constant node.
         *
         * @param array $attributes Additional attributes
         */
        public function __construct(array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Get name of magic constant.
         *
         * @return string Name of magic constant
         */
        abstract public function getName(): string;

    }
}

namespace PhpParser\Node\Scalar
{
    use PhpParser\Error;
    use PhpParser\Node\Scalar;

    class String_ extends \PhpParser\Node\Scalar
    {
        const KIND_SINGLE_QUOTED = 1;

        const KIND_DOUBLE_QUOTED = 2;

        const KIND_HEREDOC = 3;

        const KIND_NOWDOC = 4;

        /** @var string String value */
        public $value;

        protected static $replacements = [/** value is missing */];

        /**
         * Constructs a string scalar node.
         *
         * @param string $value      Value of the string
         * @param array  $attributes Additional attributes
         */
        public function __construct(string $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * @internal
         *
         * Parses a string token.
         *
         * @param string $str String token content
         * @param bool $parseUnicodeEscape Whether to parse PHP 7 \u escapes
         *
         * @return string The parsed string
         */
        public static function parse(string $str, bool $parseUnicodeEscape = true): string {}

        /**
         * @internal
         *
         * Parses escape sequences in strings (all string types apart from single quoted).
         *
         * @param string      $str   String without quotes
         * @param null|string $quote Quote type
         * @param bool $parseUnicodeEscape Whether to parse PHP 7 \u escapes
         *
         * @return string String with escape sequences parsed
         */
        public static function parseEscapeSequences(string $str, $quote, bool $parseUnicodeEscape = true): string {}

        /**
         * Converts a Unicode code point to its UTF-8 encoded representation.
         *
         * @param int $num Code point
         *
         * @return string UTF-8 representation of code point
         */
        private static function codePointToUtf8(int $num): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt\TraitUseAdaptation
{
    use PhpParser\Node;

    class Alias extends \PhpParser\Node\Stmt\TraitUseAdaptation
    {
        /** @var null|int New modifier */
        public $newModifier;

        /** @var null|Node\Identifier New name */
        public $newName;

        /**
         * Constructs a trait use precedence adaptation node.
         *
         * @param null|Node\Name              $trait       Trait name
         * @param string|Node\Identifier      $method      Method name
         * @param null|int                    $newModifier New modifier
         * @param null|string|Node\Identifier $newName     New name
         * @param array                       $attributes  Additional attributes
         */
        public function __construct($trait, $method, $newModifier, $newName, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt\TraitUseAdaptation
{
    use PhpParser\Node;

    class Precedence extends \PhpParser\Node\Stmt\TraitUseAdaptation
    {
        /** @var Node\Name[] Overwritten traits */
        public $insteadof;

        /**
         * Constructs a trait use precedence adaptation node.
         *
         * @param Node\Name              $trait       Trait name
         * @param string|Node\Identifier $method      Method name
         * @param Node\Name[]            $insteadof   Overwritten traits
         * @param array                  $attributes  Additional attributes
         */
        public function __construct(\PhpParser\Node\Name $trait, $method, array $insteadof, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Break_ extends \PhpParser\Node\Stmt
    {
        /** @var null|Node\Expr Number of loops to break */
        public $num;

        /**
         * Constructs a break node.
         *
         * @param null|Node\Expr $num        Number of loops to break
         * @param array          $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Expr $num = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Case_ extends \PhpParser\Node\Stmt
    {
        /** @var null|Node\Expr Condition (null for default) */
        public $cond;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a case node.
         *
         * @param null|Node\Expr $cond       Condition (null for default)
         * @param Node\Stmt[]    $stmts      Statements
         * @param array          $attributes Additional attributes
         */
        public function __construct($cond, array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;

    class Catch_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Name[] Types of exceptions to catch */
        public $types;

        /** @var Expr\Variable|null Variable for exception */
        public $var;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a catch node.
         *
         * @param Node\Name[]           $types      Types of exceptions to catch
         * @param Expr\Variable|null    $var        Variable for exception
         * @param Node\Stmt[]           $stmts      Statements
         * @param array                 $attributes Additional attributes
         */
        public function __construct(array $types, ?\PhpParser\Node\Expr\Variable $var = null, array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class ClassConst extends \PhpParser\Node\Stmt
    {
        /** @var int Modifiers */
        public $flags;

        /** @var Node\Const_[] Constant declarations */
        public $consts;

        /** @var Node\AttributeGroup[] */
        public $attrGroups;

        /**
         * Constructs a class const list node.
         *
         * @param Node\Const_[]         $consts     Constant declarations
         * @param int                   $flags      Modifiers
         * @param array                 $attributes Additional attributes
         * @param Node\AttributeGroup[] $attrGroups PHP attribute groups
         */
        public function __construct(array $consts, int $flags = 0, array $attributes = [/** value is missing */], array $attrGroups = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Whether constant is explicitly or implicitly public.
         *
         * @return bool
         */
        public function isPublic(): bool {}

        /**
         * Whether constant is protected.
         *
         * @return bool
         */
        public function isProtected(): bool {}

        /**
         * Whether constant is private.
         *
         * @return bool
         */
        public function isPrivate(): bool {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    /**
     * @property Node\Name $namespacedName Namespaced name (if using NameResolver)
     */
    abstract class ClassLike extends \PhpParser\Node\Stmt
    {
        /** @var Node\Identifier|null Name */
        public $name;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /**
         * @return TraitUse[]
         */
        public function getTraitUses(): array {}

        /**
         * @return ClassConst[]
         */
        public function getConstants(): array {}

        /**
         * @return Property[]
         */
        public function getProperties(): array {}

        /**
         * Gets property with the given name defined directly in this class/interface/trait.
         *
         * @param string $name Name of the property
         *
         * @return Property|null Property node or null if the property does not exist
         */
        public function getProperty(string $name) {}

        /**
         * Gets all methods defined directly in this class/interface/trait
         *
         * @return ClassMethod[]
         */
        public function getMethods(): array {}

        /**
         * Gets method with the given name defined directly in this class/interface/trait.
         *
         * @param string $name Name of the method (compared case-insensitively)
         *
         * @return ClassMethod|null Method node or null if the method does not exist
         */
        public function getMethod(string $name) {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\FunctionLike;

    class ClassMethod extends \PhpParser\Node\Stmt
    {
        /** @var int Flags */
        public $flags;

        /** @var bool Whether to return by reference */
        public $byRef;

        /** @var Node\Identifier Name */
        public $name;

        /** @var Node\Param[] Parameters */
        public $params;

        /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
        public $returnType;

        /** @var Node\Stmt[]|null Statements */
        public $stmts;

        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        private static $magicNames = [/** value is missing */];

        /**
         * Constructs a class method node.
         *
         * @param string|Node\Identifier $name Name
         * @param array $subNodes   Array of the following optional subnodes:
         *                          'flags       => MODIFIER_PUBLIC: Flags
         *                          'byRef'      => false          : Whether to return by reference
         *                          'params'     => array()        : Parameters
         *                          'returnType' => null           : Return type
         *                          'stmts'      => array()        : Statements
         *                          'attrGroups' => array()        : PHP attribute groups
         * @param array $attributes Additional attributes
         */
        public function __construct($name, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function returnsByRef(): bool {}

        public function getParams(): array {}

        public function getReturnType() {}

        public function getStmts() {}

        public function getAttrGroups(): array {}

        /**
         * Whether the method is explicitly or implicitly public.
         *
         * @return bool
         */
        public function isPublic(): bool {}

        /**
         * Whether the method is protected.
         *
         * @return bool
         */
        public function isProtected(): bool {}

        /**
         * Whether the method is private.
         *
         * @return bool
         */
        public function isPrivate(): bool {}

        /**
         * Whether the method is abstract.
         *
         * @return bool
         */
        public function isAbstract(): bool {}

        /**
         * Whether the method is final.
         *
         * @return bool
         */
        public function isFinal(): bool {}

        /**
         * Whether the method is static.
         *
         * @return bool
         */
        public function isStatic(): bool {}

        /**
         * Whether the method is magic.
         *
         * @return bool
         */
        public function isMagic(): bool {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Error;
    use PhpParser\Node;

    class Class_ extends \PhpParser\Node\Stmt\ClassLike
    {
        const MODIFIER_PUBLIC = 1;

        const MODIFIER_PROTECTED = 2;

        const MODIFIER_PRIVATE = 4;

        const MODIFIER_STATIC = 8;

        const MODIFIER_ABSTRACT = 16;

        const MODIFIER_FINAL = 32;

        const VISIBILITY_MODIFIER_MASK = 7;

        /** @var int Type */
        public $flags;

        /** @var null|Node\Name Name of extended class */
        public $extends;

        /** @var Node\Name[] Names of implemented interfaces */
        public $implements;

        /**
         * Constructs a class node.
         *
         * @param string|Node\Identifier|null $name Name
         * @param array       $subNodes   Array of the following optional subnodes:
         *                                'flags'       => 0      : Flags
         *                                'extends'     => null   : Name of extended class
         *                                'implements'  => array(): Names of implemented interfaces
         *                                'stmts'       => array(): Statements
         *                                '$attrGroups' => array(): PHP attribute groups
         * @param array       $attributes Additional attributes
         */
        public function __construct($name, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Whether the class is explicitly abstract.
         *
         * @return bool
         */
        public function isAbstract(): bool {}

        /**
         * Whether the class is final.
         *
         * @return bool
         */
        public function isFinal(): bool {}

        /**
         * Whether the class is anonymous.
         *
         * @return bool
         */
        public function isAnonymous(): bool {}

        /**
         * @internal
         */
        public static function verifyModifier($a, $b) {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Const_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Const_[] Constant declarations */
        public $consts;

        /**
         * Constructs a const list node.
         *
         * @param Node\Const_[] $consts     Constant declarations
         * @param array         $attributes Additional attributes
         */
        public function __construct(array $consts, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Continue_ extends \PhpParser\Node\Stmt
    {
        /** @var null|Node\Expr Number of loops to continue */
        public $num;

        /**
         * Constructs a continue node.
         *
         * @param null|Node\Expr $num        Number of loops to continue
         * @param array          $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Expr $num = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class DeclareDeclare extends \PhpParser\Node\Stmt
    {
        /** @var Node\Identifier Key */
        public $key;

        /** @var Node\Expr Value */
        public $value;

        /**
         * Constructs a declare key=>value pair node.
         *
         * @param string|Node\Identifier $key        Key
         * @param Node\Expr              $value      Value
         * @param array                  $attributes Additional attributes
         */
        public function __construct($key, \PhpParser\Node\Expr $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Declare_ extends \PhpParser\Node\Stmt
    {
        /** @var DeclareDeclare[] List of declares */
        public $declares;

        /** @var Node\Stmt[]|null Statements */
        public $stmts;

        /**
         * Constructs a declare node.
         *
         * @param DeclareDeclare[] $declares   List of declares
         * @param Node\Stmt[]|null $stmts      Statements
         * @param array            $attributes Additional attributes
         */
        public function __construct(array $declares, ?array $stmts = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Do_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var Node\Expr Condition */
        public $cond;

        /**
         * Constructs a do while node.
         *
         * @param Node\Expr   $cond       Condition
         * @param Node\Stmt[] $stmts      Statements
         * @param array       $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Echo_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr[] Expressions */
        public $exprs;

        /**
         * Constructs an echo node.
         *
         * @param Node\Expr[] $exprs      Expressions
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $exprs, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class ElseIf_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Condition */
        public $cond;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs an elseif node.
         *
         * @param Node\Expr   $cond       Condition
         * @param Node\Stmt[] $stmts      Statements
         * @param array       $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Else_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs an else node.
         *
         * @param Node\Stmt[] $stmts      Statements
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    /**
     * Represents statements of type "expr;"
     */
    class Expression extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Expression */
        public $expr;

        /**
         * Constructs an expression statement.
         *
         * @param Node\Expr $expr       Expression
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Finally_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a finally node.
         *
         * @param Node\Stmt[] $stmts      Statements
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class For_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr[] Init expressions */
        public $init;

        /** @var Node\Expr[] Loop conditions */
        public $cond;

        /** @var Node\Expr[] Loop expressions */
        public $loop;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a for loop node.
         *
         * @param array $subNodes   Array of the following optional subnodes:
         *                          'init'  => array(): Init expressions
         *                          'cond'  => array(): Loop conditions
         *                          'loop'  => array(): Loop expressions
         *                          'stmts' => array(): Statements
         * @param array $attributes Additional attributes
         */
        public function __construct(array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Foreach_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Expression to iterate */
        public $expr;

        /** @var null|Node\Expr Variable to assign key to */
        public $keyVar;

        /** @var bool Whether to assign value by reference */
        public $byRef;

        /** @var Node\Expr Variable to assign value to */
        public $valueVar;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a foreach node.
         *
         * @param Node\Expr $expr       Expression to iterate
         * @param Node\Expr $valueVar   Variable to assign value to
         * @param array     $subNodes   Array of the following optional subnodes:
         *                              'keyVar' => null   : Variable to assign key to
         *                              'byRef'  => false  : Whether to assign value by reference
         *                              'stmts'  => array(): Statements
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, \PhpParser\Node\Expr $valueVar, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\FunctionLike;

    /**
     * @property Node\Name $namespacedName Namespaced name (if using NameResolver)
     */
    class Function_ extends \PhpParser\Node\Stmt
    {
        /** @var bool Whether function returns by reference */
        public $byRef;

        /** @var Node\Identifier Name */
        public $name;

        /** @var Node\Param[] Parameters */
        public $params;

        /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
        public $returnType;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /**
         * Constructs a function node.
         *
         * @param string|Node\Identifier $name Name
         * @param array  $subNodes   Array of the following optional subnodes:
         *                           'byRef'      => false  : Whether to return by reference
         *                           'params'     => array(): Parameters
         *                           'returnType' => null   : Return type
         *                           'stmts'      => array(): Statements
         *                           'attrGroups' => array(): PHP attribute groups
         * @param array  $attributes Additional attributes
         */
        public function __construct($name, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function returnsByRef(): bool {}

        public function getParams(): array {}

        public function getReturnType() {}

        public function getAttrGroups(): array {}

        /** @return Node\Stmt[] */
        public function getStmts(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Global_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr[] Variables */
        public $vars;

        /**
         * Constructs a global variables list node.
         *
         * @param Node\Expr[] $vars       Variables to unset
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $vars, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Stmt;

    class Goto_ extends \PhpParser\Node\Stmt
    {
        /** @var Identifier Name of label to jump to */
        public $name;

        /**
         * Constructs a goto node.
         *
         * @param string|Identifier $name       Name of label to jump to
         * @param array             $attributes Additional attributes
         */
        public function __construct($name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Name;
    use PhpParser\Node\Stmt;

    class GroupUse extends \PhpParser\Node\Stmt
    {
        /** @var int Type of group use */
        public $type;

        /** @var Name Prefix for uses */
        public $prefix;

        /** @var UseUse[] Uses */
        public $uses;

        /**
         * Constructs a group use node.
         *
         * @param Name     $prefix     Prefix for uses
         * @param UseUse[] $uses       Uses
         * @param int      $type       Type of group use
         * @param array    $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Name $prefix, array $uses, int $type = PhpParser\Node\Stmt\Use_::TYPE_NORMAL, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Stmt;

    class HaltCompiler extends \PhpParser\Node\Stmt
    {
        /** @var string Remaining text after halt compiler statement. */
        public $remaining;

        /**
         * Constructs a __halt_compiler node.
         *
         * @param string $remaining  Remaining text after halt compiler statement.
         * @param array  $attributes Additional attributes
         */
        public function __construct(string $remaining, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class If_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Condition expression */
        public $cond;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var ElseIf_[] Elseif clauses */
        public $elseifs;

        /** @var null|Else_ Else clause */
        public $else;

        /**
         * Constructs an if node.
         *
         * @param Node\Expr $cond       Condition
         * @param array     $subNodes   Array of the following optional subnodes:
         *                              'stmts'   => array(): Statements
         *                              'elseifs' => array(): Elseif clauses
         *                              'else'    => null   : Else clause
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Stmt;

    class InlineHTML extends \PhpParser\Node\Stmt
    {
        /** @var string String */
        public $value;

        /**
         * Constructs an inline HTML node.
         *
         * @param string $value      String
         * @param array  $attributes Additional attributes
         */
        public function __construct(string $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Interface_ extends \PhpParser\Node\Stmt\ClassLike
    {
        /** @var Node\Name[] Extended interfaces */
        public $extends;

        /**
         * Constructs a class node.
         *
         * @param string|Node\Identifier $name Name
         * @param array  $subNodes   Array of the following optional subnodes:
         *                           'extends'    => array(): Name of extended interfaces
         *                           'stmts'      => array(): Statements
         *                           'attrGroups' => array(): PHP attribute groups
         * @param array  $attributes Additional attributes
         */
        public function __construct($name, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Stmt;

    class Label extends \PhpParser\Node\Stmt
    {
        /** @var Identifier Name */
        public $name;

        /**
         * Constructs a label node.
         *
         * @param string|Identifier $name       Name
         * @param array             $attributes Additional attributes
         */
        public function __construct($name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Namespace_ extends \PhpParser\Node\Stmt
    {
        const KIND_SEMICOLON = 1;

        const KIND_BRACED = 2;

        /** @var null|Node\Name Name */
        public $name;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a namespace node.
         *
         * @param null|Node\Name   $name       Name
         * @param null|Node\Stmt[] $stmts      Statements
         * @param array            $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Name $name = null, $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    /** Nop/empty statement (;). */
    class Nop extends \PhpParser\Node\Stmt
    {
        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;
    use PhpParser\Node\NullableType;
    use PhpParser\Node\UnionType;

    class Property extends \PhpParser\Node\Stmt
    {
        /** @var int Modifiers */
        public $flags;

        /** @var PropertyProperty[] Properties */
        public $props;

        /** @var null|Identifier|Name|NullableType|UnionType Type declaration */
        public $type;

        /** @var Node\AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /**
         * Constructs a class property list node.
         *
         * @param int                                                $flags      Modifiers
         * @param PropertyProperty[]                                 $props      Properties
         * @param array                                              $attributes Additional attributes
         * @param null|string|Identifier|Name|NullableType|UnionType $type       Type declaration
         * @param Node\AttributeGroup[]                              $attrGroups PHP attribute groups
         */
        public function __construct(int $flags, array $props, array $attributes = [/** value is missing */], $type = null, array $attrGroups = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Whether the property is explicitly or implicitly public.
         *
         * @return bool
         */
        public function isPublic(): bool {}

        /**
         * Whether the property is protected.
         *
         * @return bool
         */
        public function isProtected(): bool {}

        /**
         * Whether the property is private.
         *
         * @return bool
         */
        public function isPrivate(): bool {}

        /**
         * Whether the property is static.
         *
         * @return bool
         */
        public function isStatic(): bool {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class PropertyProperty extends \PhpParser\Node\Stmt
    {
        /** @var Node\VarLikeIdentifier Name */
        public $name;

        /** @var null|Node\Expr Default */
        public $default;

        /**
         * Constructs a class property node.
         *
         * @param string|Node\VarLikeIdentifier $name       Name
         * @param null|Node\Expr                $default    Default value
         * @param array                         $attributes Additional attributes
         */
        public function __construct($name, ?\PhpParser\Node\Expr $default = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Return_ extends \PhpParser\Node\Stmt
    {
        /** @var null|Node\Expr Expression */
        public $expr;

        /**
         * Constructs a return node.
         *
         * @param null|Node\Expr $expr       Expression
         * @param array          $attributes Additional attributes
         */
        public function __construct(?\PhpParser\Node\Expr $expr = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;

    class StaticVar extends \PhpParser\Node\Stmt
    {
        /** @var Expr\Variable Variable */
        public $var;

        /** @var null|Node\Expr Default value */
        public $default;

        /**
         * Constructs a static variable node.
         *
         * @param Expr\Variable  $var         Name
         * @param null|Node\Expr $default    Default value
         * @param array          $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr\Variable $var, ?\PhpParser\Node\Expr $default = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Stmt;

    class Static_ extends \PhpParser\Node\Stmt
    {
        /** @var StaticVar[] Variable definitions */
        public $vars;

        /**
         * Constructs a static variables list node.
         *
         * @param StaticVar[] $vars       Variable definitions
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $vars, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Switch_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Condition */
        public $cond;

        /** @var Case_[] Case list */
        public $cases;

        /**
         * Constructs a case node.
         *
         * @param Node\Expr $cond       Condition
         * @param Case_[]   $cases      Case list
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $cases, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Throw_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Expression */
        public $expr;

        /**
         * Constructs a legacy throw statement node.
         *
         * @param Node\Expr $expr       Expression
         * @param array     $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $expr, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class TraitUse extends \PhpParser\Node\Stmt
    {
        /** @var Node\Name[] Traits */
        public $traits;

        /** @var TraitUseAdaptation[] Adaptations */
        public $adaptations;

        /**
         * Constructs a trait use node.
         *
         * @param Node\Name[]          $traits      Traits
         * @param TraitUseAdaptation[] $adaptations Adaptations
         * @param array                $attributes  Additional attributes
         */
        public function __construct(array $traits, array $adaptations = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    abstract class TraitUseAdaptation extends \PhpParser\Node\Stmt
    {
        /** @var Node\Name|null Trait name */
        public $trait;

        /** @var Node\Identifier Method name */
        public $method;

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Trait_ extends \PhpParser\Node\Stmt\ClassLike
    {
        /**
         * Constructs a trait node.
         *
         * @param string|Node\Identifier $name Name
         * @param array  $subNodes   Array of the following optional subnodes:
         *                           'stmts'      => array(): Statements
         *                           'attrGroups' => array(): PHP attribute groups
         * @param array  $attributes Additional attributes
         */
        public function __construct($name, array $subNodes = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class TryCatch extends \PhpParser\Node\Stmt
    {
        /** @var Node\Stmt[] Statements */
        public $stmts;

        /** @var Catch_[] Catches */
        public $catches;

        /** @var null|Finally_ Optional finally node */
        public $finally;

        /**
         * Constructs a try catch node.
         *
         * @param Node\Stmt[]   $stmts      Statements
         * @param Catch_[]      $catches    Catches
         * @param null|Finally_ $finally    Optional finally node
         * @param array         $attributes Additional attributes
         */
        public function __construct(array $stmts, array $catches, ?\PhpParser\Node\Stmt\Finally_ $finally = null, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class Unset_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr[] Variables to unset */
        public $vars;

        /**
         * Constructs an unset node.
         *
         * @param Node\Expr[] $vars       Variables to unset
         * @param array       $attributes Additional attributes
         */
        public function __construct(array $vars, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;
    use PhpParser\Node\Identifier;

    class UseUse extends \PhpParser\Node\Stmt
    {
        /** @var int One of the Stmt\Use_::TYPE_* constants. Will only differ from TYPE_UNKNOWN for mixed group uses */
        public $type;

        /** @var Node\Name Namespace, class, function or constant to alias */
        public $name;

        /** @var Identifier|null Alias */
        public $alias;

        /**
         * Constructs an alias (use) node.
         *
         * @param Node\Name              $name       Namespace/Class to alias
         * @param null|string|Identifier $alias      Alias
         * @param int                    $type       Type of the use element (for mixed group use only)
         * @param array                  $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Name $name, $alias = null, int $type = PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Get alias. If not explicitly given this is the last component of the used name.
         *
         * @return Identifier
         */
        public function getAlias(): \PhpParser\Node\Identifier {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node\Stmt;

    class Use_ extends \PhpParser\Node\Stmt
    {
        /**
         * Unknown type. Both Stmt\Use_ / Stmt\GroupUse and Stmt\UseUse have a $type property, one of them will always be
         * TYPE_UNKNOWN while the other has one of the three other possible types. For normal use statements the type on the
         * Stmt\UseUse is unknown. It's only the other way around for mixed group use declarations.
         */
        const TYPE_UNKNOWN = 0;

        /** Class or namespace import */
        const TYPE_NORMAL = 1;

        /** Function import */
        const TYPE_FUNCTION = 2;

        /** Constant import */
        const TYPE_CONSTANT = 3;

        /** @var int Type of alias */
        public $type;

        /** @var UseUse[] Aliases */
        public $uses;

        /**
         * Constructs an alias (use) list node.
         *
         * @param UseUse[] $uses       Aliases
         * @param int      $type       Type of alias
         * @param array    $attributes Additional attributes
         */
        public function __construct(array $uses, int $type = self::TYPE_NORMAL, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node\Stmt
{
    use PhpParser\Node;

    class While_ extends \PhpParser\Node\Stmt
    {
        /** @var Node\Expr Condition */
        public $cond;

        /** @var Node\Stmt[] Statements */
        public $stmts;

        /**
         * Constructs a while node.
         *
         * @param Node\Expr   $cond       Condition
         * @param Node\Stmt[] $stmts      Statements
         * @param array       $attributes Additional attributes
         */
        public function __construct(\PhpParser\Node\Expr $cond, array $stmts = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    class Arg extends \PhpParser\NodeAbstract
    {
        /** @var Identifier|null Parameter name (for named parameters) */
        public $name;

        /** @var Expr Value to pass */
        public $value;

        /** @var bool Whether to pass by ref */
        public $byRef;

        /** @var bool Whether to unpack the argument */
        public $unpack;

        /**
         * Constructs a function call argument node.
         *
         * @param Expr  $value      Value to pass
         * @param bool  $byRef      Whether to pass by ref
         * @param bool  $unpack     Whether to unpack the argument
         * @param array $attributes Additional attributes
         * @param Identifier|null $name Parameter name (for named parameters)
         */
        public function __construct(\PhpParser\Node\Expr $value, bool $byRef = false, bool $unpack = false, array $attributes = [/** value is missing */], ?\PhpParser\Node\Identifier $name = null) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\Node;
    use PhpParser\NodeAbstract;

    class Attribute extends \PhpParser\NodeAbstract
    {
        /** @var Name Attribute name */
        public $name;

        /** @var Arg[] Attribute arguments */
        public $args;

        /**
         * @param Node\Name $name       Attribute name
         * @param Arg[]     $args       Attribute arguments
         * @param array     $attributes Additional node attributes
         */
        public function __construct(\PhpParser\Node\Name $name, array $args = [/** value is missing */], array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\Node;
    use PhpParser\NodeAbstract;

    class AttributeGroup extends \PhpParser\NodeAbstract
    {
        /** @var Attribute[] Attributes */
        public $attrs;

        /**
         * @param Attribute[] $attrs PHP attributes
         * @param array $attributes Additional node attributes
         */
        public function __construct(array $attrs, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    /**
     * @property Name $namespacedName Namespaced name (for global constants, if using NameResolver)
     */
    class Const_ extends \PhpParser\NodeAbstract
    {
        /** @var Identifier Name */
        public $name;

        /** @var Expr Value */
        public $value;

        /**
         * Constructs a const node for use in class const and const statements.
         *
         * @param string|Identifier $name       Name
         * @param Expr              $value      Value
         * @param array             $attributes Additional attributes
         */
        public function __construct($name, \PhpParser\Node\Expr $value, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    abstract class Expr extends \PhpParser\NodeAbstract
    {
    }
}

namespace PhpParser\Node
{
    use PhpParser\Node;

    interface FunctionLike
    {
        /**
         * Whether to return by reference
         *
         * @return bool
         */
        public function returnsByRef(): bool;

        /**
         * List of parameters
         *
         * @return Param[]
         */
        public function getParams(): array;

        /**
         * Get the declared return type or null
         *
         * @return null|Identifier|Name|NullableType|UnionType
         */
        public function getReturnType();

        /**
         * The function body
         *
         * @return Stmt[]|null
         */
        public function getStmts();

        /**
         * Get PHP attribute groups.
         *
         * @return AttributeGroup[]
         */
        public function getAttrGroups(): array;

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    /**
     * Represents a non-namespaced name. Namespaced names are represented using Name nodes.
     */
    class Identifier extends \PhpParser\NodeAbstract
    {
        /** @var string Identifier as string */
        public $name;

        private static $specialClassNames = [/** value is missing */];

        /**
         * Constructs an identifier node.
         *
         * @param string $name       Identifier as string
         * @param array  $attributes Additional attributes
         */
        public function __construct(string $name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Get identifier as string.
         *
         * @return string Identifier as string.
         */
        public function toString(): string {}

        /**
         * Get lowercased identifier as string.
         *
         * @return string Lowercased identifier as string
         */
        public function toLowerString(): string {}

        /**
         * Checks whether the identifier is a special class name (self, parent or static).
         *
         * @return bool Whether identifier is a special class name
         */
        public function isSpecialClassName(): bool {}

        /**
         * Get identifier as string.
         *
         * @return string Identifier as string
         */
        public function __toString(): string {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\Node;
    use PhpParser\NodeAbstract;

    class MatchArm extends \PhpParser\NodeAbstract
    {
        /** @var null|Node\Expr[] */
        public $conds;

        /** @var Node\Expr */
        public $body;

        /**
         * @param null|Node\Expr[] $conds
         */
        public function __construct($conds, \PhpParser\Node\Expr $body, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    class Name extends \PhpParser\NodeAbstract
    {
        /** @var string[] Parts of the name */
        public $parts;

        private static $specialClassNames = [/** value is missing */];

        /**
         * Constructs a name node.
         *
         * @param string|string[]|self $name       Name as string, part array or Name instance (copy ctor)
         * @param array                $attributes Additional attributes
         */
        public function __construct($name, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        /**
         * Gets the first part of the name, i.e. everything before the first namespace separator.
         *
         * @return string First part of the name
         */
        public function getFirst(): string {}

        /**
         * Gets the last part of the name, i.e. everything after the last namespace separator.
         *
         * @return string Last part of the name
         */
        public function getLast(): string {}

        /**
         * Checks whether the name is unqualified. (E.g. Name)
         *
         * @return bool Whether the name is unqualified
         */
        public function isUnqualified(): bool {}

        /**
         * Checks whether the name is qualified. (E.g. Name\Name)
         *
         * @return bool Whether the name is qualified
         */
        public function isQualified(): bool {}

        /**
         * Checks whether the name is fully qualified. (E.g. \Name)
         *
         * @return bool Whether the name is fully qualified
         */
        public function isFullyQualified(): bool {}

        /**
         * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
         *
         * @return bool Whether the name is relative
         */
        public function isRelative(): bool {}

        /**
         * Returns a string representation of the name itself, without taking the name type into
         * account (e.g., not including a leading backslash for fully qualified names).
         *
         * @return string String representation
         */
        public function toString(): string {}

        /**
         * Returns a string representation of the name as it would occur in code (e.g., including
         * leading backslash for fully qualified names.
         *
         * @return string String representation
         */
        public function toCodeString(): string {}

        /**
         * Returns lowercased string representation of the name, without taking the name type into
         * account (e.g., no leading backslash for fully qualified names).
         *
         * @return string Lowercased string representation
         */
        public function toLowerString(): string {}

        /**
         * Checks whether the identifier is a special class name (self, parent or static).
         *
         * @return bool Whether identifier is a special class name
         */
        public function isSpecialClassName(): bool {}

        /**
         * Returns a string representation of the name by imploding the namespace parts with the
         * namespace separator.
         *
         * @return string String representation
         */
        public function __toString(): string {}

        /**
         * Gets a slice of a name (similar to array_slice).
         *
         * This method returns a new instance of the same type as the original and with the same
         * attributes.
         *
         * If the slice is empty, null is returned. The null value will be correctly handled in
         * concatenations using concat().
         *
         * Offset and length have the same meaning as in array_slice().
         *
         * @param int      $offset Offset to start the slice at (may be negative)
         * @param int|null $length Length of the slice (may be negative)
         *
         * @return static|null Sliced name
         */
        public function slice(int $offset, ?int $length = null) {}

        /**
         * Concatenate two names, yielding a new Name instance.
         *
         * The type of the generated instance depends on which class this method is called on, for
         * example Name\FullyQualified::concat() will yield a Name\FullyQualified instance.
         *
         * If one of the arguments is null, a new instance of the other name will be returned. If both
         * arguments are null, null will be returned. As such, writing
         *     Name::concat($namespace, $shortName)
         * where $namespace is a Name node or null will work as expected.
         *
         * @param string|string[]|self|null $name1      The first name
         * @param string|string[]|self|null $name2      The second name
         * @param array                     $attributes Attributes to assign to concatenated name
         *
         * @return static|null Concatenated name
         */
        public static function concat($name1, $name2, array $attributes = [/** value is missing */]) {}

        /**
         * Prepares a (string, array or Name node) name for use in name changing methods by converting
         * it to an array.
         *
         * @param string|string[]|self $name Name to prepare
         *
         * @return string[] Prepared name
         */
        private static function prepareName($name): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    class NullableType extends \PhpParser\NodeAbstract
    {
        /** @var Identifier|Name Type */
        public $type;

        /**
         * Constructs a nullable type (wrapping another type).
         *
         * @param string|Identifier|Name $type       Type
         * @param array                  $attributes Additional attributes
         */
        public function __construct($type, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    class Param extends \PhpParser\NodeAbstract
    {
        /** @var null|Identifier|Name|NullableType|UnionType Type declaration */
        public $type;

        /** @var bool Whether parameter is passed by reference */
        public $byRef;

        /** @var bool Whether this is a variadic argument */
        public $variadic;

        /** @var Expr\Variable|Expr\Error Parameter variable */
        public $var;

        /** @var null|Expr Default value */
        public $default;

        /** @var int */
        public $flags;

        /** @var AttributeGroup[] PHP attribute groups */
        public $attrGroups;

        /**
         * Constructs a parameter node.
         *
         * @param Expr\Variable|Expr\Error                           $var        Parameter variable
         * @param null|Expr                                          $default    Default value
         * @param null|string|Identifier|Name|NullableType|UnionType $type       Type declaration
         * @param bool                                               $byRef      Whether is passed by reference
         * @param bool                                               $variadic   Whether this is a variadic argument
         * @param array                                              $attributes Additional attributes
         * @param int                                                $flags      Optional visibility flags
         * @param AttributeGroup[]                                   $attrGroups PHP attribute groups
         */
        public function __construct($var, ?\PhpParser\Node\Expr $default = null, $type = null, bool $byRef = false, bool $variadic = false, array $attributes = [/** value is missing */], int $flags = 0, array $attrGroups = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{

    abstract class Scalar extends \PhpParser\Node\Expr
    {
    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    abstract class Stmt extends \PhpParser\NodeAbstract
    {
    }
}

namespace PhpParser\Node
{
    use PhpParser\NodeAbstract;

    class UnionType extends \PhpParser\NodeAbstract
    {
        /** @var (Identifier|Name)[] Types */
        public $types;

        /**
         * Constructs a union type.
         *
         * @param (Identifier|Name)[] $types      Types
         * @param array               $attributes Additional attributes
         */
        public function __construct(array $types, array $attributes = [/** value is missing */]) {}

        public function getSubNodeNames(): array {}

        public function getType(): string {}

    }
}

namespace PhpParser\Node
{

    /**
     * Represents a name that is written in source code with a leading dollar,
     * but is not a proper variable. The leading dollar is not stored as part of the name.
     *
     * Examples: Names in property declarations are formatted as variables. Names in static property
     * lookups are also formatted as variables.
     */
    class VarLikeIdentifier extends \PhpParser\Node\Identifier
    {
        public function getType(): string {}

    }
}

namespace PhpParser\NodeVisitor
{
    use PhpParser\Node;
    use PhpParser\NodeVisitorAbstract;

    /**
     * Visitor cloning all nodes and linking to the original nodes using an attribute.
     *
     * This visitor is required to perform format-preserving pretty prints.
     */
    class CloningVisitor extends \PhpParser\NodeVisitorAbstract
    {
        public function enterNode(\PhpParser\Node $origNode) {}

    }
}

namespace PhpParser\NodeVisitor
{
    use PhpParser\Node;
    use PhpParser\NodeVisitorAbstract;

    /**
     * This visitor can be used to find and collect all nodes satisfying some criterion determined by
     * a filter callback.
     */
    class FindingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /** @var callable Filter callback */
        protected $filterCallback;

        /** @var Node[] Found nodes */
        protected $foundNodes;

        public function __construct(callable $filterCallback) {}

        /**
         * Get found nodes satisfying the filter callback.
         *
         * Nodes are returned in pre-order.
         *
         * @return Node[] Found nodes
         */
        public function getFoundNodes(): array {}

        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

    }
}

namespace PhpParser\NodeVisitor
{
    use PhpParser\Node;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitorAbstract;

    /**
     * This visitor can be used to find the first node satisfying some criterion determined by
     * a filter callback.
     */
    class FirstFindingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /** @var callable Filter callback */
        protected $filterCallback;

        /** @var null|Node Found node */
        protected $foundNode;

        public function __construct(callable $filterCallback) {}

        /**
         * Get found node satisfying the filter callback.
         *
         * Returns null if no node satisfies the filter callback.
         *
         * @return null|Node Found node (or null if not found)
         */
        public function getFoundNode() {}

        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

    }
}

namespace PhpParser\NodeVisitor
{
    use PhpParser\ErrorHandler;
    use PhpParser\NameContext;
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;
    use PhpParser\Node\Name\FullyQualified;
    use PhpParser\Node\Stmt;
    use PhpParser\NodeVisitorAbstract;

    class NameResolver extends \PhpParser\NodeVisitorAbstract
    {
        /** @var NameContext Naming context */
        protected $nameContext;

        /** @var bool Whether to preserve original names */
        protected $preserveOriginalNames;

        /** @var bool Whether to replace resolved nodes in place, or to add resolvedNode attributes */
        protected $replaceNodes;

        /**
         * Constructs a name resolution visitor.
         *
         * Options:
         *  * preserveOriginalNames (default false): An "originalName" attribute will be added to
         *    all name nodes that underwent resolution.
         *  * replaceNodes (default true): Resolved names are replaced in-place. Otherwise, a
         *    resolvedName attribute is added. (Names that cannot be statically resolved receive a
         *    namespacedName attribute, as usual.)
         *
         * @param ErrorHandler|null $errorHandler Error handler
         * @param array $options Options
         */
        public function __construct(?\PhpParser\ErrorHandler $errorHandler = null, array $options = [/** value is missing */]) {}

        /**
         * Get name resolution context.
         *
         * @return NameContext
         */
        public function getNameContext(): \PhpParser\NameContext {}

        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

        private function addAlias(\PhpParser\Node\Stmt\UseUse $use, $type, ?\PhpParser\Node\Name $prefix = null) {}

        /** @param Stmt\Function_|Stmt\ClassMethod|Expr\Closure $node */
        private function resolveSignature($node) {}

        private function resolveType($node) {}

        /**
         * Resolve name, according to name resolver options.
         *
         * @param Name $name Function or constant name to resolve
         * @param int  $type One of Stmt\Use_::TYPE_*
         *
         * @return Name Resolved name, or original name with attribute
         */
        protected function resolveName(\PhpParser\Node\Name $name, int $type): \PhpParser\Node\Name {}

        protected function resolveClassName(\PhpParser\Node\Name $name) {}

        protected function addNamespacedName(\PhpParser\Node $node) {}

        protected function resolveAttrGroups(\PhpParser\Node $node) {}

    }
}

namespace PhpParser\NodeVisitor
{
    use PhpParser\Node;
    use PhpParser\NodeVisitorAbstract;

    /**
     * Visitor that connects a child node to its parent node
     * as well as its sibling nodes.
     *
     * On the child node, the parent node can be accessed through
     * <code>$node->getAttribute('parent')</code>, the previous
     * node can be accessed through <code>$node->getAttribute('previous')</code>,
     * and the next node can be accessed through <code>$node->getAttribute('next')</code>.
     */
    final class NodeConnectingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @var Node[]
         */
        private $stack = [/** value is missing */];

        /**
         * @var ?Node
         */
        private $previous;

        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

        public function leaveNode(\PhpParser\Node $node) {}

    }
}

namespace PhpParser\NodeVisitor
{
    use array_pop;
    use count;
    use PhpParser\Node;
    use PhpParser\NodeVisitorAbstract;

    /**
     * Visitor that connects a child node to its parent node.
     *
     * On the child node, the parent node can be accessed through
     * <code>$node->getAttribute('parent')</code>.
     */
    final class ParentConnectingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @var Node[]
         */
        private $stack = [/** value is missing */];

        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

        public function leaveNode(\PhpParser\Node $node) {}

    }
}

namespace PhpParser\Parser
{
    use PhpParser\Error;
    use PhpParser\ErrorHandler;
    use PhpParser\Parser;

    class Multiple
    {
        /** @var Parser[] List of parsers to try, in order of preference */
        private $parsers;

        /**
         * Create a parser which will try multiple parsers in an order of preference.
         *
         * Parsers will be invoked in the order they're provided to the constructor. If one of the
         * parsers runs without throwing, it's output is returned. Otherwise the exception that the
         * first parser generated is thrown.
         *
         * @param Parser[] $parsers
         */
        public function __construct(array $parsers) {}

        public function parse(string $code, ?\PhpParser\ErrorHandler $errorHandler = null) {}

        private function tryParse(\PhpParser\Parser $parser, \PhpParser\ErrorHandler $errorHandler, $code) {}

    }
}

namespace PhpParser\Parser
{
    use PhpParser\Error;
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;
    use PhpParser\Node\Scalar;
    use PhpParser\Node\Stmt;

    class Php5 extends \PhpParser\ParserAbstract
    {
        protected $tokenToSymbolMapSize = 392;

        protected $actionTableSize = 1069;

        protected $gotoTableSize = 580;

        protected $invalidSymbol = 165;

        protected $errorSymbol = 1;

        protected $defaultAction;

        protected $unexpectedTokenRule = 32767;

        protected $YY2TBLSTATE = 405;

        protected $numNonLeafStates = 658;

        protected $symbolToName = [/** value is missing */];

        protected $tokenToSymbol = [/** value is missing */];

        protected $action = [/** value is missing */];

        protected $actionCheck = [/** value is missing */];

        protected $actionBase = [/** value is missing */];

        protected $actionDefault = [/** value is missing */];

        protected $goto = [/** value is missing */];

        protected $gotoCheck = [/** value is missing */];

        protected $gotoBase = [/** value is missing */];

        protected $gotoDefault = [/** value is missing */];

        protected $ruleToNonTerminal = [/** value is missing */];

        protected $ruleToLength = [/** value is missing */];

        protected function initReduceCallbacks() {}

    }
}

namespace PhpParser\Parser
{
    use PhpParser\Error;
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Name;
    use PhpParser\Node\Scalar;
    use PhpParser\Node\Stmt;

    class Php7 extends \PhpParser\ParserAbstract
    {
        protected $tokenToSymbolMapSize = 392;

        protected $actionTableSize = 1162;

        protected $gotoTableSize = 611;

        protected $invalidSymbol = 165;

        protected $errorSymbol = 1;

        protected $defaultAction;

        protected $unexpectedTokenRule = 32767;

        protected $YY2TBLSTATE = 397;

        protected $numNonLeafStates = 694;

        protected $symbolToName = [/** value is missing */];

        protected $tokenToSymbol = [/** value is missing */];

        protected $action = [/** value is missing */];

        protected $actionCheck = [/** value is missing */];

        protected $actionBase = [/** value is missing */];

        protected $actionDefault = [/** value is missing */];

        protected $goto = [/** value is missing */];

        protected $gotoCheck = [/** value is missing */];

        protected $gotoBase = [/** value is missing */];

        protected $gotoDefault = [/** value is missing */];

        protected $ruleToNonTerminal = [/** value is missing */];

        protected $ruleToLength = [/** value is missing */];

        protected function initReduceCallbacks() {}

    }
}

namespace PhpParser\Parser
{

    final class Tokens
    {
        const YYERRTOK = 256;

        const T_THROW = 257;

        const T_INCLUDE = 258;

        const T_INCLUDE_ONCE = 259;

        const T_EVAL = 260;

        const T_REQUIRE = 261;

        const T_REQUIRE_ONCE = 262;

        const T_LOGICAL_OR = 263;

        const T_LOGICAL_XOR = 264;

        const T_LOGICAL_AND = 265;

        const T_PRINT = 266;

        const T_YIELD = 267;

        const T_DOUBLE_ARROW = 268;

        const T_YIELD_FROM = 269;

        const T_PLUS_EQUAL = 270;

        const T_MINUS_EQUAL = 271;

        const T_MUL_EQUAL = 272;

        const T_DIV_EQUAL = 273;

        const T_CONCAT_EQUAL = 274;

        const T_MOD_EQUAL = 275;

        const T_AND_EQUAL = 276;

        const T_OR_EQUAL = 277;

        const T_XOR_EQUAL = 278;

        const T_SL_EQUAL = 279;

        const T_SR_EQUAL = 280;

        const T_POW_EQUAL = 281;

        const T_COALESCE_EQUAL = 282;

        const T_COALESCE = 283;

        const T_BOOLEAN_OR = 284;

        const T_BOOLEAN_AND = 285;

        const T_IS_EQUAL = 286;

        const T_IS_NOT_EQUAL = 287;

        const T_IS_IDENTICAL = 288;

        const T_IS_NOT_IDENTICAL = 289;

        const T_SPACESHIP = 290;

        const T_IS_SMALLER_OR_EQUAL = 291;

        const T_IS_GREATER_OR_EQUAL = 292;

        const T_SL = 293;

        const T_SR = 294;

        const T_INSTANCEOF = 295;

        const T_INC = 296;

        const T_DEC = 297;

        const T_INT_CAST = 298;

        const T_DOUBLE_CAST = 299;

        const T_STRING_CAST = 300;

        const T_ARRAY_CAST = 301;

        const T_OBJECT_CAST = 302;

        const T_BOOL_CAST = 303;

        const T_UNSET_CAST = 304;

        const T_POW = 305;

        const T_NEW = 306;

        const T_CLONE = 307;

        const T_EXIT = 308;

        const T_IF = 309;

        const T_ELSEIF = 310;

        const T_ELSE = 311;

        const T_ENDIF = 312;

        const T_LNUMBER = 313;

        const T_DNUMBER = 314;

        const T_STRING = 315;

        const T_STRING_VARNAME = 316;

        const T_VARIABLE = 317;

        const T_NUM_STRING = 318;

        const T_INLINE_HTML = 319;

        const T_ENCAPSED_AND_WHITESPACE = 320;

        const T_CONSTANT_ENCAPSED_STRING = 321;

        const T_ECHO = 322;

        const T_DO = 323;

        const T_WHILE = 324;

        const T_ENDWHILE = 325;

        const T_FOR = 326;

        const T_ENDFOR = 327;

        const T_FOREACH = 328;

        const T_ENDFOREACH = 329;

        const T_DECLARE = 330;

        const T_ENDDECLARE = 331;

        const T_AS = 332;

        const T_SWITCH = 333;

        const T_MATCH = 334;

        const T_ENDSWITCH = 335;

        const T_CASE = 336;

        const T_DEFAULT = 337;

        const T_BREAK = 338;

        const T_CONTINUE = 339;

        const T_GOTO = 340;

        const T_FUNCTION = 341;

        const T_FN = 342;

        const T_CONST = 343;

        const T_RETURN = 344;

        const T_TRY = 345;

        const T_CATCH = 346;

        const T_FINALLY = 347;

        const T_USE = 348;

        const T_INSTEADOF = 349;

        const T_GLOBAL = 350;

        const T_STATIC = 351;

        const T_ABSTRACT = 352;

        const T_FINAL = 353;

        const T_PRIVATE = 354;

        const T_PROTECTED = 355;

        const T_PUBLIC = 356;

        const T_VAR = 357;

        const T_UNSET = 358;

        const T_ISSET = 359;

        const T_EMPTY = 360;

        const T_HALT_COMPILER = 361;

        const T_CLASS = 362;

        const T_TRAIT = 363;

        const T_INTERFACE = 364;

        const T_EXTENDS = 365;

        const T_IMPLEMENTS = 366;

        const T_OBJECT_OPERATOR = 367;

        const T_NULLSAFE_OBJECT_OPERATOR = 368;

        const T_LIST = 369;

        const T_ARRAY = 370;

        const T_CALLABLE = 371;

        const T_CLASS_C = 372;

        const T_TRAIT_C = 373;

        const T_METHOD_C = 374;

        const T_FUNC_C = 375;

        const T_LINE = 376;

        const T_FILE = 377;

        const T_START_HEREDOC = 378;

        const T_END_HEREDOC = 379;

        const T_DOLLAR_OPEN_CURLY_BRACES = 380;

        const T_CURLY_OPEN = 381;

        const T_PAAMAYIM_NEKUDOTAYIM = 382;

        const T_NAMESPACE = 383;

        const T_NS_C = 384;

        const T_DIR = 385;

        const T_NS_SEPARATOR = 386;

        const T_ELLIPSIS = 387;

        const T_NAME_FULLY_QUALIFIED = 388;

        const T_NAME_QUALIFIED = 389;

        const T_NAME_RELATIVE = 390;

        const T_ATTRIBUTE = 391;

    }
}

namespace PhpParser\PrettyPrinter
{
    use PhpParser\Node;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Expr\AssignOp;
    use PhpParser\Node\Expr\BinaryOp;
    use PhpParser\Node\Expr\Cast;
    use PhpParser\Node\Name;
    use PhpParser\Node\Scalar;
    use PhpParser\Node\Scalar\MagicConst;
    use PhpParser\Node\Stmt;
    use PhpParser\PrettyPrinterAbstract;

    class Standard extends \PhpParser\PrettyPrinterAbstract
    {
        protected function pParam(\PhpParser\Node\Param $node) {}

        protected function pArg(\PhpParser\Node\Arg $node) {}

        protected function pConst(\PhpParser\Node\Const_ $node) {}

        protected function pNullableType(\PhpParser\Node\NullableType $node) {}

        protected function pUnionType(\PhpParser\Node\UnionType $node) {}

        protected function pIdentifier(\PhpParser\Node\Identifier $node) {}

        protected function pVarLikeIdentifier(\PhpParser\Node\VarLikeIdentifier $node) {}

        protected function pAttribute(\PhpParser\Node\Attribute $node) {}

        protected function pAttributeGroup(\PhpParser\Node\AttributeGroup $node) {}

        protected function pName(\PhpParser\Node\Name $node) {}

        protected function pName_FullyQualified(\PhpParser\Node\Name\FullyQualified $node) {}

        protected function pName_Relative(\PhpParser\Node\Name\Relative $node) {}

        protected function pScalar_MagicConst_Class(\PhpParser\Node\Scalar\MagicConst\Class_ $node) {}

        protected function pScalar_MagicConst_Dir(\PhpParser\Node\Scalar\MagicConst\Dir $node) {}

        protected function pScalar_MagicConst_File(\PhpParser\Node\Scalar\MagicConst\File $node) {}

        protected function pScalar_MagicConst_Function(\PhpParser\Node\Scalar\MagicConst\Function_ $node) {}

        protected function pScalar_MagicConst_Line(\PhpParser\Node\Scalar\MagicConst\Line $node) {}

        protected function pScalar_MagicConst_Method(\PhpParser\Node\Scalar\MagicConst\Method $node) {}

        protected function pScalar_MagicConst_Namespace(\PhpParser\Node\Scalar\MagicConst\Namespace_ $node) {}

        protected function pScalar_MagicConst_Trait(\PhpParser\Node\Scalar\MagicConst\Trait_ $node) {}

        protected function pScalar_String(\PhpParser\Node\Scalar\String_ $node) {}

        protected function pScalar_Encapsed(\PhpParser\Node\Scalar\Encapsed $node) {}

        protected function pScalar_LNumber(\PhpParser\Node\Scalar\LNumber $node) {}

        protected function pScalar_DNumber(\PhpParser\Node\Scalar\DNumber $node) {}

        protected function pScalar_EncapsedStringPart(\PhpParser\Node\Scalar\EncapsedStringPart $node) {}

        protected function pExpr_Assign(\PhpParser\Node\Expr\Assign $node) {}

        protected function pExpr_AssignRef(\PhpParser\Node\Expr\AssignRef $node) {}

        protected function pExpr_AssignOp_Plus(\PhpParser\Node\Expr\AssignOp\Plus $node) {}

        protected function pExpr_AssignOp_Minus(\PhpParser\Node\Expr\AssignOp\Minus $node) {}

        protected function pExpr_AssignOp_Mul(\PhpParser\Node\Expr\AssignOp\Mul $node) {}

        protected function pExpr_AssignOp_Div(\PhpParser\Node\Expr\AssignOp\Div $node) {}

        protected function pExpr_AssignOp_Concat(\PhpParser\Node\Expr\AssignOp\Concat $node) {}

        protected function pExpr_AssignOp_Mod(\PhpParser\Node\Expr\AssignOp\Mod $node) {}

        protected function pExpr_AssignOp_BitwiseAnd(\PhpParser\Node\Expr\AssignOp\BitwiseAnd $node) {}

        protected function pExpr_AssignOp_BitwiseOr(\PhpParser\Node\Expr\AssignOp\BitwiseOr $node) {}

        protected function pExpr_AssignOp_BitwiseXor(\PhpParser\Node\Expr\AssignOp\BitwiseXor $node) {}

        protected function pExpr_AssignOp_ShiftLeft(\PhpParser\Node\Expr\AssignOp\ShiftLeft $node) {}

        protected function pExpr_AssignOp_ShiftRight(\PhpParser\Node\Expr\AssignOp\ShiftRight $node) {}

        protected function pExpr_AssignOp_Pow(\PhpParser\Node\Expr\AssignOp\Pow $node) {}

        protected function pExpr_AssignOp_Coalesce(\PhpParser\Node\Expr\AssignOp\Coalesce $node) {}

        protected function pExpr_BinaryOp_Plus(\PhpParser\Node\Expr\BinaryOp\Plus $node) {}

        protected function pExpr_BinaryOp_Minus(\PhpParser\Node\Expr\BinaryOp\Minus $node) {}

        protected function pExpr_BinaryOp_Mul(\PhpParser\Node\Expr\BinaryOp\Mul $node) {}

        protected function pExpr_BinaryOp_Div(\PhpParser\Node\Expr\BinaryOp\Div $node) {}

        protected function pExpr_BinaryOp_Concat(\PhpParser\Node\Expr\BinaryOp\Concat $node) {}

        protected function pExpr_BinaryOp_Mod(\PhpParser\Node\Expr\BinaryOp\Mod $node) {}

        protected function pExpr_BinaryOp_BooleanAnd(\PhpParser\Node\Expr\BinaryOp\BooleanAnd $node) {}

        protected function pExpr_BinaryOp_BooleanOr(\PhpParser\Node\Expr\BinaryOp\BooleanOr $node) {}

        protected function pExpr_BinaryOp_BitwiseAnd(\PhpParser\Node\Expr\BinaryOp\BitwiseAnd $node) {}

        protected function pExpr_BinaryOp_BitwiseOr(\PhpParser\Node\Expr\BinaryOp\BitwiseOr $node) {}

        protected function pExpr_BinaryOp_BitwiseXor(\PhpParser\Node\Expr\BinaryOp\BitwiseXor $node) {}

        protected function pExpr_BinaryOp_ShiftLeft(\PhpParser\Node\Expr\BinaryOp\ShiftLeft $node) {}

        protected function pExpr_BinaryOp_ShiftRight(\PhpParser\Node\Expr\BinaryOp\ShiftRight $node) {}

        protected function pExpr_BinaryOp_Pow(\PhpParser\Node\Expr\BinaryOp\Pow $node) {}

        protected function pExpr_BinaryOp_LogicalAnd(\PhpParser\Node\Expr\BinaryOp\LogicalAnd $node) {}

        protected function pExpr_BinaryOp_LogicalOr(\PhpParser\Node\Expr\BinaryOp\LogicalOr $node) {}

        protected function pExpr_BinaryOp_LogicalXor(\PhpParser\Node\Expr\BinaryOp\LogicalXor $node) {}

        protected function pExpr_BinaryOp_Equal(\PhpParser\Node\Expr\BinaryOp\Equal $node) {}

        protected function pExpr_BinaryOp_NotEqual(\PhpParser\Node\Expr\BinaryOp\NotEqual $node) {}

        protected function pExpr_BinaryOp_Identical(\PhpParser\Node\Expr\BinaryOp\Identical $node) {}

        protected function pExpr_BinaryOp_NotIdentical(\PhpParser\Node\Expr\BinaryOp\NotIdentical $node) {}

        protected function pExpr_BinaryOp_Spaceship(\PhpParser\Node\Expr\BinaryOp\Spaceship $node) {}

        protected function pExpr_BinaryOp_Greater(\PhpParser\Node\Expr\BinaryOp\Greater $node) {}

        protected function pExpr_BinaryOp_GreaterOrEqual(\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual $node) {}

        protected function pExpr_BinaryOp_Smaller(\PhpParser\Node\Expr\BinaryOp\Smaller $node) {}

        protected function pExpr_BinaryOp_SmallerOrEqual(\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual $node) {}

        protected function pExpr_BinaryOp_Coalesce(\PhpParser\Node\Expr\BinaryOp\Coalesce $node) {}

        protected function pExpr_Instanceof(\PhpParser\Node\Expr\Instanceof_ $node) {}

        protected function pExpr_BooleanNot(\PhpParser\Node\Expr\BooleanNot $node) {}

        protected function pExpr_BitwiseNot(\PhpParser\Node\Expr\BitwiseNot $node) {}

        protected function pExpr_UnaryMinus(\PhpParser\Node\Expr\UnaryMinus $node) {}

        protected function pExpr_UnaryPlus(\PhpParser\Node\Expr\UnaryPlus $node) {}

        protected function pExpr_PreInc(\PhpParser\Node\Expr\PreInc $node) {}

        protected function pExpr_PreDec(\PhpParser\Node\Expr\PreDec $node) {}

        protected function pExpr_PostInc(\PhpParser\Node\Expr\PostInc $node) {}

        protected function pExpr_PostDec(\PhpParser\Node\Expr\PostDec $node) {}

        protected function pExpr_ErrorSuppress(\PhpParser\Node\Expr\ErrorSuppress $node) {}

        protected function pExpr_YieldFrom(\PhpParser\Node\Expr\YieldFrom $node) {}

        protected function pExpr_Print(\PhpParser\Node\Expr\Print_ $node) {}

        protected function pExpr_Cast_Int(\PhpParser\Node\Expr\Cast\Int_ $node) {}

        protected function pExpr_Cast_Double(\PhpParser\Node\Expr\Cast\Double $node) {}

        protected function pExpr_Cast_String(\PhpParser\Node\Expr\Cast\String_ $node) {}

        protected function pExpr_Cast_Array(\PhpParser\Node\Expr\Cast\Array_ $node) {}

        protected function pExpr_Cast_Object(\PhpParser\Node\Expr\Cast\Object_ $node) {}

        protected function pExpr_Cast_Bool(\PhpParser\Node\Expr\Cast\Bool_ $node) {}

        protected function pExpr_Cast_Unset(\PhpParser\Node\Expr\Cast\Unset_ $node) {}

        protected function pExpr_FuncCall(\PhpParser\Node\Expr\FuncCall $node) {}

        protected function pExpr_MethodCall(\PhpParser\Node\Expr\MethodCall $node) {}

        protected function pExpr_NullsafeMethodCall(\PhpParser\Node\Expr\NullsafeMethodCall $node) {}

        protected function pExpr_StaticCall(\PhpParser\Node\Expr\StaticCall $node) {}

        protected function pExpr_Empty(\PhpParser\Node\Expr\Empty_ $node) {}

        protected function pExpr_Isset(\PhpParser\Node\Expr\Isset_ $node) {}

        protected function pExpr_Eval(\PhpParser\Node\Expr\Eval_ $node) {}

        protected function pExpr_Include(\PhpParser\Node\Expr\Include_ $node) {}

        protected function pExpr_List(\PhpParser\Node\Expr\List_ $node) {}

        protected function pExpr_Error(\PhpParser\Node\Expr\Error $node) {}

        protected function pExpr_Variable(\PhpParser\Node\Expr\Variable $node) {}

        protected function pExpr_Array(\PhpParser\Node\Expr\Array_ $node) {}

        protected function pExpr_ArrayItem(\PhpParser\Node\Expr\ArrayItem $node) {}

        protected function pExpr_ArrayDimFetch(\PhpParser\Node\Expr\ArrayDimFetch $node) {}

        protected function pExpr_ConstFetch(\PhpParser\Node\Expr\ConstFetch $node) {}

        protected function pExpr_ClassConstFetch(\PhpParser\Node\Expr\ClassConstFetch $node) {}

        protected function pExpr_PropertyFetch(\PhpParser\Node\Expr\PropertyFetch $node) {}

        protected function pExpr_NullsafePropertyFetch(\PhpParser\Node\Expr\NullsafePropertyFetch $node) {}

        protected function pExpr_StaticPropertyFetch(\PhpParser\Node\Expr\StaticPropertyFetch $node) {}

        protected function pExpr_ShellExec(\PhpParser\Node\Expr\ShellExec $node) {}

        protected function pExpr_Closure(\PhpParser\Node\Expr\Closure $node) {}

        protected function pExpr_Match(\PhpParser\Node\Expr\Match_ $node) {}

        protected function pMatchArm(\PhpParser\Node\MatchArm $node) {}

        protected function pExpr_ArrowFunction(\PhpParser\Node\Expr\ArrowFunction $node) {}

        protected function pExpr_ClosureUse(\PhpParser\Node\Expr\ClosureUse $node) {}

        protected function pExpr_New(\PhpParser\Node\Expr\New_ $node) {}

        protected function pExpr_Clone(\PhpParser\Node\Expr\Clone_ $node) {}

        protected function pExpr_Ternary(\PhpParser\Node\Expr\Ternary $node) {}

        protected function pExpr_Exit(\PhpParser\Node\Expr\Exit_ $node) {}

        protected function pExpr_Throw(\PhpParser\Node\Expr\Throw_ $node) {}

        protected function pExpr_Yield(\PhpParser\Node\Expr\Yield_ $node) {}

        protected function pStmt_Namespace(\PhpParser\Node\Stmt\Namespace_ $node) {}

        protected function pStmt_Use(\PhpParser\Node\Stmt\Use_ $node) {}

        protected function pStmt_GroupUse(\PhpParser\Node\Stmt\GroupUse $node) {}

        protected function pStmt_UseUse(\PhpParser\Node\Stmt\UseUse $node) {}

        protected function pUseType($type) {}

        protected function pStmt_Interface(\PhpParser\Node\Stmt\Interface_ $node) {}

        protected function pStmt_Class(\PhpParser\Node\Stmt\Class_ $node) {}

        protected function pStmt_Trait(\PhpParser\Node\Stmt\Trait_ $node) {}

        protected function pStmt_TraitUse(\PhpParser\Node\Stmt\TraitUse $node) {}

        protected function pStmt_TraitUseAdaptation_Precedence(\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence $node) {}

        protected function pStmt_TraitUseAdaptation_Alias(\PhpParser\Node\Stmt\TraitUseAdaptation\Alias $node) {}

        protected function pStmt_Property(\PhpParser\Node\Stmt\Property $node) {}

        protected function pStmt_PropertyProperty(\PhpParser\Node\Stmt\PropertyProperty $node) {}

        protected function pStmt_ClassMethod(\PhpParser\Node\Stmt\ClassMethod $node) {}

        protected function pStmt_ClassConst(\PhpParser\Node\Stmt\ClassConst $node) {}

        protected function pStmt_Function(\PhpParser\Node\Stmt\Function_ $node) {}

        protected function pStmt_Const(\PhpParser\Node\Stmt\Const_ $node) {}

        protected function pStmt_Declare(\PhpParser\Node\Stmt\Declare_ $node) {}

        protected function pStmt_DeclareDeclare(\PhpParser\Node\Stmt\DeclareDeclare $node) {}

        protected function pStmt_If(\PhpParser\Node\Stmt\If_ $node) {}

        protected function pStmt_ElseIf(\PhpParser\Node\Stmt\ElseIf_ $node) {}

        protected function pStmt_Else(\PhpParser\Node\Stmt\Else_ $node) {}

        protected function pStmt_For(\PhpParser\Node\Stmt\For_ $node) {}

        protected function pStmt_Foreach(\PhpParser\Node\Stmt\Foreach_ $node) {}

        protected function pStmt_While(\PhpParser\Node\Stmt\While_ $node) {}

        protected function pStmt_Do(\PhpParser\Node\Stmt\Do_ $node) {}

        protected function pStmt_Switch(\PhpParser\Node\Stmt\Switch_ $node) {}

        protected function pStmt_Case(\PhpParser\Node\Stmt\Case_ $node) {}

        protected function pStmt_TryCatch(\PhpParser\Node\Stmt\TryCatch $node) {}

        protected function pStmt_Catch(\PhpParser\Node\Stmt\Catch_ $node) {}

        protected function pStmt_Finally(\PhpParser\Node\Stmt\Finally_ $node) {}

        protected function pStmt_Break(\PhpParser\Node\Stmt\Break_ $node) {}

        protected function pStmt_Continue(\PhpParser\Node\Stmt\Continue_ $node) {}

        protected function pStmt_Return(\PhpParser\Node\Stmt\Return_ $node) {}

        protected function pStmt_Throw(\PhpParser\Node\Stmt\Throw_ $node) {}

        protected function pStmt_Label(\PhpParser\Node\Stmt\Label $node) {}

        protected function pStmt_Goto(\PhpParser\Node\Stmt\Goto_ $node) {}

        protected function pStmt_Expression(\PhpParser\Node\Stmt\Expression $node) {}

        protected function pStmt_Echo(\PhpParser\Node\Stmt\Echo_ $node) {}

        protected function pStmt_Static(\PhpParser\Node\Stmt\Static_ $node) {}

        protected function pStmt_Global(\PhpParser\Node\Stmt\Global_ $node) {}

        protected function pStmt_StaticVar(\PhpParser\Node\Stmt\StaticVar $node) {}

        protected function pStmt_Unset(\PhpParser\Node\Stmt\Unset_ $node) {}

        protected function pStmt_InlineHTML(\PhpParser\Node\Stmt\InlineHTML $node) {}

        protected function pStmt_HaltCompiler(\PhpParser\Node\Stmt\HaltCompiler $node) {}

        protected function pStmt_Nop(\PhpParser\Node\Stmt\Nop $node) {}

        protected function pClassCommon(\PhpParser\Node\Stmt\Class_ $node, $afterClassToken) {}

        protected function pObjectProperty($node) {}

        protected function pEncapsList(array $encapsList, $quote) {}

        protected function pSingleQuotedString(string $string) {}

        protected function escapeString($string, $quote) {}

        protected function containsEndLabel($string, $label, $atStart = true, $atEnd = true) {}

        protected function encapsedContainsEndLabel(array $parts, $label) {}

        protected function pDereferenceLhs(\PhpParser\Node $node) {}

        protected function pCallLhs(\PhpParser\Node $node) {}

        protected function pNewVariable(\PhpParser\Node $node) {}

        /**
         * @param Node[] $nodes
         * @return bool
         */
        private function hasNodeWithComments(array $nodes) {}

        private function pMaybeMultiline(array $nodes, bool $trailingComma = false) {}

        private function pAttrGroups(array $nodes, bool $inline = false): string {}

    }
}

namespace PhpParser
{

    interface Builder
    {
        /**
         * Returns the built node.
         *
         * @return Node The built node
         */
        public function getNode(): \PhpParser\Node;

    }
}

namespace PhpParser
{
    use PhpParser\Node\Arg;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Expr\BinaryOp\Concat;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;
    use PhpParser\Node\Scalar\String_;
    use PhpParser\Node\Stmt\Use_;

    class BuilderFactory
    {
        /**
         * Creates a namespace builder.
         *
         * @param null|string|Node\Name $name Name of the namespace
         *
         * @return Builder\Namespace_ The created namespace builder
         */
        public function namespace($name): \PhpParser\Builder\Namespace_ {}

        /**
         * Creates a class builder.
         *
         * @param string $name Name of the class
         *
         * @return Builder\Class_ The created class builder
         */
        public function class(string $name): \PhpParser\Builder\Class_ {}

        /**
         * Creates an interface builder.
         *
         * @param string $name Name of the interface
         *
         * @return Builder\Interface_ The created interface builder
         */
        public function interface(string $name): \PhpParser\Builder\Interface_ {}

        /**
         * Creates a trait builder.
         *
         * @param string $name Name of the trait
         *
         * @return Builder\Trait_ The created trait builder
         */
        public function trait(string $name): \PhpParser\Builder\Trait_ {}

        /**
         * Creates a trait use builder.
         *
         * @param Node\Name|string ...$traits Trait names
         *
         * @return Builder\TraitUse The create trait use builder
         */
        public function useTrait(...$traits): \PhpParser\Builder\TraitUse {}

        /**
         * Creates a trait use adaptation builder.
         *
         * @param Node\Name|string|null  $trait  Trait name
         * @param Node\Identifier|string $method Method name
         *
         * @return Builder\TraitUseAdaptation The create trait use adaptation builder
         */
        public function traitUseAdaptation($trait, $method = null): \PhpParser\Builder\TraitUseAdaptation {}

        /**
         * Creates a method builder.
         *
         * @param string $name Name of the method
         *
         * @return Builder\Method The created method builder
         */
        public function method(string $name): \PhpParser\Builder\Method {}

        /**
         * Creates a parameter builder.
         *
         * @param string $name Name of the parameter
         *
         * @return Builder\Param The created parameter builder
         */
        public function param(string $name): \PhpParser\Builder\Param {}

        /**
         * Creates a property builder.
         *
         * @param string $name Name of the property
         *
         * @return Builder\Property The created property builder
         */
        public function property(string $name): \PhpParser\Builder\Property {}

        /**
         * Creates a function builder.
         *
         * @param string $name Name of the function
         *
         * @return Builder\Function_ The created function builder
         */
        public function function(string $name): \PhpParser\Builder\Function_ {}

        /**
         * Creates a namespace/class use builder.
         *
         * @param Node\Name|string $name Name of the entity (namespace or class) to alias
         *
         * @return Builder\Use_ The created use builder
         */
        public function use($name): \PhpParser\Builder\Use_ {}

        /**
         * Creates a function use builder.
         *
         * @param Node\Name|string $name Name of the function to alias
         *
         * @return Builder\Use_ The created use function builder
         */
        public function useFunction($name): \PhpParser\Builder\Use_ {}

        /**
         * Creates a constant use builder.
         *
         * @param Node\Name|string $name Name of the const to alias
         *
         * @return Builder\Use_ The created use const builder
         */
        public function useConst($name): \PhpParser\Builder\Use_ {}

        /**
         * Creates node a for a literal value.
         *
         * @param Expr|bool|null|int|float|string|array $value $value
         *
         * @return Expr
         */
        public function val($value): \PhpParser\Node\Expr {}

        /**
         * Creates variable node.
         *
         * @param string|Expr $name Name
         *
         * @return Expr\Variable
         */
        public function var($name): \PhpParser\Node\Expr\Variable {}

        /**
         * Normalizes an argument list.
         *
         * Creates Arg nodes for all arguments and converts literal values to expressions.
         *
         * @param array $args List of arguments to normalize
         *
         * @return Arg[]
         */
        public function args(array $args): array {}

        /**
         * Creates a function call node.
         *
         * @param string|Name|Expr $name Function name
         * @param array            $args Function arguments
         *
         * @return Expr\FuncCall
         */
        public function funcCall($name, array $args = [/** value is missing */]): \PhpParser\Node\Expr\FuncCall {}

        /**
         * Creates a method call node.
         *
         * @param Expr                   $var  Variable the method is called on
         * @param string|Identifier|Expr $name Method name
         * @param array                  $args Method arguments
         *
         * @return Expr\MethodCall
         */
        public function methodCall(\PhpParser\Node\Expr $var, $name, array $args = [/** value is missing */]): \PhpParser\Node\Expr\MethodCall {}

        /**
         * Creates a static method call node.
         *
         * @param string|Name|Expr       $class Class name
         * @param string|Identifier|Expr $name  Method name
         * @param array                  $args  Method arguments
         *
         * @return Expr\StaticCall
         */
        public function staticCall($class, $name, array $args = [/** value is missing */]): \PhpParser\Node\Expr\StaticCall {}

        /**
         * Creates an object creation node.
         *
         * @param string|Name|Expr $class Class name
         * @param array            $args  Constructor arguments
         *
         * @return Expr\New_
         */
        public function new($class, array $args = [/** value is missing */]): \PhpParser\Node\Expr\New_ {}

        /**
         * Creates a constant fetch node.
         *
         * @param string|Name $name Constant name
         *
         * @return Expr\ConstFetch
         */
        public function constFetch($name): \PhpParser\Node\Expr\ConstFetch {}

        /**
         * Creates a property fetch node.
         *
         * @param Expr                   $var  Variable holding object
         * @param string|Identifier|Expr $name Property name
         *
         * @return Expr\PropertyFetch
         */
        public function propertyFetch(\PhpParser\Node\Expr $var, $name): \PhpParser\Node\Expr\PropertyFetch {}

        /**
         * Creates a class constant fetch node.
         *
         * @param string|Name|Expr  $class Class name
         * @param string|Identifier $name  Constant name
         *
         * @return Expr\ClassConstFetch
         */
        public function classConstFetch($class, $name): \PhpParser\Node\Expr\ClassConstFetch {}

        /**
         * Creates nested Concat nodes from a list of expressions.
         *
         * @param Expr|string ...$exprs Expressions or literal strings
         *
         * @return Concat
         */
        public function concat(...$exprs): \PhpParser\Node\Expr\BinaryOp\Concat {}

        /**
         * @param string|Expr $expr
         * @return Expr
         */
        private function normalizeStringExpr($expr): \PhpParser\Node\Expr {}

    }
}

namespace PhpParser
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;
    use PhpParser\Node\NullableType;
    use PhpParser\Node\Scalar;
    use PhpParser\Node\Stmt;
    use PhpParser\Node\UnionType;

    /**
     * This class defines helpers used in the implementation of builders. Don't use it directly.
     *
     * @internal
     */
    final class BuilderHelpers
    {
        /**
         * Normalizes a node: Converts builder objects to nodes.
         *
         * @param Node|Builder $node The node to normalize
         *
         * @return Node The normalized node
         */
        public static function normalizeNode($node): \PhpParser\Node {}

        /**
         * Normalizes a node to a statement.
         *
         * Expressions are wrapped in a Stmt\Expression node.
         *
         * @param Node|Builder $node The node to normalize
         *
         * @return Stmt The normalized statement node
         */
        public static function normalizeStmt($node): \PhpParser\Node\Stmt {}

        /**
         * Normalizes strings to Identifier.
         *
         * @param string|Identifier $name The identifier to normalize
         *
         * @return Identifier The normalized identifier
         */
        public static function normalizeIdentifier($name): \PhpParser\Node\Identifier {}

        /**
         * Normalizes strings to Identifier, also allowing expressions.
         *
         * @param string|Identifier|Expr $name The identifier to normalize
         *
         * @return Identifier|Expr The normalized identifier or expression
         */
        public static function normalizeIdentifierOrExpr($name) {}

        /**
         * Normalizes a name: Converts string names to Name nodes.
         *
         * @param Name|string $name The name to normalize
         *
         * @return Name The normalized name
         */
        public static function normalizeName($name): \PhpParser\Node\Name {}

        /**
         * Normalizes a name: Converts string names to Name nodes, while also allowing expressions.
         *
         * @param Expr|Name|string $name The name to normalize
         *
         * @return Name|Expr The normalized name or expression
         */
        public static function normalizeNameOrExpr($name) {}

        /**
         * Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.
         *
         * @param Expr|Name|string $name      The name to normalize
         * @param bool             $allowExpr Whether to also allow expressions
         *
         * @return Name|Expr The normalized name, or expression (if allowed)
         */
        private static function normalizeNameCommon($name, bool $allowExpr) {}

        /**
         * Normalizes a type: Converts plain-text type names into proper AST representation.
         *
         * In particular, builtin types become Identifiers, custom types become Names and nullables
         * are wrapped in NullableType nodes.
         *
         * @param string|Name|Identifier|NullableType|UnionType $type The type to normalize
         *
         * @return Name|Identifier|NullableType|UnionType The normalized type
         */
        public static function normalizeType($type) {}

        /**
         * Normalizes a value: Converts nulls, booleans, integers,
         * floats, strings and arrays into their respective nodes
         *
         * @param Node\Expr|bool|null|int|float|string|array $value The value to normalize
         *
         * @return Expr The normalized value
         */
        public static function normalizeValue($value): \PhpParser\Node\Expr {}

        /**
         * Normalizes a doc comment: Converts plain strings to PhpParser\Comment\Doc.
         *
         * @param Comment\Doc|string $docComment The doc comment to normalize
         *
         * @return Comment\Doc The normalized doc comment
         */
        public static function normalizeDocComment($docComment): \PhpParser\Comment\Doc {}

        /**
         * Adds a modifier and returns new modifier bitmask.
         *
         * @param int $modifiers Existing modifiers
         * @param int $modifier  Modifier to set
         *
         * @return int New modifiers
         */
        public static function addModifier(int $modifiers, int $modifier): int {}

    }
}

namespace PhpParser
{

    class Comment
    {
        protected $text;

        protected $startLine;

        protected $startFilePos;

        protected $startTokenPos;

        protected $endLine;

        protected $endFilePos;

        protected $endTokenPos;

        /**
         * Constructs a comment node.
         *
         * @param string $text          Comment text (including comment delimiters like /*)
         * @param int    $startLine     Line number the comment started on
         * @param int    $startFilePos  File offset the comment started on
         * @param int    $startTokenPos Token offset the comment started on
         */
        public function __construct(string $text, ?int $startLine = null, ?int $startFilePos = null, ?int $startTokenPos = null, ?int $endLine = null, ?int $endFilePos = null, ?int $endTokenPos = null) {}

        /**
         * Gets the comment text.
         *
         * @return string The comment text (including comment delimiters like /*)
         */
        public function getText(): string {}

        /**
         * Gets the line number the comment started on.
         *
         * @return int Line number (or -1 if not available)
         */
        public function getStartLine(): int {}

        /**
         * Gets the file offset the comment started on.
         *
         * @return int File offset (or -1 if not available)
         */
        public function getStartFilePos(): int {}

        /**
         * Gets the token offset the comment started on.
         *
         * @return int Token offset (or -1 if not available)
         */
        public function getStartTokenPos(): int {}

        /**
         * Gets the line number the comment ends on.
         *
         * @return int Line number (or -1 if not available)
         */
        public function getEndLine(): int {}

        /**
         * Gets the file offset the comment ends on.
         *
         * @return int File offset (or -1 if not available)
         */
        public function getEndFilePos(): int {}

        /**
         * Gets the token offset the comment ends on.
         *
         * @return int Token offset (or -1 if not available)
         */
        public function getEndTokenPos(): int {}

        /**
         * Gets the line number the comment started on.
         *
         * @deprecated Use getStartLine() instead
         *
         * @return int Line number
         */
        public function getLine(): int {}

        /**
         * Gets the file offset the comment started on.
         *
         * @deprecated Use getStartFilePos() instead
         *
         * @return int File offset
         */
        public function getFilePos(): int {}

        /**
         * Gets the token offset the comment started on.
         *
         * @deprecated Use getStartTokenPos() instead
         *
         * @return int Token offset
         */
        public function getTokenPos(): int {}

        /**
         * Gets the comment text.
         *
         * @return string The comment text (including comment delimiters like /*)
         */
        public function __toString(): string {}

        /**
         * Gets the reformatted comment text.
         *
         * "Reformatted" here means that we try to clean up the whitespace at the
         * starts of the lines. This is necessary because we receive the comments
         * without trailing whitespace on the first line, but with trailing whitespace
         * on all subsequent lines.
         *
         * @return mixed|string
         */
        public function getReformattedText() {}

        /**
         * Get length of shortest whitespace prefix (at the start of a line).
         *
         * If there is a line with no prefix whitespace, 0 is a valid return value.
         *
         * @param string $str String to check
         * @return int Length in characters. Tabs count as single characters.
         */
        private function getShortestWhitespacePrefixLen(string $str): int {}

        /**
         * @return       array
         * @psalm-return array{nodeType:string, text:mixed, line:mixed, filePos:mixed}
         */
        public function jsonSerialize(): array {}

    }
}

namespace PhpParser
{

    class ConstExprEvaluationException extends \Exception
    {
    }
}

namespace PhpParser
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Scalar;

    /**
     * Evaluates constant expressions.
     *
     * This evaluator is able to evaluate all constant expressions (as defined by PHP), which can be
     * evaluated without further context. If a subexpression is not of this type, a user-provided
     * fallback evaluator is invoked. To support all constant expressions that are also supported by
     * PHP (and not already handled by this class), the fallback evaluator must be able to handle the
     * following node types:
     *
     *  * All Scalar\MagicConst\* nodes.
     *  * Expr\ConstFetch nodes. Only null/false/true are already handled by this class.
     *  * Expr\ClassConstFetch nodes.
     *
     * The fallback evaluator should throw ConstExprEvaluationException for nodes it cannot evaluate.
     *
     * The evaluation is dependent on runtime configuration in two respects: Firstly, floating
     * point to string conversions are affected by the precision ini setting. Secondly, they are also
     * affected by the LC_NUMERIC locale.
     */
    class ConstExprEvaluator
    {
        private $fallbackEvaluator;

        /**
         * Create a constant expression evaluator.
         *
         * The provided fallback evaluator is invoked whenever a subexpression cannot be evaluated. See
         * class doc comment for more information.
         *
         * @param callable|null $fallbackEvaluator To call if subexpression cannot be evaluated
         */
        public function __construct(?callable $fallbackEvaluator = null) {}

        /**
         * Silently evaluates a constant expression into a PHP value.
         *
         * Thrown Errors, warnings or notices will be converted into a ConstExprEvaluationException.
         * The original source of the exception is available through getPrevious().
         *
         * If some part of the expression cannot be evaluated, the fallback evaluator passed to the
         * constructor will be invoked. By default, if no fallback is provided, an exception of type
         * ConstExprEvaluationException is thrown.
         *
         * See class doc comment for caveats and limitations.
         *
         * @param Expr $expr Constant expression to evaluate
         * @return mixed Result of evaluation
         *
         * @throws ConstExprEvaluationException if the expression cannot be evaluated or an error occurred
         */
        public function evaluateSilently(\PhpParser\Node\Expr $expr) {}

        /**
         * Directly evaluates a constant expression into a PHP value.
         *
         * May generate Error exceptions, warnings or notices. Use evaluateSilently() to convert these
         * into a ConstExprEvaluationException.
         *
         * If some part of the expression cannot be evaluated, the fallback evaluator passed to the
         * constructor will be invoked. By default, if no fallback is provided, an exception of type
         * ConstExprEvaluationException is thrown.
         *
         * See class doc comment for caveats and limitations.
         *
         * @param Expr $expr Constant expression to evaluate
         * @return mixed Result of evaluation
         *
         * @throws ConstExprEvaluationException if the expression cannot be evaluated
         */
        public function evaluateDirectly(\PhpParser\Node\Expr $expr) {}

        private function evaluate(\PhpParser\Node\Expr $expr) {}

        private function evaluateArray(\PhpParser\Node\Expr\Array_ $expr) {}

        private function evaluateTernary(\PhpParser\Node\Expr\Ternary $expr) {}

        private function evaluateBinaryOp(\PhpParser\Node\Expr\BinaryOp $expr) {}

        private function evaluateConstFetch(\PhpParser\Node\Expr\ConstFetch $expr) {}

    }
}

namespace PhpParser
{

    class Error extends \RuntimeException
    {
        protected $rawMessage;

        protected $attributes;

        /**
         * Creates an Exception signifying a parse error.
         *
         * @param string    $message    Error message
         * @param array|int $attributes Attributes of node/token where error occurred
         *                              (or start line of error -- deprecated)
         */
        public function __construct(string $message, $attributes = [/** value is missing */]) {}

        /**
         * Gets the error message
         *
         * @return string Error message
         */
        public function getRawMessage(): string {}

        /**
         * Gets the line the error starts in.
         *
         * @return int Error start line
         */
        public function getStartLine(): int {}

        /**
         * Gets the line the error ends in.
         *
         * @return int Error end line
         */
        public function getEndLine(): int {}

        /**
         * Gets the attributes of the node/token the error occurred at.
         *
         * @return array
         */
        public function getAttributes(): array {}

        /**
         * Sets the attributes of the node/token the error occurred at.
         *
         * @param array $attributes
         */
        public function setAttributes(array $attributes) {}

        /**
         * Sets the line of the PHP file the error occurred in.
         *
         * @param string $message Error message
         */
        public function setRawMessage(string $message) {}

        /**
         * Sets the line the error starts in.
         *
         * @param int $line Error start line
         */
        public function setStartLine(int $line) {}

        /**
         * Returns whether the error has start and end column information.
         *
         * For column information enable the startFilePos and endFilePos in the lexer options.
         *
         * @return bool
         */
        public function hasColumnInfo(): bool {}

        /**
         * Gets the start column (1-based) into the line where the error started.
         *
         * @param string $code Source code of the file
         * @return int
         */
        public function getStartColumn(string $code): int {}

        /**
         * Gets the end column (1-based) into the line where the error ended.
         *
         * @param string $code Source code of the file
         * @return int
         */
        public function getEndColumn(string $code): int {}

        /**
         * Formats message including line and column information.
         *
         * @param string $code Source code associated with the error, for calculation of the columns
         *
         * @return string Formatted message
         */
        public function getMessageWithColumnInfo(string $code): string {}

        /**
         * Converts a file offset into a column.
         *
         * @param string $code Source code that $pos indexes into
         * @param int    $pos  0-based position in $code
         *
         * @return int 1-based column (relative to start of line)
         */
        private function toColumn(string $code, int $pos): int {}

        /**
         * Updates the exception message after a change to rawMessage or rawLine.
         */
        protected function updateMessage() {}

    }
}

namespace PhpParser
{

    interface ErrorHandler
    {
        /**
         * Handle an error generated during lexing, parsing or some other operation.
         *
         * @param Error $error The error that needs to be handled
         */
        public function handleError(\PhpParser\Error $error);

    }
}

namespace PhpParser
{

    class JsonDecoder
    {
        /** @var \ReflectionClass[] Node type to reflection class map */
        private $reflectionClassCache;

        public function decode(string $json) {}

        private function decodeRecursive($value) {}

        private function decodeArray(array $array): array {}

        private function decodeNode(array $value): \PhpParser\Node {}

        private function decodeComment(array $value): \PhpParser\Comment {}

        private function reflectionClassFromNodeType(string $nodeType): \ReflectionClass {}

        private function classNameFromNodeType(string $nodeType): string {}

    }
}

namespace PhpParser
{
    use PhpParser\Parser\Tokens;

    class Lexer
    {
        protected $code;

        protected $tokens;

        protected $pos;

        protected $line;

        protected $filePos;

        protected $prevCloseTagHasNewline;

        protected $tokenMap;

        protected $dropTokens;

        protected $identifierTokens;

        private $attributeStartLineUsed;

        private $attributeEndLineUsed;

        private $attributeStartTokenPosUsed;

        private $attributeEndTokenPosUsed;

        private $attributeStartFilePosUsed;

        private $attributeEndFilePosUsed;

        private $attributeCommentsUsed;

        /**
         * Creates a Lexer.
         *
         * @param array $options Options array. Currently only the 'usedAttributes' option is supported,
         *                       which is an array of attributes to add to the AST nodes. Possible
         *                       attributes are: 'comments', 'startLine', 'endLine', 'startTokenPos',
         *                       'endTokenPos', 'startFilePos', 'endFilePos'. The option defaults to the
         *                       first three. For more info see getNextToken() docs.
         */
        public function __construct(array $options = [/** value is missing */]) {}

        /**
         * Initializes the lexer for lexing the provided source code.
         *
         * This function does not throw if lexing errors occur. Instead, errors may be retrieved using
         * the getErrors() method.
         *
         * @param string $code The source code to lex
         * @param ErrorHandler|null $errorHandler Error handler to use for lexing errors. Defaults to
         *                                        ErrorHandler\Throwing
         */
        public function startLexing(string $code, ?\PhpParser\ErrorHandler $errorHandler = null) {}

        private function handleInvalidCharacterRange($start, $end, $line, \PhpParser\ErrorHandler $errorHandler) {}

        /**
         * Check whether comment token is unterminated.
         *
         * @return bool
         */
        private function isUnterminatedComment($token): bool {}

        protected function postprocessTokens(\PhpParser\ErrorHandler $errorHandler) {}

        /**
         * Fetches the next token.
         *
         * The available attributes are determined by the 'usedAttributes' option, which can
         * be specified in the constructor. The following attributes are supported:
         *
         *  * 'comments'      => Array of PhpParser\Comment or PhpParser\Comment\Doc instances,
         *                       representing all comments that occurred between the previous
         *                       non-discarded token and the current one.
         *  * 'startLine'     => Line in which the node starts.
         *  * 'endLine'       => Line in which the node ends.
         *  * 'startTokenPos' => Offset into the token array of the first token in the node.
         *  * 'endTokenPos'   => Offset into the token array of the last token in the node.
         *  * 'startFilePos'  => Offset into the code string of the first character that is part of the node.
         *  * 'endFilePos'    => Offset into the code string of the last character that is part of the node.
         *
         * @param mixed $value           Variable to store token content in
         * @param mixed $startAttributes Variable to store start attributes in
         * @param mixed $endAttributes   Variable to store end attributes in
         *
         * @return int Token id
         */
        public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null): int {}

        /**
         * Returns the token array for current code.
         *
         * The token array is in the same format as provided by the
         * token_get_all() function and does not discard tokens (i.e.
         * whitespace and comments are included). The token position
         * attributes are against this token array.
         *
         * @return array Array of tokens in token_get_all() format
         */
        public function getTokens(): array {}

        /**
         * Handles __halt_compiler() by returning the text after it.
         *
         * @return string Remaining text
         */
        public function handleHaltCompiler(): string {}

        private function defineCompatibilityTokens() {}

        /**
         * Creates the token map.
         *
         * The token map maps the PHP internal token identifiers
         * to the identifiers used by the Parser. Additionally it
         * maps T_OPEN_TAG_WITH_ECHO to T_ECHO and T_CLOSE_TAG to ';'.
         *
         * @return array The token map
         */
        protected function createTokenMap(): array {}

        private function createIdentifierTokenMap(): array {}

    }
}

namespace PhpParser
{
    use PhpParser\Node\Name;
    use PhpParser\Node\Name\FullyQualified;
    use PhpParser\Node\Stmt;

    class NameContext
    {
        /** @var null|Name Current namespace */
        protected $namespace;

        /** @var Name[][] Map of format [aliasType => [aliasName => originalName]] */
        protected $aliases = [/** value is missing */];

        /** @var Name[][] Same as $aliases but preserving original case */
        protected $origAliases = [/** value is missing */];

        /** @var ErrorHandler Error handler */
        protected $errorHandler;

        /**
         * Create a name context.
         *
         * @param ErrorHandler $errorHandler Error handling used to report errors
         */
        public function __construct(\PhpParser\ErrorHandler $errorHandler) {}

        /**
         * Start a new namespace.
         *
         * This also resets the alias table.
         *
         * @param Name|null $namespace Null is the global namespace
         */
        public function startNamespace(?\PhpParser\Node\Name $namespace = null) {}

        /**
         * Add an alias / import.
         *
         * @param Name   $name        Original name
         * @param string $aliasName   Aliased name
         * @param int    $type        One of Stmt\Use_::TYPE_*
         * @param array  $errorAttrs Attributes to use to report an error
         */
        public function addAlias(\PhpParser\Node\Name $name, string $aliasName, int $type, array $errorAttrs = [/** value is missing */]) {}

        /**
         * Get current namespace.
         *
         * @return null|Name Namespace (or null if global namespace)
         */
        public function getNamespace() {}

        /**
         * Get resolved name.
         *
         * @param Name $name Name to resolve
         * @param int  $type One of Stmt\Use_::TYPE_{FUNCTION|CONSTANT}
         *
         * @return null|Name Resolved name, or null if static resolution is not possible
         */
        public function getResolvedName(\PhpParser\Node\Name $name, int $type) {}

        /**
         * Get resolved class name.
         *
         * @param Name $name Class ame to resolve
         *
         * @return Name Resolved name
         */
        public function getResolvedClassName(\PhpParser\Node\Name $name): \PhpParser\Node\Name {}

        /**
         * Get possible ways of writing a fully qualified name (e.g., by making use of aliases).
         *
         * @param string $name Fully-qualified name (without leading namespace separator)
         * @param int    $type One of Stmt\Use_::TYPE_*
         *
         * @return Name[] Possible representations of the name
         */
        public function getPossibleNames(string $name, int $type): array {}

        /**
         * Get shortest representation of this fully-qualified name.
         *
         * @param string $name Fully-qualified name (without leading namespace separator)
         * @param int    $type One of Stmt\Use_::TYPE_*
         *
         * @return Name Shortest representation
         */
        public function getShortName(string $name, int $type): \PhpParser\Node\Name {}

        private function resolveAlias(\PhpParser\Node\Name $name, $type) {}

        private function getNamespaceRelativeName(string $name, string $lcName, int $type) {}

        private function normalizeConstName(string $name) {}

    }
}

namespace PhpParser
{

    interface Node
    {
        /**
         * Gets the type of the node.
         *
         * @return string Type of the node
         */
        public function getType(): string;

        /**
         * Gets the names of the sub nodes.
         *
         * @return array Names of sub nodes
         */
        public function getSubNodeNames(): array;

        /**
         * Gets line the node started in (alias of getStartLine).
         *
         * @return int Start line (or -1 if not available)
         */
        public function getLine(): int;

        /**
         * Gets line the node started in.
         *
         * Requires the 'startLine' attribute to be enabled in the lexer (enabled by default).
         *
         * @return int Start line (or -1 if not available)
         */
        public function getStartLine(): int;

        /**
         * Gets the line the node ended in.
         *
         * Requires the 'endLine' attribute to be enabled in the lexer (enabled by default).
         *
         * @return int End line (or -1 if not available)
         */
        public function getEndLine(): int;

        /**
         * Gets the token offset of the first token that is part of this node.
         *
         * The offset is an index into the array returned by Lexer::getTokens().
         *
         * Requires the 'startTokenPos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int Token start position (or -1 if not available)
         */
        public function getStartTokenPos(): int;

        /**
         * Gets the token offset of the last token that is part of this node.
         *
         * The offset is an index into the array returned by Lexer::getTokens().
         *
         * Requires the 'endTokenPos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int Token end position (or -1 if not available)
         */
        public function getEndTokenPos(): int;

        /**
         * Gets the file offset of the first character that is part of this node.
         *
         * Requires the 'startFilePos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int File start position (or -1 if not available)
         */
        public function getStartFilePos(): int;

        /**
         * Gets the file offset of the last character that is part of this node.
         *
         * Requires the 'endFilePos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int File end position (or -1 if not available)
         */
        public function getEndFilePos(): int;

        /**
         * Gets all comments directly preceding this node.
         *
         * The comments are also available through the "comments" attribute.
         *
         * @return Comment[]
         */
        public function getComments(): array;

        /**
         * Gets the doc comment of the node.
         *
         * @return null|Comment\Doc Doc comment object or null
         */
        public function getDocComment();

        /**
         * Sets the doc comment of the node.
         *
         * This will either replace an existing doc comment or add it to the comments array.
         *
         * @param Comment\Doc $docComment Doc comment to set
         */
        public function setDocComment(\PhpParser\Comment\Doc $docComment);

        /**
         * Sets an attribute on a node.
         *
         * @param string $key
         * @param mixed  $value
         */
        public function setAttribute(string $key, $value);

        /**
         * Returns whether an attribute exists.
         *
         * @param string $key
         *
         * @return bool
         */
        public function hasAttribute(string $key): bool;

        /**
         * Returns the value of an attribute.
         *
         * @param string $key
         * @param mixed  $default
         *
         * @return mixed
         */
        public function getAttribute(string $key, $default = null);

        /**
         * Returns all the attributes of this node.
         *
         * @return array
         */
        public function getAttributes(): array;

        /**
         * Replaces all the attributes of this node.
         *
         * @param array $attributes
         */
        public function setAttributes(array $attributes);

    }
}

namespace PhpParser
{

    abstract class NodeAbstract
    {
        protected $attributes;

        /**
         * Creates a Node.
         *
         * @param array $attributes Array of attributes
         */
        public function __construct(array $attributes = [/** value is missing */]) {}

        /**
         * Gets line the node started in (alias of getStartLine).
         *
         * @return int Start line (or -1 if not available)
         */
        public function getLine(): int {}

        /**
         * Gets line the node started in.
         *
         * Requires the 'startLine' attribute to be enabled in the lexer (enabled by default).
         *
         * @return int Start line (or -1 if not available)
         */
        public function getStartLine(): int {}

        /**
         * Gets the line the node ended in.
         *
         * Requires the 'endLine' attribute to be enabled in the lexer (enabled by default).
         *
         * @return int End line (or -1 if not available)
         */
        public function getEndLine(): int {}

        /**
         * Gets the token offset of the first token that is part of this node.
         *
         * The offset is an index into the array returned by Lexer::getTokens().
         *
         * Requires the 'startTokenPos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int Token start position (or -1 if not available)
         */
        public function getStartTokenPos(): int {}

        /**
         * Gets the token offset of the last token that is part of this node.
         *
         * The offset is an index into the array returned by Lexer::getTokens().
         *
         * Requires the 'endTokenPos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int Token end position (or -1 if not available)
         */
        public function getEndTokenPos(): int {}

        /**
         * Gets the file offset of the first character that is part of this node.
         *
         * Requires the 'startFilePos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int File start position (or -1 if not available)
         */
        public function getStartFilePos(): int {}

        /**
         * Gets the file offset of the last character that is part of this node.
         *
         * Requires the 'endFilePos' attribute to be enabled in the lexer (DISABLED by default).
         *
         * @return int File end position (or -1 if not available)
         */
        public function getEndFilePos(): int {}

        /**
         * Gets all comments directly preceding this node.
         *
         * The comments are also available through the "comments" attribute.
         *
         * @return Comment[]
         */
        public function getComments(): array {}

        /**
         * Gets the doc comment of the node.
         *
         * @return null|Comment\Doc Doc comment object or null
         */
        public function getDocComment() {}

        /**
         * Sets the doc comment of the node.
         *
         * This will either replace an existing doc comment or add it to the comments array.
         *
         * @param Comment\Doc $docComment Doc comment to set
         */
        public function setDocComment(\PhpParser\Comment\Doc $docComment) {}

        public function setAttribute(string $key, $value) {}

        public function hasAttribute(string $key): bool {}

        public function getAttribute(string $key, $default = null) {}

        public function getAttributes(): array {}

        public function setAttributes(array $attributes) {}

        /**
         * @return array
         */
        public function jsonSerialize(): array {}

    }
}

namespace PhpParser
{
    use PhpParser\Node\Expr\Include_;
    use PhpParser\Node\Stmt\Class_;
    use PhpParser\Node\Stmt\GroupUse;
    use PhpParser\Node\Stmt\Use_;
    use PhpParser\Node\Stmt\UseUse;

    class NodeDumper
    {
        private $dumpComments;

        private $dumpPositions;

        private $code;

        /**
         * Constructs a NodeDumper.
         *
         * Supported options:
         *  * bool dumpComments: Whether comments should be dumped.
         *  * bool dumpPositions: Whether line/offset information should be dumped. To dump offset
         *                        information, the code needs to be passed to dump().
         *
         * @param array $options Options (see description)
         */
        public function __construct(array $options = [/** value is missing */]) {}

        /**
         * Dumps a node or array.
         *
         * @param array|Node  $node Node or array to dump
         * @param string|null $code Code corresponding to dumped AST. This only needs to be passed if
         *                          the dumpPositions option is enabled and the dumping of node offsets
         *                          is desired.
         *
         * @return string Dumped value
         */
        public function dump($node, ?string $code = null): string {}

        protected function dumpRecursive($node) {}

        protected function dumpFlags($flags) {}

        protected function dumpIncludeType($type) {}

        protected function dumpUseType($type) {}

        /**
         * Dump node position, if possible.
         *
         * @param Node $node Node for which to dump position
         *
         * @return string|null Dump of position, or null if position information not available
         */
        protected function dumpPosition(\PhpParser\Node $node) {}

        private function toColumn($code, $pos) {}

    }
}

namespace PhpParser
{
    use PhpParser\NodeVisitor\FindingVisitor;
    use PhpParser\NodeVisitor\FirstFindingVisitor;

    class NodeFinder
    {
        /**
         * Find all nodes satisfying a filter callback.
         *
         * @param Node|Node[] $nodes  Single node or array of nodes to search in
         * @param callable    $filter Filter callback: function(Node $node) : bool
         *
         * @return Node[] Found nodes satisfying the filter callback
         */
        public function find($nodes, callable $filter): array {}

        /**
         * Find all nodes that are instances of a certain class.
         *
         * @param Node|Node[] $nodes Single node or array of nodes to search in
         * @param string      $class Class name
         *
         * @return Node[] Found nodes (all instances of $class)
         */
        public function findInstanceOf($nodes, string $class): array {}

        /**
         * Find first node satisfying a filter callback.
         *
         * @param Node|Node[] $nodes  Single node or array of nodes to search in
         * @param callable    $filter Filter callback: function(Node $node) : bool
         *
         * @return null|Node Found node (or null if none found)
         */
        public function findFirst($nodes, callable $filter) {}

        /**
         * Find first node that is an instance of a certain class.
         *
         * @param Node|Node[] $nodes  Single node or array of nodes to search in
         * @param string      $class Class name
         *
         * @return null|Node Found node, which is an instance of $class (or null if none found)
         */
        public function findFirstInstanceOf($nodes, string $class) {}

    }
}

namespace PhpParser
{

    class NodeTraverser
    {
        /**
         * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CHILDREN, child nodes
         * of the current node will not be traversed for any visitors.
         *
         * For subsequent visitors enterNode() will still be called on the current
         * node and leaveNode() will also be invoked for the current node.
         */
        const DONT_TRAVERSE_CHILDREN = 1;

        /**
         * If NodeVisitor::enterNode() or NodeVisitor::leaveNode() returns
         * STOP_TRAVERSAL, traversal is aborted.
         *
         * The afterTraverse() method will still be invoked.
         */
        const STOP_TRAVERSAL = 2;

        /**
         * If NodeVisitor::leaveNode() returns REMOVE_NODE for a node that occurs
         * in an array, it will be removed from the array.
         *
         * For subsequent visitors leaveNode() will still be invoked for the
         * removed node.
         */
        const REMOVE_NODE = 3;

        /**
         * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CURRENT_AND_CHILDREN, child nodes
         * of the current node will not be traversed for any visitors.
         *
         * For subsequent visitors enterNode() will not be called as well.
         * leaveNode() will be invoked for visitors that has enterNode() method invoked.
         */
        const DONT_TRAVERSE_CURRENT_AND_CHILDREN = 4;

        /** @var NodeVisitor[] Visitors */
        protected $visitors = [/** value is missing */];

        /** @var bool Whether traversal should be stopped */
        protected $stopTraversal;

        public function __construct() {}

        /**
         * Adds a visitor.
         *
         * @param NodeVisitor $visitor Visitor to add
         */
        public function addVisitor(\PhpParser\NodeVisitor $visitor) {}

        /**
         * Removes an added visitor.
         *
         * @param NodeVisitor $visitor
         */
        public function removeVisitor(\PhpParser\NodeVisitor $visitor) {}

        /**
         * Traverses an array of nodes using the registered visitors.
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return Node[] Traversed array of nodes
         */
        public function traverse(array $nodes): array {}

        /**
         * Recursively traverse a node.
         *
         * @param Node $node Node to traverse.
         *
         * @return Node Result of traversal (may be original node or new one)
         */
        protected function traverseNode(\PhpParser\Node $node): \PhpParser\Node {}

        /**
         * Recursively traverse array (usually of nodes).
         *
         * @param array $nodes Array to traverse
         *
         * @return array Result of traversal (may be original array or changed one)
         */
        protected function traverseArray(array $nodes): array {}

        private function ensureReplacementReasonable($old, $new) {}

    }
}

namespace PhpParser
{

    interface NodeTraverserInterface
    {
        /**
         * Adds a visitor.
         *
         * @param NodeVisitor $visitor Visitor to add
         */
        public function addVisitor(\PhpParser\NodeVisitor $visitor);

        /**
         * Removes an added visitor.
         *
         * @param NodeVisitor $visitor
         */
        public function removeVisitor(\PhpParser\NodeVisitor $visitor);

        /**
         * Traverses an array of nodes using the registered visitors.
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return Node[] Traversed array of nodes
         */
        public function traverse(array $nodes): array;

    }
}

namespace PhpParser
{

    interface NodeVisitor
    {
        /**
         * Called once before traversal.
         *
         * Return value semantics:
         *  * null:      $nodes stays as-is
         *  * otherwise: $nodes is set to the return value
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return null|Node[] Array of nodes
         */
        public function beforeTraverse(array $nodes);

        /**
         * Called when entering a node.
         *
         * Return value semantics:
         *  * null
         *        => $node stays as-is
         *  * NodeTraverser::DONT_TRAVERSE_CHILDREN
         *        => Children of $node are not traversed. $node stays as-is
         *  * NodeTraverser::STOP_TRAVERSAL
         *        => Traversal is aborted. $node stays as-is
         *  * otherwise
         *        => $node is set to the return value
         *
         * @param Node $node Node
         *
         * @return null|int|Node Replacement node (or special return value)
         */
        public function enterNode(\PhpParser\Node $node);

        /**
         * Called when leaving a node.
         *
         * Return value semantics:
         *  * null
         *        => $node stays as-is
         *  * NodeTraverser::REMOVE_NODE
         *        => $node is removed from the parent array
         *  * NodeTraverser::STOP_TRAVERSAL
         *        => Traversal is aborted. $node stays as-is
         *  * array (of Nodes)
         *        => The return value is merged into the parent array (at the position of the $node)
         *  * otherwise
         *        => $node is set to the return value
         *
         * @param Node $node Node
         *
         * @return null|int|Node|Node[] Replacement node (or special return value)
         */
        public function leaveNode(\PhpParser\Node $node);

        /**
         * Called once after traversal.
         *
         * Return value semantics:
         *  * null:      $nodes stays as-is
         *  * otherwise: $nodes is set to the return value
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return null|Node[] Array of nodes
         */
        public function afterTraverse(array $nodes);

    }
}

namespace PhpParser
{

    /**
     * @codeCoverageIgnore
     */
    class NodeVisitorAbstract
    {
        public function beforeTraverse(array $nodes) {}

        public function enterNode(\PhpParser\Node $node) {}

        public function leaveNode(\PhpParser\Node $node) {}

        public function afterTraverse(array $nodes) {}

    }
}

namespace PhpParser
{

    interface Parser
    {
        /**
         * Parses PHP code into a node tree.
         *
         * @param string $code The source code to parse
         * @param ErrorHandler|null $errorHandler Error handler to use for lexer/parser errors, defaults
         *                                        to ErrorHandler\Throwing.
         *
         * @return Node\Stmt[]|null Array of statements (or null non-throwing error handler is used and
         *                          the parser was unable to recover from an error).
         */
        public function parse(string $code, ?\PhpParser\ErrorHandler $errorHandler = null);

    }
}

namespace PhpParser
{
    use PhpParser\Node\Expr;
    use PhpParser\Node\Expr\Cast\Double;
    use PhpParser\Node\Name;
    use PhpParser\Node\Param;
    use PhpParser\Node\Scalar\Encapsed;
    use PhpParser\Node\Scalar\LNumber;
    use PhpParser\Node\Scalar\String_;
    use PhpParser\Node\Stmt\Class_;
    use PhpParser\Node\Stmt\ClassConst;
    use PhpParser\Node\Stmt\ClassMethod;
    use PhpParser\Node\Stmt\Interface_;
    use PhpParser\Node\Stmt\Namespace_;
    use PhpParser\Node\Stmt\Property;
    use PhpParser\Node\Stmt\TryCatch;
    use PhpParser\Node\Stmt\UseUse;
    use PhpParser\Node\VarLikeIdentifier;

    abstract class ParserAbstract
    {
        const SYMBOL_NONE = null;

        /** @var int Size of $tokenToSymbol map */
        protected $tokenToSymbolMapSize;

        /** @var int Size of $action table */
        protected $actionTableSize;

        /** @var int Size of $goto table */
        protected $gotoTableSize;

        /** @var int Symbol number signifying an invalid token */
        protected $invalidSymbol;

        /** @var int Symbol number of error recovery token */
        protected $errorSymbol;

        /** @var int Action number signifying default action */
        protected $defaultAction;

        /** @var int Rule number signifying that an unexpected token was encountered */
        protected $unexpectedTokenRule;

        protected $YY2TBLSTATE;

        /** @var int Number of non-leaf states */
        protected $numNonLeafStates;

        /** @var int[] Map of lexer tokens to internal symbols */
        protected $tokenToSymbol;

        /** @var string[] Map of symbols to their names */
        protected $symbolToName;

        /** @var array Names of the production rules (only necessary for debugging) */
        protected $productions;

        /** @var int[] Map of states to a displacement into the $action table. The corresponding action for this
         *             state/symbol pair is $action[$actionBase[$state] + $symbol]. If $actionBase[$state] is 0, the
         action is defaulted, i.e. $actionDefault[$state] should be used instead. */
        protected $actionBase;

        /** @var int[] Table of actions. Indexed according to $actionBase comment. */
        protected $action;

        /** @var int[] Table indexed analogously to $action. If $actionCheck[$actionBase[$state] + $symbol] != $symbol
         *             then the action is defaulted, i.e. $actionDefault[$state] should be used instead. */
        protected $actionCheck;

        /** @var int[] Map of states to their default action */
        protected $actionDefault;

        /** @var callable[] Semantic action callbacks */
        protected $reduceCallbacks;

        /** @var int[] Map of non-terminals to a displacement into the $goto table. The corresponding goto state for this
         *             non-terminal/state pair is $goto[$gotoBase[$nonTerminal] + $state] (unless defaulted) */
        protected $gotoBase;

        /** @var int[] Table of states to goto after reduction. Indexed according to $gotoBase comment. */
        protected $goto;

        /** @var int[] Table indexed analogously to $goto. If $gotoCheck[$gotoBase[$nonTerminal] + $state] != $nonTerminal
         *             then the goto state is defaulted, i.e. $gotoDefault[$nonTerminal] should be used. */
        protected $gotoCheck;

        /** @var int[] Map of non-terminals to the default state to goto after their reduction */
        protected $gotoDefault;

        /** @var int[] Map of rules to the non-terminal on their left-hand side, i.e. the non-terminal to use for
         *             determining the state to goto after reduction. */
        protected $ruleToNonTerminal;

        /** @var int[] Map of rules to the length of their right-hand side, which is the number of elements that have to
         *             be popped from the stack(s) on reduction. */
        protected $ruleToLength;

        /** @var Lexer Lexer that is used when parsing */
        protected $lexer;

        /** @var mixed Temporary value containing the result of last semantic action (reduction) */
        protected $semValue;

        /** @var array Semantic value stack (contains values of tokens and semantic action results) */
        protected $semStack;

        /** @var array[] Start attribute stack */
        protected $startAttributeStack;

        /** @var array[] End attribute stack */
        protected $endAttributeStack;

        /** @var array End attributes of last *shifted* token */
        protected $endAttributes;

        /** @var array Start attributes of last *read* token */
        protected $lookaheadStartAttributes;

        /** @var ErrorHandler Error handler */
        protected $errorHandler;

        /** @var int Error state, used to avoid error floods */
        protected $errorState;

        /**
         * Initialize $reduceCallbacks map.
         */
        abstract protected function initReduceCallbacks();

        /**
         * Creates a parser instance.
         *
         * Options: Currently none.
         *
         * @param Lexer $lexer A lexer
         * @param array $options Options array.
         */
        public function __construct(\PhpParser\Lexer $lexer, array $options = [/** value is missing */]) {}

        /**
         * Parses PHP code into a node tree.
         *
         * If a non-throwing error handler is used, the parser will continue parsing after an error
         * occurred and attempt to build a partial AST.
         *
         * @param string $code The source code to parse
         * @param ErrorHandler|null $errorHandler Error handler to use for lexer/parser errors, defaults
         *                                        to ErrorHandler\Throwing.
         *
         * @return Node\Stmt[]|null Array of statements (or null non-throwing error handler is used and
         *                          the parser was unable to recover from an error).
         */
        public function parse(string $code, ?\PhpParser\ErrorHandler $errorHandler = null) {}

        protected function doParse() {}

        protected function emitError(\PhpParser\Error $error) {}

        /**
         * Format error message including expected tokens.
         *
         * @param int $symbol Unexpected symbol
         * @param int $state  State at time of error
         *
         * @return string Formatted error message
         */
        protected function getErrorMessage(int $symbol, int $state): string {}

        /**
         * Get limited number of expected tokens in given state.
         *
         * @param int $state State
         *
         * @return string[] Expected tokens. If too many, an empty array is returned.
         */
        protected function getExpectedTokens(int $state): array {}

        /**
         * Moves statements of semicolon-style namespaces into $ns->stmts and checks various error conditions.
         *
         * @param Node\Stmt[] $stmts
         * @return Node\Stmt[]
         */
        protected function handleNamespaces(array $stmts): array {}

        private function fixupNamespaceAttributes(\PhpParser\Node\Stmt\Namespace_ $stmt) {}

        /**
         * Determine namespacing style (semicolon or brace)
         *
         * @param Node[] $stmts Top-level statements.
         *
         * @return null|string One of "semicolon", "brace" or null (no namespaces)
         */
        private function getNamespacingStyle(array $stmts) {}

        /**
         * Fix up parsing of static property calls in PHP 5.
         *
         * In PHP 5 A::$b[c][d] and A::$b[c][d]() have very different interpretation. The former is
         * interpreted as (A::$b)[c][d], while the latter is the same as A::{$b[c][d]}(). We parse the
         * latter as the former initially and this method fixes the AST into the correct form when we
         * encounter the "()".
         *
         * @param  Node\Expr\StaticPropertyFetch|Node\Expr\ArrayDimFetch $prop
         * @param  Node\Arg[] $args
         * @param  array      $attributes
         *
         * @return Expr\StaticCall
         */
        protected function fixupPhp5StaticPropCall($prop, array $args, array $attributes): \PhpParser\Node\Expr\StaticCall {}

        protected function fixupStartAttributes(\PhpParser\Node $to, \PhpParser\Node $from) {}

        protected function handleBuiltinTypes(\PhpParser\Node\Name $name) {}

        /**
         * Get combined start and end attributes at a stack location
         *
         * @param int $pos Stack location
         *
         * @return array Combined start and end attributes
         */
        protected function getAttributesAt(int $pos): array {}

        protected function getFloatCastKind(string $cast): int {}

        protected function parseLNumber($str, $attributes, $allowInvalidOctal = false) {}

        /**
         * Parse a T_NUM_STRING token into either an integer or string node.
         *
         * @param string $str        Number string
         * @param array  $attributes Attributes
         *
         * @return LNumber|String_ Integer or string node.
         */
        protected function parseNumString(string $str, array $attributes) {}

        protected function stripIndentation(string $string, int $indentLen, string $indentChar, bool $newlineAtStart, bool $newlineAtEnd, array $attributes) {}

        protected function parseDocString(string $startToken, $contents, string $endToken, array $attributes, array $endTokenAttributes, bool $parseUnicodeEscape) {}

        /**
         * Create attributes for a zero-length common-capturing nop.
         *
         * @param Comment[] $comments
         * @return array
         */
        protected function createCommentNopAttributes(array $comments) {}

        protected function checkModifier($a, $b, $modifierPos) {}

        protected function checkParam(\PhpParser\Node\Param $node) {}

        protected function checkTryCatch(\PhpParser\Node\Stmt\TryCatch $node) {}

        protected function checkNamespace(\PhpParser\Node\Stmt\Namespace_ $node) {}

        protected function checkClass(\PhpParser\Node\Stmt\Class_ $node, $namePos) {}

        protected function checkInterface(\PhpParser\Node\Stmt\Interface_ $node, $namePos) {}

        protected function checkClassMethod(\PhpParser\Node\Stmt\ClassMethod $node, $modifierPos) {}

        protected function checkClassConst(\PhpParser\Node\Stmt\ClassConst $node, $modifierPos) {}

        protected function checkProperty(\PhpParser\Node\Stmt\Property $node, $modifierPos) {}

        protected function checkUseUse(\PhpParser\Node\Stmt\UseUse $node, $namePos) {}

    }
}

namespace PhpParser
{

    class ParserFactory
    {
        const PREFER_PHP7 = 1;

        const PREFER_PHP5 = 2;

        const ONLY_PHP7 = 3;

        const ONLY_PHP5 = 4;

        /**
         * Creates a Parser instance, according to the provided kind.
         *
         * @param int        $kind  One of ::PREFER_PHP7, ::PREFER_PHP5, ::ONLY_PHP7 or ::ONLY_PHP5
         * @param Lexer|null $lexer Lexer to use. Defaults to emulative lexer when not specified
         * @param array      $parserOptions Parser options. See ParserAbstract::__construct() argument
         *
         * @return Parser The parser instance
         */
        public function create(int $kind, ?\PhpParser\Lexer $lexer = null, array $parserOptions = [/** value is missing */]): \PhpParser\Parser {}

    }
}

namespace PhpParser
{
    use PhpParser\Internal\DiffElem;
    use PhpParser\Internal\PrintableNewAnonClassNode;
    use PhpParser\Internal\TokenStream;
    use PhpParser\Node\Expr;
    use PhpParser\Node\Expr\AssignOp;
    use PhpParser\Node\Expr\BinaryOp;
    use PhpParser\Node\Expr\Cast;
    use PhpParser\Node\Scalar;
    use PhpParser\Node\Stmt;

    abstract class PrettyPrinterAbstract
    {
        const FIXUP_PREC_LEFT = 0;

        const FIXUP_PREC_RIGHT = 1;

        const FIXUP_CALL_LHS = 2;

        const FIXUP_DEREF_LHS = 3;

        const FIXUP_BRACED_NAME = 4;

        const FIXUP_VAR_BRACED_NAME = 5;

        const FIXUP_ENCAPSED = 6;

        protected $precedenceMap = [/** value is missing */];

        /** @var int Current indentation level. */
        protected $indentLevel;

        /** @var string Newline including current indentation. */
        protected $nl;

        /** @var string Token placed at end of doc string to ensure it is followed by a newline. */
        protected $docStringEndToken;

        /** @var bool Whether semicolon namespaces can be used (i.e. no global namespace is used) */
        protected $canUseSemicolonNamespaces;

        /** @var array Pretty printer options */
        protected $options;

        /** @var TokenStream Original tokens for use in format-preserving pretty print */
        protected $origTokens;

        /** @var Internal\Differ Differ for node lists */
        protected $nodeListDiffer;

        /** @var bool[] Map determining whether a certain character is a label character */
        protected $labelCharMap;

        /**
         * @var int[][] Map from token classes and subnode names to FIXUP_* constants. This is used
         *              during format-preserving prints to place additional parens/braces if necessary.
         */
        protected $fixupMap;

        /**
         * @var int[][] Map from "{$node->getType()}->{$subNode}" to ['left' => $l, 'right' => $r],
         *              where $l and $r specify the token type that needs to be stripped when removing
         *              this node.
         */
        protected $removalMap;

        /**
         * @var mixed[] Map from "{$node->getType()}->{$subNode}" to [$find, $beforeToken, $extraLeft, $extraRight].
         *              $find is an optional token after which the insertion occurs. $extraLeft/Right
         *              are optionally added before/after the main insertions.
         */
        protected $insertionMap;

        /**
         * @var string[] Map From "{$node->getType()}->{$subNode}" to string that should be inserted
         *               between elements of this list subnode.
         */
        protected $listInsertionMap;

        protected $emptyListInsertionMap;

        /** @var int[] Map from "{$node->getType()}->{$subNode}" to token before which the modifiers
         *             should be reprinted. */
        protected $modifierChangeMap;

        /**
         * Creates a pretty printer instance using the given options.
         *
         * Supported options:
         *  * bool $shortArraySyntax = false: Whether to use [] instead of array() as the default array
         *                                    syntax, if the node does not specify a format.
         *
         * @param array $options Dictionary of formatting options
         */
        public function __construct(array $options = [/** value is missing */]) {}

        /**
         * Reset pretty printing state.
         */
        protected function resetState() {}

        /**
         * Set indentation level
         *
         * @param int $level Level in number of spaces
         */
        protected function setIndentLevel(int $level) {}

        /**
         * Increase indentation level.
         */
        protected function indent() {}

        /**
         * Decrease indentation level.
         */
        protected function outdent() {}

        /**
         * Pretty prints an array of statements.
         *
         * @param Node[] $stmts Array of statements
         *
         * @return string Pretty printed statements
         */
        public function prettyPrint(array $stmts): string {}

        /**
         * Pretty prints an expression.
         *
         * @param Expr $node Expression node
         *
         * @return string Pretty printed node
         */
        public function prettyPrintExpr(\PhpParser\Node\Expr $node): string {}

        /**
         * Pretty prints a file of statements (includes the opening <?php tag if it is required).
         *
         * @param Node[] $stmts Array of statements
         *
         * @return string Pretty printed statements
         */
        public function prettyPrintFile(array $stmts): string {}

        /**
         * Preprocesses the top-level nodes to initialize pretty printer state.
         *
         * @param Node[] $nodes Array of nodes
         */
        protected function preprocessNodes(array $nodes) {}

        /**
         * Handles (and removes) no-indent and doc-string-end tokens.
         *
         * @param string $str
         * @return string
         */
        protected function handleMagicTokens(string $str): string {}

        /**
         * Pretty prints an array of nodes (statements) and indents them optionally.
         *
         * @param Node[] $nodes  Array of nodes
         * @param bool   $indent Whether to indent the printed nodes
         *
         * @return string Pretty printed statements
         */
        protected function pStmts(array $nodes, bool $indent = true): string {}

        /**
         * Pretty-print an infix operation while taking precedence into account.
         *
         * @param string $class          Node class of operator
         * @param Node   $leftNode       Left-hand side node
         * @param string $operatorString String representation of the operator
         * @param Node   $rightNode      Right-hand side node
         *
         * @return string Pretty printed infix operation
         */
        protected function pInfixOp(string $class, \PhpParser\Node $leftNode, string $operatorString, \PhpParser\Node $rightNode): string {}

        /**
         * Pretty-print a prefix operation while taking precedence into account.
         *
         * @param string $class          Node class of operator
         * @param string $operatorString String representation of the operator
         * @param Node   $node           Node
         *
         * @return string Pretty printed prefix operation
         */
        protected function pPrefixOp(string $class, string $operatorString, \PhpParser\Node $node): string {}

        /**
         * Pretty-print a postfix operation while taking precedence into account.
         *
         * @param string $class          Node class of operator
         * @param string $operatorString String representation of the operator
         * @param Node   $node           Node
         *
         * @return string Pretty printed postfix operation
         */
        protected function pPostfixOp(string $class, \PhpParser\Node $node, string $operatorString): string {}

        /**
         * Prints an expression node with the least amount of parentheses necessary to preserve the meaning.
         *
         * @param Node $node                Node to pretty print
         * @param int  $parentPrecedence    Precedence of the parent operator
         * @param int  $parentAssociativity Associativity of parent operator
         *                                  (-1 is left, 0 is nonassoc, 1 is right)
         * @param int  $childPosition       Position of the node relative to the operator
         *                                  (-1 is left, 1 is right)
         *
         * @return string The pretty printed node
         */
        protected function pPrec(\PhpParser\Node $node, int $parentPrecedence, int $parentAssociativity, int $childPosition): string {}

        /**
         * Pretty prints an array of nodes and implodes the printed values.
         *
         * @param Node[] $nodes Array of Nodes to be printed
         * @param string $glue  Character to implode with
         *
         * @return string Imploded pretty printed nodes
         */
        protected function pImplode(array $nodes, string $glue = ''): string {}

        /**
         * Pretty prints an array of nodes and implodes the printed values with commas.
         *
         * @param Node[] $nodes Array of Nodes to be printed
         *
         * @return string Comma separated pretty printed nodes
         */
        protected function pCommaSeparated(array $nodes): string {}

        /**
         * Pretty prints a comma-separated list of nodes in multiline style, including comments.
         *
         * The result includes a leading newline and one level of indentation (same as pStmts).
         *
         * @param Node[] $nodes         Array of Nodes to be printed
         * @param bool   $trailingComma Whether to use a trailing comma
         *
         * @return string Comma separated pretty printed nodes in multiline style
         */
        protected function pCommaSeparatedMultiline(array $nodes, bool $trailingComma): string {}

        /**
         * Prints reformatted text of the passed comments.
         *
         * @param Comment[] $comments List of comments
         *
         * @return string Reformatted text of comments
         */
        protected function pComments(array $comments): string {}

        /**
         * Perform a format-preserving pretty print of an AST.
         *
         * The format preservation is best effort. For some changes to the AST the formatting will not
         * be preserved (at least not locally).
         *
         * In order to use this method a number of prerequisites must be satisfied:
         *  * The startTokenPos and endTokenPos attributes in the lexer must be enabled.
         *  * The CloningVisitor must be run on the AST prior to modification.
         *  * The original tokens must be provided, using the getTokens() method on the lexer.
         *
         * @param Node[] $stmts      Modified AST with links to original AST
         * @param Node[] $origStmts  Original AST with token offset information
         * @param array  $origTokens Tokens of the original code
         *
         * @return string
         */
        public function printFormatPreserving(array $stmts, array $origStmts, array $origTokens): string {}

        protected function pFallback(\PhpParser\Node $node) {}

        /**
         * Pretty prints a node.
         *
         * This method also handles formatting preservation for nodes.
         *
         * @param Node $node Node to be pretty printed
         * @param bool $parentFormatPreserved Whether parent node has preserved formatting
         *
         * @return string Pretty printed node
         */
        protected function p(\PhpParser\Node $node, $parentFormatPreserved = false): string {}

        /**
         * Perform a format-preserving pretty print of an array.
         *
         * @param array       $nodes            New nodes
         * @param array       $origNodes        Original nodes
         * @param int         $pos              Current token position (updated by reference)
         * @param int         $indentAdjustment Adjustment for indentation
         * @param string      $parentNodeType   Type of the containing node.
         * @param string      $subNodeName      Name of array subnode.
         * @param null|int    $fixup            Fixup information for array item nodes
         *
         * @return null|string Result of pretty print or null if cannot preserve formatting
         */
        protected function pArray(array $nodes, array $origNodes, int &$pos, int $indentAdjustment, string $parentNodeType, string $subNodeName, $fixup) {}

        /**
         * Print node with fixups.
         *
         * Fixups here refer to the addition of extra parentheses, braces or other characters, that
         * are required to preserve program semantics in a certain context (e.g. to maintain precedence
         * or because only certain expressions are allowed in certain places).
         *
         * @param int         $fixup       Fixup type
         * @param Node        $subNode     Subnode to print
         * @param string|null $parentClass Class of parent node
         * @param int         $subStartPos Original start pos of subnode
         * @param int         $subEndPos   Original end pos of subnode
         *
         * @return string Result of fixed-up print of subnode
         */
        protected function pFixup(int $fixup, \PhpParser\Node $subNode, $parentClass, int $subStartPos, int $subEndPos): string {}

        /**
         * Appends to a string, ensuring whitespace between label characters.
         *
         * Example: "echo" and "$x" result in "echo$x", but "echo" and "x" result in "echo x".
         * Without safeAppend the result would be "echox", which does not preserve semantics.
         *
         * @param string $str
         * @param string $append
         */
        protected function safeAppend(string &$str, string $append) {}

        /**
         * Determines whether the LHS of a call must be wrapped in parenthesis.
         *
         * @param Node $node LHS of a call
         *
         * @return bool Whether parentheses are required
         */
        protected function callLhsRequiresParens(\PhpParser\Node $node): bool {}

        /**
         * Determines whether the LHS of a dereferencing operation must be wrapped in parenthesis.
         *
         * @param Node $node LHS of dereferencing operation
         *
         * @return bool Whether parentheses are required
         */
        protected function dereferenceLhsRequiresParens(\PhpParser\Node $node): bool {}

        /**
         * Print modifiers, including trailing whitespace.
         *
         * @param int $modifiers Modifier mask to print
         *
         * @return string Printed modifiers
         */
        protected function pModifiers(int $modifiers) {}

        /**
         * Determine whether a list of nodes uses multiline formatting.
         *
         * @param (Node|null)[] $nodes Node list
         *
         * @return bool Whether multiline formatting is used
         */
        protected function isMultiline(array $nodes): bool {}

        /**
         * Lazily initializes label char map.
         *
         * The label char map determines whether a certain character may occur in a label.
         */
        protected function initializeLabelCharMap() {}

        /**
         * Lazily initializes node list differ.
         *
         * The node list differ is used to determine differences between two array subnodes.
         */
        protected function initializeNodeListDiffer() {}

        /**
         * Lazily initializes fixup map.
         *
         * The fixup map is used to determine whether a certain subnode of a certain node may require
         * some kind of "fixup" operation, e.g. the addition of parenthesis or braces.
         */
        protected function initializeFixupMap() {}

        /**
         * Lazily initializes the removal map.
         *
         * The removal map is used to determine which additional tokens should be returned when a
         * certain node is replaced by null.
         */
        protected function initializeRemovalMap() {}

        protected function initializeInsertionMap() {}

        protected function initializeListInsertionMap() {}

        protected function initializeEmptyListInsertionMap() {}

        protected function initializeModifierChangeMap() {}

    }
}

namespace PharIo\Manifest
{

    class ElementCollectionException extends \InvalidArgumentException
    {
    }
}

namespace PharIo\Manifest
{

    interface Exception
    {
    }
}

namespace PharIo\Manifest
{

    class InvalidApplicationNameException extends \InvalidArgumentException
    {
        const InvalidFormat = 2;

    }
}

namespace PharIo\Manifest
{

    class InvalidEmailException extends \InvalidArgumentException
    {
    }
}

namespace PharIo\Manifest
{

    class InvalidUrlException extends \InvalidArgumentException
    {
    }
}

namespace PharIo\Manifest
{

    class ManifestDocumentException extends \RuntimeException
    {
    }
}

namespace PharIo\Manifest
{
    use LibXMLError;

    class ManifestDocumentLoadingException extends \Exception
    {
        /** @var LibXMLError[] */
        private $libxmlErrors;

        /**
         * ManifestDocumentLoadingException constructor.
         *
         * @param LibXMLError[] $libxmlErrors
         */
        public function __construct(array $libxmlErrors) {}

        /**
         * @return LibXMLError[]
         */
        public function getLibxmlErrors(): array {}

    }
}

namespace PharIo\Manifest
{

    class ManifestDocumentMapperException extends \RuntimeException
    {
    }
}

namespace PharIo\Manifest
{

    class ManifestElementException extends \RuntimeException
    {
    }
}

namespace PharIo\Manifest
{

    class ManifestLoaderException extends \Exception
    {
    }
}

namespace PharIo\Manifest
{

    class Application extends \PharIo\Manifest\Type
    {
        public function isApplication(): bool {}

    }
}

namespace PharIo\Manifest
{

    class ApplicationName
    {
        /** @var string */
        private $name;

        public function __construct(string $name) {}

        public function asString(): string {}

        public function isEqual(\PharIo\Manifest\ApplicationName $name): bool {}

        private function ensureValidFormat(string $name): \void {}

    }
}

namespace PharIo\Manifest
{

    class Author
    {
        /** @var string */
        private $name;

        /** @var Email */
        private $email;

        public function __construct(string $name, \PharIo\Manifest\Email $email) {}

        public function asString(): string {}

        public function getName(): string {}

        public function getEmail(): \PharIo\Manifest\Email {}

    }
}

namespace PharIo\Manifest
{

    class AuthorCollection
    {
        /** @var Author[] */
        private $authors = [/** value is missing */];

        public function add(\PharIo\Manifest\Author $author): \void {}

        /**
         * @return Author[]
         */
        public function getAuthors(): array {}

        public function count(): int {}

        public function getIterator(): \PharIo\Manifest\AuthorCollectionIterator {}

    }
}

namespace PharIo\Manifest
{

    class AuthorCollectionIterator
    {
        /** @var Author[] */
        private $authors;

        /** @var int */
        private $position = 0;

        public function __construct(\PharIo\Manifest\AuthorCollection $authors) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PharIo\Manifest\Author {}

        public function next(): \void {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\Version;

    class BundledComponent
    {
        /** @var string */
        private $name;

        /** @var Version */
        private $version;

        public function __construct(string $name, \PharIo\Version\Version $version) {}

        public function getName(): string {}

        public function getVersion(): \PharIo\Version\Version {}

    }
}

namespace PharIo\Manifest
{

    class BundledComponentCollection
    {
        /** @var BundledComponent[] */
        private $bundledComponents = [/** value is missing */];

        public function add(\PharIo\Manifest\BundledComponent $bundledComponent): \void {}

        /**
         * @return BundledComponent[]
         */
        public function getBundledComponents(): array {}

        public function count(): int {}

        public function getIterator(): \PharIo\Manifest\BundledComponentCollectionIterator {}

    }
}

namespace PharIo\Manifest
{

    class BundledComponentCollectionIterator
    {
        /** @var BundledComponent[] */
        private $bundledComponents;

        /** @var int */
        private $position = 0;

        public function __construct(\PharIo\Manifest\BundledComponentCollection $bundledComponents) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PharIo\Manifest\BundledComponent {}

        public function next(): \void {}

    }
}

namespace PharIo\Manifest
{

    class CopyrightInformation
    {
        /** @var AuthorCollection */
        private $authors;

        /** @var License */
        private $license;

        public function __construct(\PharIo\Manifest\AuthorCollection $authors, \PharIo\Manifest\License $license) {}

        public function getAuthors(): \PharIo\Manifest\AuthorCollection {}

        public function getLicense(): \PharIo\Manifest\License {}

    }
}

namespace PharIo\Manifest
{

    class Email
    {
        /** @var string */
        private $email;

        public function __construct(string $email) {}

        public function asString(): string {}

        private function ensureEmailIsValid(string $url): \void {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\Version;
    use PharIo\Version\VersionConstraint;

    class Extension extends \PharIo\Manifest\Type
    {
        /** @var ApplicationName */
        private $application;

        /** @var VersionConstraint */
        private $versionConstraint;

        public function __construct(\PharIo\Manifest\ApplicationName $application, \PharIo\Version\VersionConstraint $versionConstraint) {}

        public function getApplicationName(): \PharIo\Manifest\ApplicationName {}

        public function getVersionConstraint(): \PharIo\Version\VersionConstraint {}

        public function isExtension(): bool {}

        public function isExtensionFor(\PharIo\Manifest\ApplicationName $name): bool {}

        public function isCompatibleWith(\PharIo\Manifest\ApplicationName $name, \PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Manifest
{

    class Library extends \PharIo\Manifest\Type
    {
        public function isLibrary(): bool {}

    }
}

namespace PharIo\Manifest
{

    class License
    {
        /** @var string */
        private $name;

        /** @var Url */
        private $url;

        public function __construct(string $name, \PharIo\Manifest\Url $url) {}

        public function getName(): string {}

        public function getUrl(): \PharIo\Manifest\Url {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\Version;

    class Manifest
    {
        /** @var ApplicationName */
        private $name;

        /** @var Version */
        private $version;

        /** @var Type */
        private $type;

        /** @var CopyrightInformation */
        private $copyrightInformation;

        /** @var RequirementCollection */
        private $requirements;

        /** @var BundledComponentCollection */
        private $bundledComponents;

        public function __construct(\PharIo\Manifest\ApplicationName $name, \PharIo\Version\Version $version, \PharIo\Manifest\Type $type, \PharIo\Manifest\CopyrightInformation $copyrightInformation, \PharIo\Manifest\RequirementCollection $requirements, \PharIo\Manifest\BundledComponentCollection $bundledComponents) {}

        public function getName(): \PharIo\Manifest\ApplicationName {}

        public function getVersion(): \PharIo\Version\Version {}

        public function getType(): \PharIo\Manifest\Type {}

        public function getCopyrightInformation(): \PharIo\Manifest\CopyrightInformation {}

        public function getRequirements(): \PharIo\Manifest\RequirementCollection {}

        public function getBundledComponents(): \PharIo\Manifest\BundledComponentCollection {}

        public function isApplication(): bool {}

        public function isLibrary(): bool {}

        public function isExtension(): bool {}

        public function isExtensionFor(\PharIo\Manifest\ApplicationName $application, ?\PharIo\Version\Version $version = null): bool {}

    }
}

namespace PharIo\Manifest
{

    class PhpExtensionRequirement implements \PharIo\Manifest\Requirement
    {
        /** @var string */
        private $extension;

        public function __construct(string $extension) {}

        public function asString(): string {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\VersionConstraint;

    class PhpVersionRequirement implements \PharIo\Manifest\Requirement
    {
        /** @var VersionConstraint */
        private $versionConstraint;

        public function __construct(\PharIo\Version\VersionConstraint $versionConstraint) {}

        public function getVersionConstraint(): \PharIo\Version\VersionConstraint {}

    }
}

namespace PharIo\Manifest
{

    interface Requirement
    {
    }
}

namespace PharIo\Manifest
{

    class RequirementCollection
    {
        /** @var Requirement[] */
        private $requirements = [/** value is missing */];

        public function add(\PharIo\Manifest\Requirement $requirement): \void {}

        /**
         * @return Requirement[]
         */
        public function getRequirements(): array {}

        public function count(): int {}

        public function getIterator(): \PharIo\Manifest\RequirementCollectionIterator {}

    }
}

namespace PharIo\Manifest
{

    class RequirementCollectionIterator
    {
        /** @var Requirement[] */
        private $requirements;

        /** @var int */
        private $position = 0;

        public function __construct(\PharIo\Manifest\RequirementCollection $requirements) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \PharIo\Manifest\Requirement {}

        public function next(): \void {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\VersionConstraint;

    abstract class Type
    {
        public static function application(): \PharIo\Manifest\Application {}

        public static function library(): \PharIo\Manifest\Library {}

        public static function extension(\PharIo\Manifest\ApplicationName $application, \PharIo\Version\VersionConstraint $versionConstraint): \PharIo\Manifest\Extension {}

        /** @psalm-assert-if-true Application $this */
        public function isApplication(): bool {}

        /** @psalm-assert-if-true Library $this */
        public function isLibrary(): bool {}

        /** @psalm-assert-if-true Extension $this */
        public function isExtension(): bool {}

    }
}

namespace PharIo\Manifest
{

    class Url
    {
        /** @var string */
        private $url;

        public function __construct(string $url) {}

        public function asString(): string {}

        /**
         * @param string $url
         *
         * @throws InvalidUrlException
         */
        private function ensureUrlIsValid($url): \void {}

    }
}

namespace PharIo\Manifest
{

    class AuthorElement extends \PharIo\Manifest\ManifestElement
    {
        public function getName(): string {}

        public function getEmail(): string {}

    }
}

namespace PharIo\Manifest
{

    class AuthorElementCollection extends \PharIo\Manifest\ElementCollection
    {
        public function current(): \PharIo\Manifest\AuthorElement {}

    }
}

namespace PharIo\Manifest
{

    class BundlesElement extends \PharIo\Manifest\ManifestElement
    {
        public function getComponentElements(): \PharIo\Manifest\ComponentElementCollection {}

    }
}

namespace PharIo\Manifest
{

    class ComponentElement extends \PharIo\Manifest\ManifestElement
    {
        public function getName(): string {}

        public function getVersion(): string {}

    }
}

namespace PharIo\Manifest
{

    class ComponentElementCollection extends \PharIo\Manifest\ElementCollection
    {
        public function current(): \PharIo\Manifest\ComponentElement {}

    }
}

namespace PharIo\Manifest
{

    class ContainsElement extends \PharIo\Manifest\ManifestElement
    {
        public function getName(): string {}

        public function getVersion(): string {}

        public function getType(): string {}

        public function getExtensionElement(): \PharIo\Manifest\ExtensionElement {}

    }
}

namespace PharIo\Manifest
{

    class CopyrightElement extends \PharIo\Manifest\ManifestElement
    {
        public function getAuthorElements(): \PharIo\Manifest\AuthorElementCollection {}

        public function getLicenseElement(): \PharIo\Manifest\LicenseElement {}

    }
}

namespace PharIo\Manifest
{
    use DOMElement;
    use DOMNodeList;

    abstract class ElementCollection
    {
        /** @var DOMElement[] */
        private $nodes = [/** value is missing */];

        /** @var int */
        private $position;

        public function __construct(\DOMNodeList $nodeList) {}

        abstract public function current();

        public function next(): \void {}

        public function key() {}

        public function valid() {}

        public function rewind(): \void {}

        protected function getCurrentElement(): \DOMElement {}

        private function importNodes(\DOMNodeList $nodeList): \void {}

    }
}

namespace PharIo\Manifest
{

    class ExtElement extends \PharIo\Manifest\ManifestElement
    {
        public function getName(): string {}

    }
}

namespace PharIo\Manifest
{

    class ExtElementCollection extends \PharIo\Manifest\ElementCollection
    {
        public function current(): \PharIo\Manifest\ExtElement {}

    }
}

namespace PharIo\Manifest
{

    class ExtensionElement extends \PharIo\Manifest\ManifestElement
    {
        public function getFor(): string {}

        public function getCompatible(): string {}

    }
}

namespace PharIo\Manifest
{

    class LicenseElement extends \PharIo\Manifest\ManifestElement
    {
        public function getType(): string {}

        public function getUrl(): string {}

    }
}

namespace PharIo\Manifest
{
    use DOMDocument;
    use DOMElement;

    class ManifestDocument
    {
        const XMLNS = 'https://phar.io/xml/manifest/1.0';

        /** @var DOMDocument */
        private $dom;

        public static function fromFile(string $filename): \PharIo\Manifest\ManifestDocument {}

        public static function fromString(string $xmlString): \PharIo\Manifest\ManifestDocument {}

        private function __construct(\DOMDocument $dom) {}

        public function getContainsElement(): \PharIo\Manifest\ContainsElement {}

        public function getCopyrightElement(): \PharIo\Manifest\CopyrightElement {}

        public function getRequiresElement(): \PharIo\Manifest\RequiresElement {}

        public function hasBundlesElement(): bool {}

        public function getBundlesElement(): \PharIo\Manifest\BundlesElement {}

        private function ensureCorrectDocumentType(\DOMDocument $dom): \void {}

        private function fetchElementByName(string $elementName): \DOMElement {}

    }
}

namespace PharIo\Manifest
{
    use DOMElement;
    use DOMNodeList;

    class ManifestElement
    {
        const XMLNS = 'https://phar.io/xml/manifest/1.0';

        /** @var DOMElement */
        private $element;

        public function __construct(\DOMElement $element) {}

        protected function getAttributeValue(string $name): string {}

        protected function getChildByName(string $elementName): \DOMElement {}

        protected function getChildrenByName(string $elementName): \DOMNodeList {}

        protected function hasChild(string $elementName): bool {}

    }
}

namespace PharIo\Manifest
{

    class PhpElement extends \PharIo\Manifest\ManifestElement
    {
        public function getVersion(): string {}

        public function hasExtElements(): bool {}

        public function getExtElements(): \PharIo\Manifest\ExtElementCollection {}

    }
}

namespace PharIo\Manifest
{

    class RequiresElement extends \PharIo\Manifest\ManifestElement
    {
        public function getPHPElement(): \PharIo\Manifest\PhpElement {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\Exception as VersionException;
    use PharIo\Version\Version;
    use PharIo\Version\VersionConstraintParser;

    class ManifestDocumentMapper
    {
        public function map(\PharIo\Manifest\ManifestDocument $document): \PharIo\Manifest\Manifest {}

        private function mapType(\PharIo\Manifest\ContainsElement $contains): \PharIo\Manifest\Type {}

        private function mapCopyright(\PharIo\Manifest\CopyrightElement $copyright): \PharIo\Manifest\CopyrightInformation {}

        private function mapRequirements(\PharIo\Manifest\RequiresElement $requires): \PharIo\Manifest\RequirementCollection {}

        private function mapBundledComponents(\PharIo\Manifest\ManifestDocument $document): \PharIo\Manifest\BundledComponentCollection {}

        private function mapExtension(\PharIo\Manifest\ExtensionElement $extension): \PharIo\Manifest\Extension {}

    }
}

namespace PharIo\Manifest
{

    class ManifestLoader
    {
        public static function fromFile(string $filename): \PharIo\Manifest\Manifest {}

        public static function fromPhar(string $filename): \PharIo\Manifest\Manifest {}

        public static function fromString(string $manifest): \PharIo\Manifest\Manifest {}

    }
}

namespace PharIo\Manifest
{
    use PharIo\Version\AnyVersionConstraint;
    use PharIo\Version\Version;
    use PharIo\Version\VersionConstraint;
    use XMLWriter;

    /** @psalm-suppress MissingConstructor */
    class ManifestSerializer
    {
        /** @var XMLWriter */
        private $xmlWriter;

        public function serializeToFile(\PharIo\Manifest\Manifest $manifest, string $filename): \void {}

        public function serializeToString(\PharIo\Manifest\Manifest $manifest): string {}

        private function startDocument(): \void {}

        private function finishDocument(): string {}

        private function addContains(\PharIo\Manifest\ApplicationName $name, \PharIo\Version\Version $version, \PharIo\Manifest\Type $type): \void {}

        private function addCopyright(\PharIo\Manifest\CopyrightInformation $copyrightInformation): \void {}

        private function addRequirements(\PharIo\Manifest\RequirementCollection $requirementCollection): \void {}

        private function addBundles(\PharIo\Manifest\BundledComponentCollection $bundledComponentCollection): \void {}

        private function addExtension(\PharIo\Manifest\ApplicationName $applicationName, \PharIo\Version\VersionConstraint $versionConstraint): \void {}

    }
}

namespace PharIo\Version
{

    abstract class AbstractVersionConstraint implements \PharIo\Version\VersionConstraint
    {
        /** @var string */
        private $originalValue;

        public function __construct(string $originalValue) {}

        public function asString(): string {}

    }
}

namespace PharIo\Version
{

    class AndVersionConstraintGroup extends \PharIo\Version\AbstractVersionConstraint
    {
        /** @var VersionConstraint[] */
        private $constraints = [/** value is missing */];

        /**
         * @param VersionConstraint[] $constraints
         */
        public function __construct(string $originalValue, array $constraints) {}

        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    class AnyVersionConstraint implements \PharIo\Version\VersionConstraint
    {
        public function complies(\PharIo\Version\Version $version): bool {}

        public function asString(): string {}

    }
}

namespace PharIo\Version
{

    class ExactVersionConstraint extends \PharIo\Version\AbstractVersionConstraint
    {
        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    class GreaterThanOrEqualToVersionConstraint extends \PharIo\Version\AbstractVersionConstraint
    {
        /** @var Version */
        private $minimalVersion;

        /**
         * @param string $originalValue
         */
        public function __construct($originalValue, \PharIo\Version\Version $minimalVersion) {}

        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    class OrVersionConstraintGroup extends \PharIo\Version\AbstractVersionConstraint
    {
        /** @var VersionConstraint[] */
        private $constraints = [/** value is missing */];

        /**
         * @param string              $originalValue
         * @param VersionConstraint[] $constraints
         */
        public function __construct($originalValue, array $constraints) {}

        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    class SpecificMajorAndMinorVersionConstraint extends \PharIo\Version\AbstractVersionConstraint
    {
        /** @var int */
        private $major = 0;

        /** @var int */
        private $minor = 0;

        /**
         * @param string $originalValue
         * @param int    $major
         * @param int    $minor
         */
        public function __construct($originalValue, $major, $minor) {}

        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    class SpecificMajorVersionConstraint extends \PharIo\Version\AbstractVersionConstraint
    {
        /** @var int */
        private $major = 0;

        /**
         * @param string $originalValue
         * @param int    $major
         */
        public function __construct($originalValue, $major) {}

        public function complies(\PharIo\Version\Version $version): bool {}

    }
}

namespace PharIo\Version
{

    interface VersionConstraint
    {
        public function complies(\PharIo\Version\Version $version): bool;

        public function asString(): string;

    }
}

namespace PharIo\Version
{
    use Throwable;

    interface Exception
    {
    }
}

namespace PharIo\Version
{

    class InvalidPreReleaseSuffixException extends \Exception
    {
    }
}

namespace PharIo\Version
{

    class InvalidVersionException extends \InvalidArgumentException
    {
    }
}

namespace PharIo\Version
{

    final class UnsupportedVersionConstraintException extends \RuntimeException
    {
    }
}

namespace PharIo\Version
{

    class PreReleaseSuffix
    {
        const valueScoreMap = [/** value is missing */];

        /** @var string */
        private $value;

        /** @var int */
        private $valueScore;

        /** @var int */
        private $number = 0;

        /** @var string  */
        private $full;

        /**
         * @throws InvalidPreReleaseSuffixException
         */
        public function __construct(string $value) {}

        public function asString(): string {}

        public function getValue(): string {}

        public function getNumber(): ?int {}

        public function isGreaterThan(\PharIo\Version\PreReleaseSuffix $suffix): bool {}

        /**
         * @param $value
         */
        private function mapValueToScore($value): int {}

        private function parseValue($value): \void {}

    }
}

namespace PharIo\Version
{

    class Version
    {
        /** @var VersionNumber */
        private $major;

        /** @var VersionNumber */
        private $minor;

        /** @var VersionNumber */
        private $patch;

        /** @var PreReleaseSuffix */
        private $preReleaseSuffix;

        /**
         * @param string $versionString
         */
        public function __construct($versionString) {}

        public function getPreReleaseSuffix(): \PharIo\Version\PreReleaseSuffix {}

        public function getVersionString(): string {}

        public function hasPreReleaseSuffix(): bool {}

        public function isGreaterThan(\PharIo\Version\Version $version): bool {}

        public function getMajor(): \PharIo\Version\VersionNumber {}

        public function getMinor(): \PharIo\Version\VersionNumber {}

        public function getPatch(): \PharIo\Version\VersionNumber {}

        private function parseVersion(array $matches): \void {}

        /**
         * @param string $version
         *
         * @throws InvalidVersionException
         */
        private function ensureVersionStringIsValid($version): \void {}

    }
}

namespace PharIo\Version
{

    class VersionConstraintParser
    {
        /**
         * @param string $value
         *
         * @throws UnsupportedVersionConstraintException
         */
        public function parse($value): \PharIo\Version\VersionConstraint {}

        /**
         * @param $value
         */
        private function handleOrGroup($value): \PharIo\Version\OrVersionConstraintGroup {}

        /**
         * @param string $value
         */
        private function handleTildeOperator($value): \PharIo\Version\AndVersionConstraintGroup {}

        /**
         * @param string $value
         */
        private function handleCaretOperator($value): \PharIo\Version\AndVersionConstraintGroup {}

    }
}

namespace PharIo\Version
{

    class VersionConstraintValue
    {
        /** @var VersionNumber */
        private $major;

        /** @var VersionNumber */
        private $minor;

        /** @var VersionNumber */
        private $patch;

        /** @var string */
        private $label = '';

        /** @var string */
        private $buildMetaData = '';

        /** @var string */
        private $versionString = '';

        /**
         * @param string $versionString
         */
        public function __construct($versionString) {}

        public function getLabel(): string {}

        public function getBuildMetaData(): string {}

        public function getVersionString(): string {}

        public function getMajor(): \PharIo\Version\VersionNumber {}

        public function getMinor(): \PharIo\Version\VersionNumber {}

        public function getPatch(): \PharIo\Version\VersionNumber {}

        /**
         * @param $versionString
         */
        private function parseVersion($versionString): \void {}

        /**
         * @param string $versionString
         */
        private function extractBuildMetaData(&$versionString): \void {}

        /**
         * @param string $versionString
         */
        private function extractLabel(&$versionString): \void {}

        private function stripPotentialVPrefix(&$versionString): \void {}

    }
}

namespace PharIo\Version
{

    class VersionNumber
    {
        /** @var ?int */
        private $value;

        public function __construct(?int $value) {}

        public function isAny(): bool {}

        public function getValue(): ?int {}

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * Interface for Api Elements
     */
    interface Element
    {
        /**
         * Returns the Fqsen of the element.
         */
        public function getFqsen(): \phpDocumentor\Reflection\Fqsen;

        /**
         * Returns the name of the element.
         */
        public function getName(): string;

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * Interface for files processed by the ProjectFactory
     */
    interface File
    {
        /**
         * Returns the content of the file as a string.
         */
        public function getContents(): string;

        /**
         * Returns md5 hash of the file.
         */
        public function md5(): string;

        /**
         * Returns an relative path to the file.
         */
        public function path(): string;

    }
}

namespace phpDocumentor\Reflection
{
    use InvalidArgumentException;
    use assert;
    use end;
    use explode;
    use is_string;
    use preg_match;
    use sprintf;
    use trim;

    /**
     * Value Object for Fqsen.
     *
     * @link https://github.com/phpDocumentor/fig-standards/blob/master/proposed/phpdoc-meta.md
     *
     * @psalm-immutable
     */
    final class Fqsen
    {
        /** @var string full quallified class name */
        private $fqsen;

        /** @var string name of the element without path. */
        private $name;

        /**
         * Initializes the object.
         *
         * @throws InvalidArgumentException when $fqsen is not matching the format.
         */
        public function __construct(string $fqsen) {}

        /**
         * converts this class to string.
         */
        public function __toString(): string {}

        /**
         * Returns the name of the element without path.
         */
        public function getName(): string {}

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * The location where an element occurs within a file.
     *
     * @psalm-immutable
     */
    final class Location
    {
        /** @var int */
        private $lineNumber = 0;

        /** @var int */
        private $columnNumber = 0;

        /**
         * Initializes the location for an element using its line number in the file and optionally the column number.
         */
        public function __construct(int $lineNumber, int $columnNumber = 0) {}

        /**
         * Returns the line number that is covered by this location.
         */
        public function getLineNumber(): int {}

        /**
         * Returns the column number (character position on a line) for this location object.
         */
        public function getColumnNumber(): int {}

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * Interface for project. Since the definition of a project can be different per factory this interface will be small.
     */
    interface Project
    {
        /**
         * Returns the name of the project.
         */
        public function getName(): string;

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * Interface for project factories. A project factory shall convert a set of files
     * into an object implementing the Project interface.
     */
    interface ProjectFactory
    {
        /**
         * Creates a project from the set of files.
         *
         * @param File[] $files
         */
        public function create(string $name, array $files): \phpDocumentor\Reflection\Project;

    }
}

namespace phpDocumentor\Reflection
{
    use phpDocumentor\Reflection\DocBlock\Tag;
    use Webmozart\Assert\Assert;

    final class DocBlock
    {
        /** @var string The opening line for this docblock. */
        private $summary;

        /** @var DocBlock\Description The actual description for this docblock. */
        private $description;

        /** @var Tag[] An array containing all the tags in this docblock; except inline. */
        private $tags = [/** value is missing */];

        /** @var Types\Context|null Information about the context of this DocBlock. */
        private $context;

        /** @var Location|null Information about the location of this DocBlock. */
        private $location;

        /** @var bool Is this DocBlock (the start of) a template? */
        private $isTemplateStart;

        /** @var bool Does this DocBlock signify the end of a DocBlock template? */
        private $isTemplateEnd;

        /**
         * @param DocBlock\Tag[] $tags
         * @param Types\Context  $context  The context in which the DocBlock occurs.
         * @param Location       $location The location within the file that this DocBlock occurs in.
         */
        public function __construct(string $summary = '', ?\phpDocumentor\Reflection\DocBlock\Description $description = null, array $tags = [/** value is missing */], ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null, bool $isTemplateStart = false, bool $isTemplateEnd = false) {}

        public function getSummary(): string {}

        public function getDescription(): \phpDocumentor\Reflection\DocBlock\Description {}

        /**
         * Returns the current context.
         */
        public function getContext(): ?\phpDocumentor\Reflection\Types\Context {}

        /**
         * Returns the current location.
         */
        public function getLocation(): ?\phpDocumentor\Reflection\Location {}

        /**
         * Returns whether this DocBlock is the start of a Template section.
         *
         * A Docblock may serve as template for a series of subsequent DocBlocks. This is indicated by a special marker
         * (`#@+`) that is appended directly after the opening `/**` of a DocBlock.
         *
         * An example of such an opening is:
         *
         * ```
         * /**#@+
         *  * My DocBlock
         *  * /
         * ```
         *
         * The description and tags (not the summary!) are copied onto all subsequent DocBlocks and also applied to all
         * elements that follow until another DocBlock is found that contains the closing marker (`#@-`).
         *
         * @see self::isTemplateEnd() for the check whether a closing marker was provided.
         */
        public function isTemplateStart(): bool {}

        /**
         * Returns whether this DocBlock is the end of a Template section.
         *
         * @see self::isTemplateStart() for a more complete description of the Docblock Template functionality.
         */
        public function isTemplateEnd(): bool {}

        /**
         * Returns the tags for this DocBlock.
         *
         * @return Tag[]
         */
        public function getTags(): array {}

        /**
         * Returns an array of tags matching the given name. If no tags are found
         * an empty array is returned.
         *
         * @param string $name String to search by.
         *
         * @return Tag[]
         */
        public function getTagsByName(string $name): array {}

        /**
         * Checks if a tag of a certain type is present in this DocBlock.
         *
         * @param string $name Tag name to check for.
         */
        public function hasTag(string $name): bool {}

        /**
         * Remove a tag from this DocBlock.
         *
         * @param Tag $tagToRemove The tag to remove.
         */
        public function removeTag(\phpDocumentor\Reflection\DocBlock\Tag $tagToRemove): \void {}

        /**
         * Adds a tag to this DocBlock.
         *
         * @param Tag $tag The tag to add.
         */
        private function addTag(\phpDocumentor\Reflection\DocBlock\Tag $tag): \void {}

    }
}

namespace phpDocumentor\Reflection
{
    use InvalidArgumentException;
    use LogicException;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\DocBlock\StandardTagFactory;
    use phpDocumentor\Reflection\DocBlock\Tag;
    use phpDocumentor\Reflection\DocBlock\TagFactory;
    use Webmozart\Assert\Assert;
    use array_shift;
    use count;
    use explode;
    use is_object;
    use method_exists;
    use preg_match;
    use preg_replace;
    use str_replace;
    use strpos;
    use substr;
    use trim;

    final class DocBlockFactory implements \phpDocumentor\Reflection\DocBlockFactoryInterface
    {
        /** @var DocBlock\DescriptionFactory */
        private $descriptionFactory;

        /** @var DocBlock\TagFactory */
        private $tagFactory;

        /**
         * Initializes this factory with the required subcontractors.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory, \phpDocumentor\Reflection\DocBlock\TagFactory $tagFactory) {}

        /**
         * Factory method for easy instantiation.
         *
         * @param array<string, class-string<Tag>> $additionalTags
         */
        public static function createInstance(array $additionalTags = [/** value is missing */]): self {}

        /**
         * @param object|string $docblock A string containing the DocBlock to parse or an object supporting the
         *                                getDocComment method (such as a ReflectionClass object).
         */
        public function create($docblock, ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null): \phpDocumentor\Reflection\DocBlock {}

        /**
         * @param class-string<Tag> $handler
         */
        public function registerTagHandler(string $tagName, string $handler): \void {}

        /**
         * Strips the asterisks from the DocBlock comment.
         *
         * @param string $comment String containing the comment text.
         */
        private function stripDocComment(string $comment): string {}

        /**
         * Splits the DocBlock into a template marker, summary, description and block of tags.
         *
         * @param string $comment Comment to split into the sub-parts.
         *
         * @return string[] containing the template marker (if any), summary, description and a string containing the tags.
         *
         * @author Mike van Riel <me@mikevanriel.com> for extending the regex with template marker support.
         *
         * @author Richard van Velzen (@_richardJ) Special thanks to Richard for the regex responsible for the split.
         */
        private function splitDocBlock(string $comment): array {}

        /**
         * Creates the tag objects.
         *
         * @param string        $tags    Tag block to parse.
         * @param Types\Context $context Context of the parsed Tag
         *
         * @return DocBlock\Tag[]
         */
        private function parseTagBlock(string $tags, \phpDocumentor\Reflection\Types\Context $context): array {}

        /**
         * @return string[]
         */
        private function splitTagBlockIntoTagLines(string $tags): array {}

        private function filterTagBlock(string $tags): ?string {}

    }
}

namespace phpDocumentor\Reflection
{
    use phpDocumentor\Reflection\DocBlock\Tag;

    interface DocBlockFactoryInterface
    {
        /**
         * Factory method for easy instantiation.
         *
         * @param array<string, class-string<Tag>> $additionalTags
         */
        public static function createInstance(array $additionalTags = [/** value is missing */]): \phpDocumentor\Reflection\DocBlockFactory;

        /**
         * @param string|object $docblock
         */
        public function create($docblock, ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null): \phpDocumentor\Reflection\DocBlock;

    }
}

namespace phpDocumentor\Reflection
{
    use phpDocumentor\Reflection\Exception\PcreException;
    use preg_last_error;
    use preg_split as php_preg_split;

    abstract class Utils
    {
        /**
         * Wrapper function for phps preg_split
         *
         * This function is inspired by {@link https://github.com/thecodingmachine/safe/blob/master/generated/pcre.php}. But
         * since this library is all about performance we decided to strip everything we don't need. Reducing the amount
         * of files that have to be loaded, ect.
         *
         * @param string $pattern The pattern to search for, as a string.
         * @param string $subject The input string.
         * @param int|null $limit If specified, then only substrings up to limit are returned with the
         *      rest of the string being placed in the last substring. A limit of -1 or 0 means "no limit".
         * @param int $flags flags can be any combination of the following flags (combined with the | bitwise operator):
         * *PREG_SPLIT_NO_EMPTY*
         *      If this flag is set, only non-empty pieces will be returned by preg_split().
         * *PREG_SPLIT_DELIM_CAPTURE*
         *      If this flag is set, parenthesized expression in the delimiter pattern will be captured
         *      and returned as well.
         * *PREG_SPLIT_OFFSET_CAPTURE*
         *      If this flag is set, for every occurring match the appendant string offset will also be returned.
         *      Note that this changes the return value in an array where every element is an array consisting of the
         *      matched string at offset 0 and its string offset into subject at offset 1.
         *
         * @return string[] Returns an array containing substrings of subject split along boundaries matched by pattern
         *
         * @throws PcreException
         */
        public static function pregSplit(string $pattern, string $subject, ?int $limit = null, int $flags = 0): array {}

    }
}

namespace phpDocumentor\Reflection
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\Types\Context;
    use explode;
    use implode;
    use strpos;

    /**
     * Resolver for Fqsen using Context information
     *
     * @psalm-immutable
     */
    class FqsenResolver
    {
        /** @var string Definition of the NAMESPACE operator in PHP */
        const OPERATOR_NAMESPACE = '\';

        public function resolve(string $fqsen, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Tests whether the given type is a Fully Qualified Structural Element Name.
         */
        private function isFqsen(string $type): bool {}

        /**
         * Resolves a partial Structural Element Name (i.e. `Reflection\DocBlock`) to its FQSEN representation
         * (i.e. `\phpDocumentor\Reflection\DocBlock`) based on the Namespace and aliases mentioned in the Context.
         *
         * @throws InvalidArgumentException When type is not a valid FQSEN.
         */
        private function resolvePartialStructuralElementName(string $type, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Fqsen {}

    }
}

namespace phpDocumentor\Reflection
{

    interface PseudoType extends \phpDocumentor\Reflection\Type
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type;

    }
}

namespace phpDocumentor\Reflection
{

    /**
     * @psalm-immutable
     */
    interface Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string;

    }
}

namespace phpDocumentor\Reflection
{
    use ArrayIterator;
    use InvalidArgumentException;
    use phpDocumentor\Reflection\Types\Array_;
    use phpDocumentor\Reflection\Types\ClassString;
    use phpDocumentor\Reflection\Types\Collection;
    use phpDocumentor\Reflection\Types\Compound;
    use phpDocumentor\Reflection\Types\Context;
    use phpDocumentor\Reflection\Types\Expression;
    use phpDocumentor\Reflection\Types\Integer;
    use phpDocumentor\Reflection\Types\Intersection;
    use phpDocumentor\Reflection\Types\Iterable_;
    use phpDocumentor\Reflection\Types\Nullable;
    use phpDocumentor\Reflection\Types\Object_;
    use phpDocumentor\Reflection\Types\String_;
    use RuntimeException;
    use array_key_exists;
    use array_pop;
    use array_values;
    use class_exists;
    use class_implements;
    use count;
    use end;
    use in_array;
    use key;
    use preg_split;
    use strpos;
    use strtolower;
    use trim;
    use PREG_SPLIT_DELIM_CAPTURE;
    use PREG_SPLIT_NO_EMPTY;

    final class TypeResolver
    {
        /** @var string Definition of the ARRAY operator for types */
        const OPERATOR_ARRAY = '[]';

        /** @var string Definition of the NAMESPACE operator in PHP */
        const OPERATOR_NAMESPACE = '\';

        /** @var int the iterator parser is inside a compound context */
        const PARSER_IN_COMPOUND = 0;

        /** @var int the iterator parser is inside a nullable expression context */
        const PARSER_IN_NULLABLE = 1;

        /** @var int the iterator parser is inside an array expression context */
        const PARSER_IN_ARRAY_EXPRESSION = 2;

        /** @var int the iterator parser is inside a collection expression context */
        const PARSER_IN_COLLECTION_EXPRESSION = 3;

        /**
         * @var array<string, string> List of recognized keywords and unto which Value Object they map
         * @psalm-var array<string, class-string<Type>>
         */
        private $keywords = [/** value is missing */];

        /**
         * @var FqsenResolver
         * @psalm-readonly
         */
        private $fqsenResolver;

        /**
         * Initializes this TypeResolver with the means to create and resolve Fqsen objects.
         */
        public function __construct(?\phpDocumentor\Reflection\FqsenResolver $fqsenResolver = null) {}

        /**
         * Analyzes the given type and returns the FQCN variant.
         *
         * When a type is provided this method checks whether it is not a keyword or
         * Fully Qualified Class Name. If so it will use the given namespace and
         * aliases to expand the type to a FQCN representation.
         *
         * This method only works as expected if the namespace and aliases are set;
         * no dynamic reflection is being performed here.
         *
         * @uses Context::getNamespaceAliases() to check whether the first part of the relative type name should not be
         * replaced with another namespace.
         * @uses Context::getNamespace()        to determine with what to prefix the type name.
         *
         * @param string $type The relative or absolute type.
         */
        public function resolve(string $type, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\Type {}

        /**
         * Analyse each tokens and creates types
         *
         * @param ArrayIterator<int, string|null> $tokens        the iterator on tokens
         * @param int                        $parserContext on of self::PARSER_* constants, indicating
         * the context where we are in the parsing
         */
        private function parseTypes(\ArrayIterator $tokens, \phpDocumentor\Reflection\Types\Context $context, int $parserContext): \phpDocumentor\Reflection\Type {}

        /**
         * resolve the given type into a type object
         *
         * @param string $type the type string, representing a single type
         *
         * @return Type|Array_|Object_
         *
         * @psalm-mutation-free
         */
        private function resolveSingleType(string $type, \phpDocumentor\Reflection\Types\Context $context): object {}

        /**
         * Adds a keyword to the list of Keywords and associates it with a specific Value Object.
         *
         * @psalm-param class-string<Type> $typeClassName
         */
        public function addKeyword(string $keyword, string $typeClassName): \void {}

        /**
         * Detects whether the given type represents a PHPDoc keyword.
         *
         * @param string $type A relative or absolute type as defined in the phpDocumentor documentation.
         *
         * @psalm-mutation-free
         */
        private function isKeyword(string $type): bool {}

        /**
         * Detects whether the given type represents a relative structural element name.
         *
         * @param string $type A relative or absolute type as defined in the phpDocumentor documentation.
         *
         * @psalm-mutation-free
         */
        private function isPartialStructuralElementName(string $type): bool {}

        /**
         * Tests whether the given type is a Fully Qualified Structural Element Name.
         *
         * @psalm-mutation-free
         */
        private function isFqsen(string $type): bool {}

        /**
         * Resolves the given keyword (such as `string`) into a Type object representing that keyword.
         *
         * @psalm-mutation-free
         */
        private function resolveKeyword(string $type): \phpDocumentor\Reflection\Type {}

        /**
         * Resolves the given FQSEN string into an FQSEN object.
         *
         * @psalm-mutation-free
         */
        private function resolveTypedObject(string $type, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\Types\Object_ {}

        /**
         * Resolves class string
         *
         * @param ArrayIterator<int, (string|null)> $tokens
         */
        private function resolveClassString(\ArrayIterator $tokens, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Type {}

        /**
         * Resolves the collection values and keys
         *
         * @param ArrayIterator<int, (string|null)> $tokens
         *
         * @return Array_|Iterable_|Collection
         */
        private function resolveCollection(\ArrayIterator $tokens, \phpDocumentor\Reflection\Type $classType, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Type {}

        /**
         * @psalm-pure
         */
        private function makeCollectionFromObject(\phpDocumentor\Reflection\Types\Object_ $object, \phpDocumentor\Reflection\Type $valueType, ?\phpDocumentor\Reflection\Type $keyType = null): \phpDocumentor\Reflection\Types\Collection {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Factory
{

    /**
     * @deprecated This contract is totally covered by Tag contract. Every class using StaticMethod also use Tag
     */
    interface StaticMethod
    {
        /**
         * @return mixed
         */
        public static function create(string $body);

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Formatter
{
    use phpDocumentor\Reflection\DocBlock\Tag;
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter;
    use max;
    use str_repeat;
    use strlen;

    class AlignFormatter implements \phpDocumentor\Reflection\DocBlock\Tags\Formatter
    {
        /** @var int The maximum tag name length. */
        protected $maxLen = 0;

        /**
         * @param Tag[] $tags All tags that should later be aligned with the formatter.
         */
        public function __construct(array $tags) {}

        /**
         * Formats the given tag to return a simple plain text version.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Formatter
{
    use phpDocumentor\Reflection\DocBlock\Tag;
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter;
    use trim;

    class PassthroughFormatter implements \phpDocumentor\Reflection\DocBlock\Tags\Formatter
    {
        /**
         * Formats the given tag to return a simple plain text version.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Reference
{
    use phpDocumentor\Reflection\Fqsen as RealFqsen;

    /**
     * Fqsen reference used by {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    final class Fqsen implements \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference
    {
        /** @var RealFqsen */
        private $fqsen;

        public function __construct(\phpDocumentor\Reflection\Fqsen $fqsen) {}

        /**
         * @return string string representation of the referenced fqsen
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Reference
{

    /**
     * Interface for references in {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    interface Reference
    {
        public function __toString(): string;

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags\Reference
{
    use Webmozart\Assert\Assert;

    /**
     * Url reference used by {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    final class Url implements \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference
    {
        /** @var string */
        private $uri;

        public function __construct(string $uri) {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use InvalidArgumentException;
    use filter_var;
    use preg_match;
    use trim;
    use FILTER_VALIDATE_EMAIL;

    /**
     * Reflection class for an {@}author tag in a Docblock.
     */
    final class Author extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string register that this is the author tag. */
        protected $name = 'author';

        /** @var string The name of the author */
        private $authorName;

        /** @var string The email of the author */
        private $authorEmail;

        /**
         * Initializes this tag with the author name and e-mail.
         */
        public function __construct(string $authorName, string $authorEmail) {}

        /**
         * Gets the author's name.
         *
         * @return string The author's name.
         */
        public function getAuthorName(): string {}

        /**
         * Returns the author's email.
         *
         * @return string The author's email.
         */
        public function getEmail(): string {}

        /**
         * Returns this tag in string form.
         */
        public function __toString(): string {}

        /**
         * Attempts to create a new Author object based on †he tag body.
         */
        public static function create(string $body): ?self {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock;
    use phpDocumentor\Reflection\DocBlock\Description;

    /**
     * Parses a tag definition for a DocBlock.
     */
    abstract class BaseTag implements \phpDocumentor\Reflection\DocBlock\Tag
    {
        /** @var string Name of the tag */
        protected $name = '';

        /** @var Description|null Description of the tag. */
        protected $description;

        /**
         * Gets the name of this tag.
         *
         * @return string The name of this tag.
         */
        public function getName(): string {}

        public function getDescription(): ?\phpDocumentor\Reflection\DocBlock\Description {}

        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\FqsenResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_key_exists;
    use explode;

    /**
     * Reflection class for a @covers tag in a Docblock.
     */
    final class Covers extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'covers';

        /** @var Fqsen */
        private $refers;

        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\Fqsen $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\FqsenResolver $resolver = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        private static function resolveFqsen(string $parts, ?\phpDocumentor\Reflection\FqsenResolver $fqsenResolver, ?\phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns the structural element this tag refers to.
         */
        public function getReference(): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;
    use preg_match;

    /**
     * Reflection class for a {@}deprecated tag in a Docblock.
     */
    final class Deprecated extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';

        /** @var string */
        protected $name = 'deprecated';

        /** @var string|null The version vector. */
        private $version;

        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        /**
         * @return static
         */
        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Tag;
    use Webmozart\Assert\Assert;
    use array_key_exists;
    use preg_match;
    use rawurlencode;
    use str_replace;
    use strpos;
    use trim;

    /**
     * Reflection class for a {@}example tag in a Docblock.
     */
    final class Example implements \phpDocumentor\Reflection\DocBlock\Tag, \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string Path to a file to use as an example. May also be an absolute URI. */
        private $filePath;

        /**
         * @var bool Whether the file path component represents an URI. This determines how the file portion
         *     appears at {@link getContent()}.
         */
        private $isURI;

        /** @var int */
        private $startingLine;

        /** @var int */
        private $lineCount;

        /** @var string|null */
        private $content;

        public function __construct(string $filePath, bool $isURI, int $startingLine, int $lineCount, ?string $content) {}

        public function getContent(): string {}

        public function getDescription(): ?string {}

        public static function create(string $body): ?\phpDocumentor\Reflection\DocBlock\Tag {}

        /**
         * Returns the file path.
         *
         * @return string Path to a file to use as an example.
         *     May also be an absolute URI.
         */
        public function getFilePath(): string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

        /**
         * Returns true if the provided URI is relative or contains a complete scheme (and thus is absolute).
         */
        private function isUriRelative(string $uri): bool {}

        public function getStartingLine(): int {}

        public function getLineCount(): int {}

        public function getName(): string {}

        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Tag;

    interface Formatter
    {
        /**
         * Formats a tag into a string representation according to a specific format, such as Markdown.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string;

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\DocBlock\StandardTagFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;
    use preg_match;

    /**
     * Parses a tag definition for a DocBlock.
     */
    final class Generic extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Parses a tag and populates the member variables.
         *
         * @param string      $name        Name of the tag.
         * @param Description $description The contents of the given tag.
         */
        public function __construct(string $name, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        /**
         * Creates a new tag that represents any unknown tag type.
         *
         * @return static
         */
        public static function create(string $body, string $name = '', ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the tag as a serialized string
         */
        public function __toString(): string {}

        /**
         * Validates if the tag name matches the expected format, otherwise throws an exception.
         */
        private function validateTagName(string $name): \void {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use Closure;
    use Exception;
    use phpDocumentor\Reflection\DocBlock\Tag;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionFunction;
    use Throwable;
    use array_map;
    use get_class;
    use get_resource_type;
    use is_array;
    use is_object;
    use is_resource;
    use sprintf;

    /**
     * This class represents an exception during the tag creation
     *
     * Since the internals of the library are relaying on the correct syntax of a docblock
     * we cannot simply throw exceptions at all time because the exceptions will break the creation of a
     * docklock. Just silently ignore the exceptions is not an option because the user as an issue to fix.
     *
     * This tag holds that error information until a using application is able to display it. The object wil just behave
     * like any normal tag. So the normal application flow will not break.
     */
    final class InvalidTag implements \phpDocumentor\Reflection\DocBlock\Tag
    {
        /** @var string */
        private $name;

        /** @var string */
        private $body;

        /** @var Throwable|null */
        private $throwable;

        private function __construct(string $name, string $body) {}

        public function getException(): ?\Throwable {}

        public function getName(): string {}

        public static function create(string $body, string $name = ''): self {}

        public function withError(\Throwable $exception): self {}

        /**
         * Removes all complex types from backtrace
         *
         * Not all objects are serializable. So we need to remove them from the
         * stored exception to be sure that we do not break existing library usage.
         */
        private function flattenExceptionBacktrace(\Throwable $exception): \void {}

        /**
         * @param mixed $value
         *
         * @return mixed
         *
         * @throws ReflectionException
         */
        private function flattenArguments($value) {}

        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;

    /**
     * Reflection class for a {@}link tag in a Docblock.
     */
    final class Link extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'link';

        /** @var string */
        private $link;

        /**
         * Initializes a link to a URL.
         */
        public function __construct(string $link, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Gets the link
         */
        public function getLink(): string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Types\Mixed_;
    use phpDocumentor\Reflection\Types\Void_;
    use Webmozart\Assert\Assert;
    use array_keys;
    use explode;
    use implode;
    use is_string;
    use preg_match;
    use sort;
    use strpos;
    use substr;
    use trim;
    use var_export;

    /**
     * Reflection class for an {@}method in a Docblock.
     */
    final class Method extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'method';

        /** @var string */
        private $methodName;

        /**
         * @phpstan-var array<int, array{name: string, type: Type}>
         * @var array<int, array<string, Type|string>>
         */
        private $arguments;

        /** @var bool */
        private $isStatic;

        /** @var Type */
        private $returnType;

        /**
         * @param array<int, array<string, Type|string>> $arguments
         *
         * @phpstan-param array<int, array{name: string, type: Type}|string> $arguments
         */
        public function __construct(string $methodName, array $arguments = [/** value is missing */], ?\phpDocumentor\Reflection\Type $returnType = null, bool $static = false, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self {}

        /**
         * Retrieves the method name.
         */
        public function getMethodName(): string {}

        /**
         * @return array<int, array<string, Type|string>>
         *
         * @phpstan-return array<int, array{name: string, type: Type}>
         */
        public function getArguments(): array {}

        /**
         * Checks whether the method tag describes a static method or not.
         *
         * @return bool TRUE if the method declaration is for a static method, FALSE otherwise.
         */
        public function isStatic(): bool {}

        public function getReturnType(): \phpDocumentor\Reflection\Type {}

        public function __toString(): string {}

        /**
         * @param mixed[][]|string[] $arguments
         *
         * @return mixed[][]
         *
         * @phpstan-param array<int, array{name: string, type: Type}|string> $arguments
         * @phpstan-return array<int, array{name: string, type: Type}>
         */
        private function filterArguments(array $arguments = [/** value is missing */]): array {}

        private static function stripRestArg(string $argument): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_shift;
    use array_unshift;
    use implode;
    use strpos;
    use substr;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Reflection class for the {@}param tag in a Docblock.
     */
    final class Param extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string|null */
        private $variableName;

        /** @var bool determines whether this is a variadic argument */
        private $isVariadic;

        /** @var bool determines whether this is passed by reference */
        private $isReference;

        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, bool $isVariadic = false, ?\phpDocumentor\Reflection\DocBlock\Description $description = null, bool $isReference = false) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string {}

        /**
         * Returns whether this tag is variadic.
         */
        public function isVariadic(): bool {}

        /**
         * Returns whether this tag is passed by reference.
         */
        public function isReference(): bool {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

        private static function strStartsWithVariable(string $str): bool {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_shift;
    use array_unshift;
    use implode;
    use strpos;
    use substr;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Reflection class for a {@}property tag in a Docblock.
     */
    final class Property extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string|null */
        protected $variableName;

        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_shift;
    use array_unshift;
    use implode;
    use strpos;
    use substr;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Reflection class for a {@}property-read tag in a Docblock.
     */
    final class PropertyRead extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string|null */
        protected $variableName;

        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_shift;
    use array_unshift;
    use implode;
    use strpos;
    use substr;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Reflection class for a {@}property-write tag in a Docblock.
     */
    final class PropertyWrite extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $variableName;

        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;

    /**
     * Reflection class for a {@}return tag in a Docblock.
     */
    final class Return_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\DocBlock\Tags\Reference\Fqsen as FqsenRef;
    use phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference;
    use phpDocumentor\Reflection\DocBlock\Tags\Reference\Url;
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\FqsenResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_key_exists;
    use explode;
    use preg_match;

    /**
     * Reflection class for an {@}see tag in a Docblock.
     */
    final class See extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'see';

        /** @var Reference */
        protected $refers;

        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\FqsenResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        private static function resolveFqsen(string $parts, ?\phpDocumentor\Reflection\FqsenResolver $fqsenResolver, ?\phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns the ref of this tag.
         */
        public function getReference(): \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference {}

        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;
    use preg_match;

    /**
     * Reflection class for a {@}since tag in a Docblock.
     */
    final class Since extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';

        /** @var string */
        protected $name = 'since';

        /** @var string|null The version vector. */
        private $version;

        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self {}

        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;
    use preg_match;

    /**
     * Reflection class for a {@}source tag in a Docblock.
     */
    final class Source extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'source';

        /** @var int The starting line, relative to the structural element's location. */
        private $startingLine;

        /** @var int|null The number of lines, relative to the starting line. NULL means "to the end". */
        private $lineCount;

        /**
         * @param int|string      $startingLine should be a to int convertible value
         * @param int|string|null $lineCount    should be a to int convertible value
         */
        public function __construct($startingLine, $lineCount = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Gets the starting line.
         *
         * @return int The starting line, relative to the structural element's
         *     location.
         */
        public function getStartingLine(): int {}

        /**
         * Returns the number of lines.
         *
         * @return int|null The number of lines, relative to the starting line. NULL
         *     means "to the end".
         */
        public function getLineCount(): ?int {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\Type;
    use in_array;
    use strlen;
    use substr;
    use trim;

    abstract class TagWithType extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag
    {
        /** @var ?Type */
        protected $type;

        /**
         * Returns the type section of the variable.
         */
        public function getType(): ?\phpDocumentor\Reflection\Type {}

        /**
         * @return string[]
         */
        protected static function extractTypeFromBody(string $body): array {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;

    /**
     * Reflection class for a {@}throws tag in a Docblock.
     */
    final class Throws extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\FqsenResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_key_exists;
    use explode;

    /**
     * Reflection class for a {@}uses tag in a Docblock.
     */
    final class Uses extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string */
        protected $name = 'uses';

        /** @var Fqsen */
        protected $refers;

        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\Fqsen $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\FqsenResolver $resolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        private static function resolveFqsen(string $parts, ?\phpDocumentor\Reflection\FqsenResolver $fqsenResolver, ?\phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns the structural element this tag refers to.
         */
        public function getReference(): \phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\TypeResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use Webmozart\Assert\Assert;
    use array_shift;
    use array_unshift;
    use implode;
    use strpos;
    use substr;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Reflection class for a {@}var tag in a Docblock.
     */
    final class Var_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /** @var string|null */
        protected $variableName = '';

        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self {}

        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock\Tags
{
    use phpDocumentor\Reflection\DocBlock\Description;
    use phpDocumentor\Reflection\DocBlock\DescriptionFactory;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use Webmozart\Assert\Assert;
    use preg_match;

    /**
     * Reflection class for a {@}version tag in a Docblock.
     */
    final class Version extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';

        /** @var string */
        protected $name = 'version';

        /** @var string|null The version vector. */
        private $version;

        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null) {}

        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self {}

        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string {}

        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter;
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter\PassthroughFormatter;
    use vsprintf;

    /**
     * Object representing to description for a DocBlock.
     *
     * A Description object can consist of plain text but can also include tags. A Description Formatter can then combine
     * a body template with sprintf-style placeholders together with formatted tags in order to reconstitute a complete
     * description text using the format that you would prefer.
     *
     * Because parsing a Description text can be a verbose process this is handled by the {@see DescriptionFactory}. It is
     * thus recommended to use that to create a Description object, like this:
     *
     *     $description = $descriptionFactory->create('This is a {@see Description}', $context);
     *
     * The description factory will interpret the given body and create a body template and list of tags from them, and pass
     * that onto the constructor if this class.
     *
     * > The $context variable is a class of type {@see \phpDocumentor\Reflection\Types\Context} and contains the namespace
     * > and the namespace aliases that apply to this DocBlock. These are used by the Factory to resolve and expand partial
     * > type names and FQSENs.
     *
     * If you do not want to use the DescriptionFactory you can pass a body template and tag listing like this:
     *
     *     $description = new Description(
     *         'This is a %1$s',
     *         [ new See(new Fqsen('\phpDocumentor\Reflection\DocBlock\Description')) ]
     *     );
     *
     * It is generally recommended to use the Factory as that will also apply escaping rules, while the Description object
     * is mainly responsible for rendering.
     *
     * @see DescriptionFactory to create a new Description.
     * @see Description\Formatter for the formatting of the body and tags.
     */
    class Description
    {
        /** @var string */
        private $bodyTemplate;

        /** @var Tag[] */
        private $tags;

        /**
         * Initializes a Description with its body (template) and a listing of the tags used in the body template.
         *
         * @param Tag[] $tags
         */
        public function __construct(string $bodyTemplate, array $tags = [/** value is missing */]) {}

        /**
         * Returns the body template.
         */
        public function getBodyTemplate(): string {}

        /**
         * Returns the tags for this DocBlock.
         *
         * @return Tag[]
         */
        public function getTags(): array {}

        /**
         * Renders this description as a string where the provided formatter will format the tags in the expected string
         * format.
         */
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string {}

        /**
         * Returns a plain string representation of this description.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use phpDocumentor\Reflection\Utils;
    use count;
    use explode;
    use implode;
    use ltrim;
    use min;
    use str_replace;
    use strlen;
    use strpos;
    use substr;
    use trim;
    use PREG_SPLIT_DELIM_CAPTURE;

    /**
     * Creates a new Description object given a body of text.
     *
     * Descriptions in phpDocumentor are somewhat complex entities as they can contain one or more tags inside their
     * body that can be replaced with a readable output. The replacing is done by passing a Formatter object to the
     * Description object's `render` method.
     *
     * In addition to the above does a Description support two types of escape sequences:
     *
     * 1. `{@}` to escape the `@` character to prevent it from being interpreted as part of a tag, i.e. `{{@}link}`
     * 2. `{}` to escape the `}` character, this can be used if you want to use the `}` character in the description
     *    of an inline tag.
     *
     * If a body consists of multiple lines then this factory will also remove any superfluous whitespace at the beginning
     * of each line while maintaining any indentation that is used. This will prevent formatting parsers from tripping
     * over unexpected spaces as can be observed with tag descriptions.
     */
    class DescriptionFactory
    {
        /** @var TagFactory */
        private $tagFactory;

        /**
         * Initializes this factory with the means to construct (inline) tags.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\TagFactory $tagFactory) {}

        /**
         * Returns the parsed text of this description.
         */
        public function create(string $contents, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Description {}

        /**
         * Strips the contents from superfluous whitespace and splits the description into a series of tokens.
         *
         * @return string[] A series of tokens of which the description text is composed.
         */
        private function lex(string $contents): array {}

        /**
         * Removes the superfluous from a multi-line description.
         *
         * When a description has more than one line then it can happen that the second and subsequent lines have an
         * additional indentation. This is commonly in use with tags like this:
         *
         *     {@}since 1.1.0 This is an example
         *         description where we have an
         *         indentation in the second and
         *         subsequent lines.
         *
         * If we do not normalize the indentation then we have superfluous whitespace on the second and subsequent
         * lines and this may cause rendering issues when, for example, using a Markdown converter.
         */
        private function removeSuperfluousStartingWhitespace(string $contents): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use phpDocumentor\Reflection\DocBlock\Tags\Example;
    use array_slice;
    use file;
    use getcwd;
    use implode;
    use is_readable;
    use rtrim;
    use sprintf;
    use trim;
    use DIRECTORY_SEPARATOR;

    /**
     * Class used to find an example file's location based on a given ExampleDescriptor.
     */
    class ExampleFinder
    {
        /** @var string */
        private $sourceDirectory = '';

        /** @var string[] */
        private $exampleDirectories = [/** value is missing */];

        /**
         * Attempts to find the example contents for the given descriptor.
         */
        public function find(\phpDocumentor\Reflection\DocBlock\Tags\Example $example): string {}

        /**
         * Registers the project's root directory where an 'examples' folder can be expected.
         */
        public function setSourceDirectory(string $directory = ''): \void {}

        /**
         * Returns the project's root directory where an 'examples' folder can be expected.
         */
        public function getSourceDirectory(): string {}

        /**
         * Registers a series of directories that may contain examples.
         *
         * @param string[] $directories
         */
        public function setExampleDirectories(array $directories): \void {}

        /**
         * Returns a series of directories that may contain examples.
         *
         * @return string[]
         */
        public function getExampleDirectories(): array {}

        /**
         * Attempts to find the requested example file and returns its contents or null if no file was found.
         *
         * This method will try several methods in search of the given example file, the first one it encounters is
         * returned:
         *
         * 1. Iterates through all examples folders for the given filename
         * 2. Checks the source folder for the given filename
         * 3. Checks the 'examples' folder in the current working directory for examples
         * 4. Checks the path relative to the current working directory for the given filename
         *
         * @return string[] all lines of the example file
         */
        private function getExampleFileContents(string $filename): ?array {}

        /**
         * Get example filepath based on the example directory inside your project.
         */
        private function getExamplePathFromExampleDirectory(string $file): string {}

        /**
         * Returns a path to the example file in the given directory..
         */
        private function constructExamplePath(string $directory, string $file): string {}

        /**
         * Get example filepath based on sourcecode.
         */
        private function getExamplePathFromSource(string $file): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use phpDocumentor\Reflection\DocBlock;
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter;
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter\PassthroughFormatter;
    use sprintf;
    use str_repeat;
    use str_replace;
    use strlen;
    use wordwrap;

    /**
     * Converts a DocBlock back from an object to a complete DocComment including Asterisks.
     */
    class Serializer
    {
        /** @var string The string to indent the comment with. */
        protected $indentString = ' ';

        /** @var int The number of times the indent string is repeated. */
        protected $indent = 0;

        /** @var bool Whether to indent the first line with the given indent amount and string. */
        protected $isFirstLineIndented = true;

        /** @var int|null The max length of a line. */
        protected $lineLength;

        /** @var Formatter A custom tag formatter. */
        protected $tagFormatter;

        /**
         * Create a Serializer instance.
         *
         * @param int       $indent          The number of times the indent string is repeated.
         * @param string    $indentString    The string to indent the comment with.
         * @param bool      $indentFirstLine Whether to indent the first line.
         * @param int|null  $lineLength      The max length of a line or NULL to disable line wrapping.
         * @param Formatter $tagFormatter    A custom tag formatter, defaults to PassthroughFormatter.
         */
        public function __construct(int $indent = 0, string $indentString = ' ', bool $indentFirstLine = true, ?int $lineLength = null, ?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $tagFormatter = null) {}

        /**
         * Generate a DocBlock comment.
         *
         * @param DocBlock $docblock The DocBlock to serialize.
         *
         * @return string The serialized doc block.
         */
        public function getDocComment(\phpDocumentor\Reflection\DocBlock $docblock): string {}

        private function removeTrailingSpaces(string $indent, string $text): string {}

        private function addAsterisksForEachLine(string $indent, string $text): string {}

        private function getSummaryAndDescriptionTextBlock(\phpDocumentor\Reflection\DocBlock $docblock, ?int $wrapLength): string {}

        private function addTagBlock(\phpDocumentor\Reflection\DocBlock $docblock, ?int $wrapLength, string $indent, string $comment): string {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\DocBlock\Tags\Author;
    use phpDocumentor\Reflection\DocBlock\Tags\Covers;
    use phpDocumentor\Reflection\DocBlock\Tags\Deprecated;
    use phpDocumentor\Reflection\DocBlock\Tags\Generic;
    use phpDocumentor\Reflection\DocBlock\Tags\InvalidTag;
    use phpDocumentor\Reflection\DocBlock\Tags\Link as LinkTag;
    use phpDocumentor\Reflection\DocBlock\Tags\Method;
    use phpDocumentor\Reflection\DocBlock\Tags\Param;
    use phpDocumentor\Reflection\DocBlock\Tags\Property;
    use phpDocumentor\Reflection\DocBlock\Tags\PropertyRead;
    use phpDocumentor\Reflection\DocBlock\Tags\PropertyWrite;
    use phpDocumentor\Reflection\DocBlock\Tags\Return_;
    use phpDocumentor\Reflection\DocBlock\Tags\See as SeeTag;
    use phpDocumentor\Reflection\DocBlock\Tags\Since;
    use phpDocumentor\Reflection\DocBlock\Tags\Source;
    use phpDocumentor\Reflection\DocBlock\Tags\Throws;
    use phpDocumentor\Reflection\DocBlock\Tags\Uses;
    use phpDocumentor\Reflection\DocBlock\Tags\Var_;
    use phpDocumentor\Reflection\DocBlock\Tags\Version;
    use phpDocumentor\Reflection\FqsenResolver;
    use phpDocumentor\Reflection\Types\Context as TypeContext;
    use ReflectionMethod;
    use ReflectionNamedType;
    use ReflectionParameter;
    use Webmozart\Assert\Assert;
    use array_merge;
    use array_slice;
    use call_user_func_array;
    use count;
    use get_class;
    use preg_match;
    use strpos;
    use trim;

    /**
     * Creates a Tag object given the contents of a tag.
     *
     * This Factory is capable of determining the appropriate class for a tag and instantiate it using its `create`
     * factory method. The `create` factory method of a Tag can have a variable number of arguments; this way you can
     * pass the dependencies that you need to construct a tag object.
     *
     * > Important: each parameter in addition to the body variable for the `create` method must default to null, otherwise
     * > it violates the constraint with the interface; it is recommended to use the {@see Assert::notNull()} method to
     * > verify that a dependency is actually passed.
     *
     * This Factory also features a Service Locator component that is used to pass the right dependencies to the
     * `create` method of a tag; each dependency should be registered as a service or as a parameter.
     *
     * When you want to use a Tag of your own with custom handling you need to call the `registerTagHandler` method, pass
     * the name of the tag and a Fully Qualified Class Name pointing to a class that implements the Tag interface.
     */
    final class StandardTagFactory implements \phpDocumentor\Reflection\DocBlock\TagFactory
    {
        /** PCRE regular expression matching a tag name. */
        const REGEX_TAGNAME = '[\w\-\_\\:]+';

        /**
         * @var array<class-string<Tag>> An array with a tag as a key, and an
         *                               FQCN to a class that handles it as an array value.
         */
        private $tagHandlerMappings = [/** value is missing */];

        /**
         * @var array<class-string<Tag>> An array with a anotation s a key, and an
         *      FQCN to a class that handles it as an array value.
         */
        private $annotationMappings = [/** value is missing */];

        /**
         * @var ReflectionParameter[][] a lazy-loading cache containing parameters
         *      for each tagHandler that has been used.
         */
        private $tagHandlerParameterCache = [/** value is missing */];

        /** @var FqsenResolver */
        private $fqsenResolver;

        /**
         * @var mixed[] an array representing a simple Service Locator where we can store parameters and
         *     services that can be inserted into the Factory Methods of Tag Handlers.
         */
        private $serviceLocator = [/** value is missing */];

        /**
         * Initialize this tag factory with the means to resolve an FQSEN and optionally a list of tag handlers.
         *
         * If no tag handlers are provided than the default list in the {@see self::$tagHandlerMappings} property
         * is used.
         *
         * @see self::registerTagHandler() to add a new tag handler to the existing default list.
         *
         * @param array<class-string<Tag>> $tagHandlers
         */
        public function __construct(\phpDocumentor\Reflection\FqsenResolver $fqsenResolver, ?array $tagHandlers = null) {}

        public function create(string $tagLine, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Tag {}

        /**
         * @param mixed $value
         */
        public function addParameter(string $name, $value): \void {}

        public function addService(object $service, ?string $alias = null): \void {}

        public function registerTagHandler(string $tagName, string $handler): \void {}

        /**
         * Extracts all components for a tag.
         *
         * @return string[]
         */
        private function extractTagParts(string $tagLine): array {}

        /**
         * Creates a new tag object with the given name and body or returns null if the tag name was recognized but the
         * body was invalid.
         */
        private function createTag(string $body, string $name, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag {}

        /**
         * Determines the Fully Qualified Class Name of the Factory or Tag (containing a Factory Method `create`).
         *
         * @return class-string<Tag>
         */
        private function findHandlerClassName(string $tagName, \phpDocumentor\Reflection\Types\Context $context): string {}

        /**
         * Retrieves the arguments that need to be passed to the Factory Method with the given Parameters.
         *
         * @param ReflectionParameter[] $parameters
         * @param mixed[]               $locator
         *
         * @return mixed[] A series of values that can be passed to the Factory Method of the tag whose parameters
         *     is provided with this method.
         */
        private function getArgumentsForParametersFromWiring(array $parameters, array $locator): array {}

        /**
         * Retrieves a series of ReflectionParameter objects for the static 'create' method of the given
         * tag handler class name.
         *
         * @param class-string $handlerClassName
         *
         * @return ReflectionParameter[]
         */
        private function fetchParametersForHandlerFactoryMethod(string $handlerClassName): array {}

        /**
         * Returns a copy of this class' Service Locator with added dynamic parameters,
         * such as the tag's name, body and Context.
         *
         * @param TypeContext $context The Context (namespace and aliasses) that may be
         *  passed and is used to resolve FQSENs.
         * @param string      $tagName The name of the tag that may be
         *  passed onto the factory method of the Tag class.
         * @param string      $tagBody The body of the tag that may be
         *  passed onto the factory method of the Tag class.
         *
         * @return mixed[]
         */
        private function getServiceLocatorWithDynamicParameters(\phpDocumentor\Reflection\Types\Context $context, string $tagName, string $tagBody): array {}

        /**
         * Returns whether the given tag belongs to an annotation.
         *
         * @todo this method should be populated once we implement Annotation notation support.
         */
        private function isAnnotation(string $tagContent): bool {}

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use phpDocumentor\Reflection\DocBlock\Tags\Formatter;

    interface Tag
    {
        public function getName(): string;

        /**
         * @return Tag|mixed Class that implements Tag
         *
         * @phpstan-return ?Tag
         */
        public static function create(string $body);

        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string;

        public function __toString(): string;

    }
}

namespace phpDocumentor\Reflection\DocBlock
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\Types\Context as TypeContext;

    interface TagFactory
    {
        /**
         * Adds a parameter to the service locator that can be injected in a tag's factory method.
         *
         * When calling a tag's "create" method we always check the signature for dependencies to inject. One way is to
         * typehint a parameter in the signature so that we can use that interface or class name to inject a dependency
         * (see {@see addService()} for more information on that).
         *
         * Another way is to check the name of the argument against the names in the Service Locator. With this method
         * you can add a variable that will be inserted when a tag's create method is not typehinted and has a matching
         * name.
         *
         * Be aware that there are two reserved names:
         *
         * - name, representing the name of the tag.
         * - body, representing the complete body of the tag.
         *
         * These parameters are injected at the last moment and will override any existing parameter with those names.
         *
         * @param mixed $value
         */
        public function addParameter(string $name, $value): \void;

        /**
         * Factory method responsible for instantiating the correct sub type.
         *
         * @param string $tagLine The text for this tag, including description.
         *
         * @return Tag A new tag object.
         *
         * @throws InvalidArgumentException If an invalid tag line was presented.
         */
        public function create(string $tagLine, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Tag;

        /**
         * Registers a service with the Service Locator using the FQCN of the class or the alias, if provided.
         *
         * When calling a tag's "create" method we always check the signature for dependencies to inject. If a parameter
         * has a typehint then the ServiceLocator is queried to see if a Service is registered for that typehint.
         *
         * Because interfaces are regularly used as type-hints this method provides an alias parameter; if the FQCN of the
         * interface is passed as alias then every time that interface is requested the provided service will be returned.
         */
        public function addService(object $service): \void;

        /**
         * Registers a handler for tags.
         *
         * If you want to use your own tags then you can use this method to instruct the TagFactory
         * to register the name of a tag with the FQCN of a 'Tag Handler'. The Tag handler should implement
         * the {@see Tag} interface (and thus the create method).
         *
         * @param string                    $tagName Name of tag to register a handler for. When registering a namespaced
         *                                   tag, the full name, along with a prefixing slash MUST be provided.
         * @param class-string<Tag>         $handler FQCN of handler.
         *
         * @throws InvalidArgumentException If the tag name is not a string.
         * @throws InvalidArgumentException If the tag name is namespaced (contains backslashes) but
         *                                   does not start with a backslash.
         * @throws InvalidArgumentException If the handler is not a string.
         * @throws InvalidArgumentException If the handler is not an existing class.
         * @throws InvalidArgumentException If the handler does not implement the {@see Tag} interface.
         */
        public function registerTagHandler(string $tagName, string $handler): \void;

    }
}

namespace phpDocumentor\Reflection\Exception
{
    use InvalidArgumentException;
    use PREG_BACKTRACK_LIMIT_ERROR;
    use PREG_BAD_UTF8_ERROR;
    use PREG_BAD_UTF8_OFFSET_ERROR;
    use PREG_INTERNAL_ERROR;
    use PREG_JIT_STACKLIMIT_ERROR;
    use PREG_NO_ERROR;
    use PREG_RECURSION_LIMIT_ERROR;

    final class PcreException extends \InvalidArgumentException
    {
        public static function createFromPhpError(int $errorCode): self {}

    }
}

namespace phpDocumentor\Reflection\PseudoTypes
{
    use phpDocumentor\Reflection\PseudoType;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\Types\Boolean;
    use class_alias;

    /**
     * Value Object representing the PseudoType 'False', which is a Boolean type.
     *
     * @psalm-immutable
     */
    final class False_ extends \phpDocumentor\Reflection\Types\Boolean implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\PseudoTypes
{
    use phpDocumentor\Reflection\PseudoType;
    use phpDocumentor\Reflection\Type;
    use phpDocumentor\Reflection\Types\Boolean;
    use class_alias;

    /**
     * Value Object representing the PseudoType 'False', which is a Boolean type.
     *
     * @psalm-immutable
     */
    final class True_ extends \phpDocumentor\Reflection\Types\Boolean implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Represents a list of values. This is an abstract class for Array_ and Collection.
     *
     * @psalm-immutable
     */
    abstract class AbstractList implements \phpDocumentor\Reflection\Type
    {
        /** @var Type */
        protected $valueType;

        /** @var Type|null */
        protected $keyType;

        /** @var Type */
        protected $defaultKeyType;

        /**
         * Initializes this representation of an array with the given Type.
         */
        public function __construct(?\phpDocumentor\Reflection\Type $valueType = null, ?\phpDocumentor\Reflection\Type $keyType = null) {}

        /**
         * Returns the type for the keys of this array.
         */
        public function getKeyType(): \phpDocumentor\Reflection\Type {}

        /**
         * Returns the value for the keys of this array.
         */
        public function getValueType(): \phpDocumentor\Reflection\Type {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use ArrayIterator;
    use IteratorAggregate;
    use phpDocumentor\Reflection\Type;
    use array_key_exists;
    use implode;

    /**
     * Base class for aggregated types like Compound and Intersection
     *
     * A Aggregated Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using separator.
     *
     * @psalm-immutable
     * @template-implements IteratorAggregate<int, Type>
     */
    abstract class AggregatedType
    {
        /**
         * @psalm-allow-private-mutation
         * @var array<int, Type>
         */
        private $types = [/** value is missing */];

        /** @var string */
        private $token;

        /**
         * @param array<Type> $types
         */
        public function __construct(array $types, string $token) {}

        /**
         * Returns the type at the given index.
         */
        public function get(int $index): ?\phpDocumentor\Reflection\Type {}

        /**
         * Tests if this compound type has a type with the given index.
         */
        public function has(int $index): bool {}

        /**
         * Tests if this compound type contains the given type.
         */
        public function contains(\phpDocumentor\Reflection\Type $type): bool {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

        /**
         * @return ArrayIterator<int, Type>
         */
        public function getIterator(): \ArrayIterator {}

        /**
         * @psalm-suppress ImpureMethodCall
         */
        private function add(\phpDocumentor\Reflection\Type $type): \void {}

    }
}

namespace phpDocumentor\Reflection\Types
{

    /**
     * Represents an array type as described in the PSR-5, the PHPDoc Standard.
     *
     * An array can be represented in two forms:
     *
     * 1. Untyped (`array`), where the key and value type is unknown and hence classified as 'Mixed_'.
     * 2. Types (`string[]`), where the value type is provided by preceding an opening and closing square bracket with a
     *    type name.
     *
     * @psalm-immutable
     */
    final class Array_ extends \phpDocumentor\Reflection\Types\AbstractList
    {
    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a Boolean type.
     *
     * @psalm-immutable
     */
    class Boolean implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a Callable type.
     *
     * @psalm-immutable
     */
    final class Callable_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class ClassString implements \phpDocumentor\Reflection\Type
    {
        /** @var Fqsen|null */
        private $fqsen;

        /**
         * Initializes this representation of a class string with the given Fqsen.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen = null) {}

        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\Type;

    /**
     * Represents a collection type as described in the PSR-5, the PHPDoc Standard.
     *
     * A collection can be represented in two forms:
     *
     * 1. `ACollectionObject<aValueType>`
     * 2. `ACollectionObject<aValueType,aKeyType>`
     *
     * - ACollectionObject can be 'array' or an object that can act as an array
     * - aValueType and aKeyType can be any type expression
     *
     * @psalm-immutable
     */
    final class Collection extends \phpDocumentor\Reflection\Types\AbstractList
    {
        /** @var Fqsen|null */
        private $fqsen;

        /**
         * Initializes this representation of an array with the given Type or Fqsen.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen, \phpDocumentor\Reflection\Type $valueType, ?\phpDocumentor\Reflection\Type $keyType = null) {}

        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a Compound Type.
     *
     * A Compound Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using an OR operator (`|`). This combination of types signifies that whatever is associated with this compound type
     * may contain a value with any of the given types.
     *
     * @psalm-immutable
     */
    final class Compound extends \phpDocumentor\Reflection\Types\AggregatedType
    {
        /**
         * Initializes a compound type (i.e. `string|int`) and tests if the provided types all implement the Type interface.
         *
         * @param array<Type> $types
         */
        public function __construct(array $types) {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use strlen;
    use substr;
    use trim;

    /**
     * Provides information about the Context in which the DocBlock occurs that receives this context.
     *
     * A DocBlock does not know of its own accord in which namespace it occurs and which namespace aliases are applicable
     * for the block of code in which it is in. This information is however necessary to resolve Class names in tags since
     * you can provide a short form or make use of namespace aliases.
     *
     * The phpDocumentor Reflection component knows how to create this class but if you use the DocBlock parser from your
     * own application it is possible to generate a Context class using the ContextFactory; this will analyze the file in
     * which an associated class resides for its namespace and imports.
     *
     * @see ContextFactory::createFromClassReflector()
     * @see ContextFactory::createForNamespace()
     *
     * @psalm-immutable
     */
    final class Context
    {
        /** @var string The current namespace. */
        private $namespace;

        /**
         * @var string[] List of namespace aliases => Fully Qualified Namespace.
         * @psalm-var array<string, string>
         */
        private $namespaceAliases;

        /**
         * Initializes the new context and normalizes all passed namespaces to be in Qualified Namespace Name (QNN)
         * format (without a preceding `\`).
         *
         * @param string   $namespace        The namespace where this DocBlock resides in.
         * @param string[] $namespaceAliases List of namespace aliases => Fully Qualified Namespace.
         *
         * @psalm-param array<string, string> $namespaceAliases
         */
        public function __construct(string $namespace, array $namespaceAliases = [/** value is missing */]) {}

        /**
         * Returns the Qualified Namespace Name (thus without `\` in front) where the associated element is in.
         */
        public function getNamespace(): string {}

        /**
         * Returns a list of Qualified Namespace Names (thus without `\` in front) that are imported, the keys represent
         * the alias for the imported Namespace.
         *
         * @return string[]
         *
         * @psalm-return array<string, string>
         */
        public function getNamespaceAliases(): array {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use ArrayIterator;
    use InvalidArgumentException;
    use ReflectionClass;
    use ReflectionClassConstant;
    use ReflectionMethod;
    use ReflectionParameter;
    use ReflectionProperty;
    use Reflector;
    use RuntimeException;
    use UnexpectedValueException;
    use define;
    use defined;
    use file_exists;
    use file_get_contents;
    use get_class;
    use in_array;
    use is_string;
    use strrpos;
    use substr;
    use token_get_all;
    use trim;
    use T_AS;
    use T_CLASS;
    use T_CURLY_OPEN;
    use T_DOLLAR_OPEN_CURLY_BRACES;
    use T_NAMESPACE;
    use T_NS_SEPARATOR;
    use T_STRING;
    use T_USE;

    /**
     * Convenience class to create a Context for DocBlocks when not using the Reflection Component of phpDocumentor.
     *
     * For a DocBlock to be able to resolve types that use partial namespace names or rely on namespace imports we need to
     * provide a bit of context so that the DocBlock can read that and based on it decide how to resolve the types to
     * Fully Qualified names.
     *
     * @see Context for more information.
     */
    final class ContextFactory
    {
        /** The literal used at the end of a use statement. */
        const T_LITERAL_END_OF_USE = ';';

        /** The literal used between sets of use statements */
        const T_LITERAL_USE_SEPARATOR = ',';

        /**
         * Build a Context given a Class Reflection.
         *
         * @see Context for more information on Contexts.
         */
        public function createFromReflector(\Reflector $reflector): \phpDocumentor\Reflection\Types\Context {}

        private function createFromReflectionParameter(\ReflectionParameter $parameter): \phpDocumentor\Reflection\Types\Context {}

        private function createFromReflectionMethod(\ReflectionMethod $method): \phpDocumentor\Reflection\Types\Context {}

        private function createFromReflectionProperty(\ReflectionProperty $property): \phpDocumentor\Reflection\Types\Context {}

        private function createFromReflectionClassConstant(\ReflectionClassConstant $constant): \phpDocumentor\Reflection\Types\Context {}

        /**
         * @param ReflectionClass<object> $class
         */
        private function createFromReflectionClass(\ReflectionClass $class): \phpDocumentor\Reflection\Types\Context {}

        /**
         * Build a Context for a namespace in the provided file contents.
         *
         * @see Context for more information on Contexts.
         *
         * @param string $namespace    It does not matter if a `\` precedes the namespace name,
         * this method first normalizes.
         * @param string $fileContents The file's contents to retrieve the aliases from with the given namespace.
         */
        public function createForNamespace(string $namespace, string $fileContents): \phpDocumentor\Reflection\Types\Context {}

        /**
         * Deduce the name from tokens when we are at the T_NAMESPACE token.
         *
         * @param ArrayIterator<int, string|array{0:int,1:string,2:int}> $tokens
         */
        private function parseNamespace(\ArrayIterator $tokens): string {}

        /**
         * Deduce the names of all imports when we are at the T_USE token.
         *
         * @param ArrayIterator<int, string|array{0:int,1:string,2:int}> $tokens
         *
         * @return string[]
         *
         * @psalm-return array<string, string>
         */
        private function parseUseStatement(\ArrayIterator $tokens): array {}

        /**
         * Fast-forwards the iterator as longs as we don't encounter a T_STRING or T_NS_SEPARATOR token.
         *
         * @param ArrayIterator<int, string|array{0:int,1:string,2:int}> $tokens
         */
        private function skipToNextStringOrNamespaceSeparator(\ArrayIterator $tokens): \void {}

        /**
         * Deduce the namespace name and alias of an import when we are at the T_USE token or have not reached the end of
         * a USE statement yet. This will return a key/value array of the alias => namespace.
         *
         * @param ArrayIterator<int, string|array{0:int,1:string,2:int}> $tokens
         *
         * @return string[]
         *
         * @psalm-suppress TypeDoesNotContainType
         *
         * @psalm-return array<string, string>
         */
        private function extractUseStatements(\ArrayIterator $tokens): array {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Represents an expression type as described in the PSR-5, the PHPDoc Standard.
     *
     * @psalm-immutable
     */
    final class Expression implements \phpDocumentor\Reflection\Type
    {
        /** @var Type */
        protected $valueType;

        /**
         * Initializes this representation of an array with the given Type.
         */
        public function __construct(\phpDocumentor\Reflection\Type $valueType) {}

        /**
         * Returns the value for the keys of this array.
         */
        public function getValueType(): \phpDocumentor\Reflection\Type {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a Float.
     *
     * @psalm-immutable
     */
    final class Float_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value object representing Integer type
     *
     * @psalm-immutable
     */
    final class Integer implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a Compound Type.
     *
     * A Intersection Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using an AND operator (`&`). This combination of types signifies that whatever is associated with this Intersection
     * type may contain a value with any of the given types.
     *
     * @psalm-immutable
     */
    final class Intersection extends \phpDocumentor\Reflection\Types\AggregatedType
    {
        /**
         * Initializes a intersection type (i.e. `\A&\B`) and tests if the provided types all implement the Type interface.
         *
         * @param array<Type> $types
         */
        public function __construct(array $types) {}

    }
}

namespace phpDocumentor\Reflection\Types
{

    /**
     * Value Object representing iterable type
     *
     * @psalm-immutable
     */
    final class Iterable_ extends \phpDocumentor\Reflection\Types\AbstractList
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing an unknown, or mixed, type.
     *
     * @psalm-immutable
     */
    final class Mixed_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a null value or type.
     *
     * @psalm-immutable
     */
    final class Null_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing a nullable type. The real type is wrapped.
     *
     * @psalm-immutable
     */
    final class Nullable implements \phpDocumentor\Reflection\Type
    {
        /** @var Type The actual type that is wrapped */
        private $realType;

        /**
         * Initialises this nullable type using the real type embedded
         */
        public function __construct(\phpDocumentor\Reflection\Type $realType) {}

        /**
         * Provide access to the actual type directly, if needed.
         */
        public function getActualType(): \phpDocumentor\Reflection\Type {}

        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use InvalidArgumentException;
    use phpDocumentor\Reflection\Fqsen;
    use phpDocumentor\Reflection\Type;
    use strpos;

    /**
     * Value Object representing an object.
     *
     * An object can be either typed or untyped. When an object is typed it means that it has an identifier, the FQSEN,
     * pointing to an element in PHP. Object types that are untyped do not refer to a specific class but represent objects
     * in general.
     *
     * @psalm-immutable
     */
    final class Object_ implements \phpDocumentor\Reflection\Type
    {
        /** @var Fqsen|null */
        private $fqsen;

        /**
         * Initializes this object with an optional FQSEN, if not provided this object is considered 'untyped'.
         *
         * @throws InvalidArgumentException When provided $fqsen is not a valid type.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen = null) {}

        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen {}

        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the 'parent' type.
     *
     * Parent, as a Type, represents the parent class of class in which the associated element was defined.
     *
     * @psalm-immutable
     */
    final class Parent_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the 'resource' Type.
     *
     * @psalm-immutable
     */
    final class Resource_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the 'scalar' pseudo-type, which is either a string, integer, float or boolean.
     *
     * @psalm-immutable
     */
    final class Scalar implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the 'self' type.
     *
     * Self, as a Type, represents the class in which the associated element was defined.
     *
     * @psalm-immutable
     */
    final class Self_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the 'static' type.
     *
     * Self, as a Type, represents the class in which the associated element was called. This differs from self as self does
     * not take inheritance into account but static means that the return type is always that of the class of the called
     * element.
     *
     * See the documentation on late static binding in the PHP Documentation for more information on the difference between
     * static and self.
     *
     * @psalm-immutable
     */
    final class Static_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class String_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the '$this' pseudo-type.
     *
     * $this, as a Type, represents the instance of the class associated with the element as it was called. $this is
     * commonly used when documenting fluent interfaces since it represents that the same object is returned.
     *
     * @psalm-immutable
     */
    final class This implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace phpDocumentor\Reflection\Types
{
    use phpDocumentor\Reflection\Type;

    /**
     * Value Object representing the pseudo-type 'void'.
     *
     * Void is generally only used when working with return types as it signifies that the method intentionally does not
     * return any value.
     *
     * @psalm-immutable
     */
    final class Void_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Any single value token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class AnyValueToken implements \Prophecy\Argument\Token\TokenInterface
    {
        /**
         * Always scores 3 for any argument.
         *
         * @param $argument
         *
         * @return int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Any values token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class AnyValuesToken implements \Prophecy\Argument\Token\TokenInterface
    {
        /**
         * Always scores 2 for any argument.
         *
         * @param $argument
         *
         * @return int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns true to stop wildcard from processing other tokens.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Approximate value token
     *
     * @author Daniel Leech <daniel@dantleech.com>
     */
    class ApproximateValueToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $value;

        private $precision;

        public function __construct($value, $precision = 0) {}

        /**
         * {@inheritdoc}
         */
        public function scoreArgument($argument) {}

        /**
         * {@inheritdoc}
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Array elements count token.
     *
     * @author Boris Mikhaylov <kaguxmail@gmail.com>
     */
    class ArrayCountToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $count;

        /**
         * @param integer $value
         */
        public function __construct($value) {}

        /**
         * Scores 6 when argument has preset number of elements.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return boolean
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

        /**
         * Returns true if object is either array or instance of \Countable
         *
         * @param $argument
         * @return bool
         */
        private function isCountable($argument) {}

        /**
         * Returns true if $argument has expected number of elements
         *
         * @param array|\Countable $argument
         *
         * @return bool
         */
        private function hasProperCount($argument) {}

    }
}

namespace Prophecy\Argument\Token
{
    use Prophecy\Exception\InvalidArgumentException;

    /**
     * Array entry token.
     *
     * @author Boris Mikhaylov <kaguxmail@gmail.com>
     */
    class ArrayEntryToken implements \Prophecy\Argument\Token\TokenInterface
    {
        /** @var \Prophecy\Argument\Token\TokenInterface */
        private $key;

        /** @var \Prophecy\Argument\Token\TokenInterface */
        private $value;

        /**
         * @param mixed $key   exact value or token
         * @param mixed $value exact value or token
         */
        public function __construct($key, $value) {}

        /**
         * Scores half of combined scores from key and value tokens for same entry. Capped at 8.
         * If argument implements \ArrayAccess without \Traversable, then key token is restricted to ExactValueToken.
         *
         * @param array|\ArrayAccess|\Traversable $argument
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return boolean
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

        /**
         * Returns key
         *
         * @return TokenInterface
         */
        public function getKey() {}

        /**
         * Returns value
         *
         * @return TokenInterface
         */
        public function getValue() {}

        /**
         * Wraps non token $value into ExactValueToken
         *
         * @param $value
         * @return TokenInterface
         */
        private function wrapIntoExactValueToken($value) {}

        /**
         * Converts instance of \ArrayAccess to key => value array entry
         *
         * @param \ArrayAccess $object
         *
         * @return array|null
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        private function convertArrayAccessToEntry(\ArrayAccess $object) {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Array every entry token.
     *
     * @author Adrien Brault <adrien.brault@gmail.com>
     */
    class ArrayEveryEntryToken implements \Prophecy\Argument\Token\TokenInterface
    {
        /**
         * @var TokenInterface
         */
        private $value;

        /**
         * @param mixed $value exact value or token
         */
        public function __construct($value) {}

        /**
         * {@inheritdoc}
         */
        public function scoreArgument($argument) {}

        /**
         * {@inheritdoc}
         */
        public function isLast() {}

        /**
         * {@inheritdoc}
         */
        public function __toString() {}

        /**
         * @return TokenInterface
         */
        public function getValue() {}

    }
}

namespace Prophecy\Argument\Token
{
    use Prophecy\Exception\InvalidArgumentException;

    /**
     * Callback-verified token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallbackToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $callback;

        /**
         * Initializes token.
         *
         * @param callable $callback
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function __construct($callback) {}

        /**
         * Scores 7 if callback returns true, false otherwise.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{
    use SebastianBergmann\Comparator\ComparisonFailure;
    use Prophecy\Comparator\Factory as ComparatorFactory;
    use Prophecy\Util\StringUtil;

    /**
     * Exact value token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ExactValueToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $value;

        private $string;

        private $util;

        private $comparatorFactory;

        /**
         * Initializes token.
         *
         * @param mixed             $value
         * @param StringUtil        $util
         * @param ComparatorFactory $comparatorFactory
         */
        public function __construct($value, ?\Prophecy\Util\StringUtil $util = null, ?\Prophecy\Comparator\Factory $comparatorFactory = null) {}

        /**
         * Scores 10 if argument matches preset value.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns preset value against which token checks arguments.
         *
         * @return mixed
         */
        public function getValue() {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{
    use Prophecy\Util\StringUtil;

    /**
     * Identical value token.
     *
     * @author Florian Voutzinos <florian@voutzinos.com>
     */
    class IdenticalValueToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $value;

        private $string;

        private $util;

        /**
         * Initializes token.
         *
         * @param mixed      $value
         * @param StringUtil $util
         */
        public function __construct($value, ?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Scores 11 if argument matches preset value.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Check if values is in array
     *
     * @author Vinícius Alonso <vba321@hotmail.com>
     */
    class InArrayToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $token = [/** value is missing */];

        private $strict;

        /**
         * @param array $arguments tokens
         * @param bool $strict
         */
        public function __construct(array $arguments, $strict = true) {}

        /**
         * Return scores 8 score if argument is in array.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return boolean
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Logical AND token.
     *
     * @author Boris Mikhaylov <kaguxmail@gmail.com>
     */
    class LogicalAndToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $tokens = [/** value is missing */];

        /**
         * @param array $arguments exact values or tokens
         */
        public function __construct(array $arguments) {}

        /**
         * Scores maximum score from scores returned by tokens for this argument if all of them score.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return boolean
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Logical NOT token.
     *
     * @author Boris Mikhaylov <kaguxmail@gmail.com>
     */
    class LogicalNotToken implements \Prophecy\Argument\Token\TokenInterface
    {
        /** @var \Prophecy\Argument\Token\TokenInterface  */
        private $token;

        /**
         * @param mixed $value exact value or token
         */
        public function __construct($value) {}

        /**
         * Scores 4 when preset token does not match the argument.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns true if preset token is last.
         *
         * @return bool|int
         */
        public function isLast() {}

        /**
         * Returns originating token.
         *
         * @return TokenInterface
         */
        public function getOriginatingToken() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Check if values is not in array
     *
     * @author Vinícius Alonso <vba321@hotmail.com>
     */
    class NotInArrayToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $token = [/** value is missing */];

        private $strict;

        /**
         * @param array $arguments tokens
         * @param bool $strict
         */
        public function __construct(array $arguments, $strict = true) {}

        /**
         * Return scores 8 score if argument is in array.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return boolean
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{
    use SebastianBergmann\Comparator\ComparisonFailure;
    use Prophecy\Comparator\Factory as ComparatorFactory;
    use Prophecy\Util\StringUtil;

    /**
     * Object state-checker token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ObjectStateToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $name;

        private $value;

        private $util;

        private $comparatorFactory;

        /**
         * Initializes token.
         *
         * @param string            $methodName
         * @param mixed             $value             Expected return value
         * @param null|StringUtil   $util
         * @param ComparatorFactory $comparatorFactory
         */
        public function __construct($methodName, $value, ?\Prophecy\Util\StringUtil $util = null, ?\Prophecy\Comparator\Factory $comparatorFactory = null) {}

        /**
         * Scores 8 if argument is an object, which method returns expected value.
         *
         * @param mixed $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * String contains token.
     *
     * @author Peter Mitchell <pete@peterjmit.com>
     */
    class StringContainsToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $value;

        /**
         * Initializes token.
         *
         * @param string $value
         */
        public function __construct($value) {}

        public function scoreArgument($argument) {}

        /**
         * Returns preset value against which token checks arguments.
         *
         * @return mixed
         */
        public function getValue() {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument\Token
{

    /**
     * Argument token interface.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface TokenInterface
    {
        /**
         * Calculates token match score for provided argument.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument);

        /**
         * Returns true if this token prevents check of other tokens (is last one).
         *
         * @return bool|int
         */
        public function isLast();

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString();

    }
}

namespace Prophecy\Argument\Token
{
    use Prophecy\Exception\InvalidArgumentException;

    /**
     * Value type token.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class TypeToken implements \Prophecy\Argument\Token\TokenInterface
    {
        private $type;

        /**
         * @param string $type
         */
        public function __construct($type) {}

        /**
         * Scores 5 if argument has the same type this token was constructed with.
         *
         * @param $argument
         *
         * @return bool|int
         */
        public function scoreArgument($argument) {}

        /**
         * Returns false.
         *
         * @return bool
         */
        public function isLast() {}

        /**
         * Returns string representation for token.
         *
         * @return string
         */
        public function __toString() {}

    }
}

namespace Prophecy\Argument
{

    /**
     * Arguments wildcarding.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ArgumentsWildcard
    {
        /**
         * @var Token\TokenInterface[]
         */
        private $tokens = [/** value is missing */];

        private $string;

        /**
         * Initializes wildcard.
         *
         * @param array $arguments Array of argument tokens or values
         */
        public function __construct(array $arguments) {}

        /**
         * Calculates wildcard match score for provided arguments.
         *
         * @param array $arguments
         *
         * @return false|int False OR integer score (higher - better)
         */
        public function scoreArguments(array $arguments) {}

        /**
         * Returns string representation for wildcard.
         *
         * @return string
         */
        public function __toString() {}

        /**
         * @return array
         */
        public function getTokens() {}

    }
}

namespace Prophecy\Call
{
    use Exception;
    use Prophecy\Argument\ArgumentsWildcard;

    /**
     * Call object.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class Call
    {
        private $methodName;

        private $arguments;

        private $returnValue;

        private $exception;

        private $file;

        private $line;

        private $scores;

        /**
         * Initializes call.
         *
         * @param string      $methodName
         * @param array       $arguments
         * @param mixed       $returnValue
         * @param Exception   $exception
         * @param null|string $file
         * @param null|int    $line
         */
        public function __construct($methodName, array $arguments, $returnValue, ?\Exception $exception = null, $file, $line) {}

        /**
         * Returns called method name.
         *
         * @return string
         */
        public function getMethodName() {}

        /**
         * Returns called method arguments.
         *
         * @return array
         */
        public function getArguments() {}

        /**
         * Returns called method return value.
         *
         * @return null|mixed
         */
        public function getReturnValue() {}

        /**
         * Returns exception that call thrown.
         *
         * @return null|Exception
         */
        public function getException() {}

        /**
         * Returns callee filename.
         *
         * @return string
         */
        public function getFile() {}

        /**
         * Returns callee line number.
         *
         * @return int
         */
        public function getLine() {}

        /**
         * Returns short notation for callee place.
         *
         * @return string
         */
        public function getCallPlace() {}

        /**
         * Adds the wildcard match score for the provided wildcard.
         *
         * @param ArgumentsWildcard $wildcard
         * @param false|int $score
         *
         * @return $this
         */
        public function addScore(\Prophecy\Argument\ArgumentsWildcard $wildcard, $score) {}

        /**
         * Returns wildcard match score for the provided wildcard. The score is
         * calculated if not already done.
         *
         * @param ArgumentsWildcard $wildcard
         *
         * @return false|int False OR integer score (higher - better)
         */
        public function getScore(\Prophecy\Argument\ArgumentsWildcard $wildcard) {}

    }
}

namespace Prophecy\Call
{
    use Prophecy\Exception\Prophecy\MethodProphecyException;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Argument\ArgumentsWildcard;
    use Prophecy\Util\StringUtil;
    use Prophecy\Exception\Call\UnexpectedCallException;
    use SplObjectStorage;

    /**
     * Calls receiver & manager.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallCenter
    {
        private $util;

        /**
         * @var Call[]
         */
        private $recordedCalls = [/** value is missing */];

        /**
         * @var SplObjectStorage
         */
        private $unexpectedCalls;

        /**
         * Initializes call center.
         *
         * @param StringUtil $util
         */
        public function __construct(?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Makes and records specific method call for object prophecy.
         *
         * @param ObjectProphecy $prophecy
         * @param string         $methodName
         * @param array          $arguments
         *
         * @return mixed Returns null if no promise for prophecy found or promise return value.
         *
         * @throws \Prophecy\Exception\Call\UnexpectedCallException If no appropriate method prophecy found
         */
        public function makeCall(\Prophecy\Prophecy\ObjectProphecy $prophecy, $methodName, array $arguments) {}

        /**
         * Searches for calls by method name & arguments wildcard.
         *
         * @param string            $methodName
         * @param ArgumentsWildcard $wildcard
         *
         * @return Call[]
         */
        public function findCalls($methodName, \Prophecy\Argument\ArgumentsWildcard $wildcard) {}

        /**
         * @throws UnexpectedCallException
         */
        public function checkUnexpectedCalls() {}

        private function createUnexpectedCallException(\Prophecy\Prophecy\ObjectProphecy $prophecy, $methodName, array $arguments) {}

        private function indentArguments(array $arguments, $indentationLength) {}

        /**
         * @param ObjectProphecy $prophecy
         * @param string $methodName
         * @param array $arguments
         *
         * @return array
         */
        private function findMethodProphecies(\Prophecy\Prophecy\ObjectProphecy $prophecy, $methodName, array $arguments) {}

    }
}

namespace Prophecy\Comparator
{
    use SebastianBergmann\Comparator\Comparator;
    use SebastianBergmann\Comparator\ComparisonFailure;

    /**
     * Closure comparator.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    final class ClosureComparator extends \SebastianBergmann\Comparator\Comparator
    {
        public function accepts($expected, $actual) {}

        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

    }
}

namespace Prophecy\Comparator
{
    use SebastianBergmann\Comparator\Factory as BaseFactory;

    /**
     * Prophecy comparator factory.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    final class Factory extends \SebastianBergmann\Comparator\Factory
    {
        /**
         * @var Factory
         */
        private static $instance;

        public function __construct() {}

        /**
         * @return Factory
         */
        public static function getInstance() {}

    }
}

namespace Prophecy\Comparator
{
    use Prophecy\Prophecy\ProphecyInterface;
    use SebastianBergmann\Comparator\ObjectComparator;

    class ProphecyComparator extends \SebastianBergmann\Comparator\ObjectComparator
    {
        public function accepts($expected, $actual) {}

        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;

    /**
     * Class patch interface.
     * Class patches extend doubles functionality or help
     * Prophecy to avoid some internal PHP bugs.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface ClassPatchInterface
    {
        /**
         * Checks if patch supports specific class node.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node);

        /**
         * Applies patch to the specific class node.
         *
         * @param ClassNode $node
         * @return void
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node);

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority();

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Doubler\Generator\Node\MethodNode;

    /**
     * Disable constructor.
     * Makes all constructor arguments optional.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class DisableConstructorPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Checks if class has `__construct` method.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Makes all class constructor arguments optional.
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;

    /**
     * Exception patch for HHVM to remove the stubs from special methods
     *
     * @author Christophe Coevoet <stof@notk.org>
     */
    class HhvmExceptionPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Supports exceptions on HHVM.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Removes special exception static methods from the doubled methods.
         *
         * @param ClassNode $node
         *
         * @return void
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * {@inheritdoc}
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;

    /**
     * Remove method functionality from the double which will clash with php keywords.
     *
     * @author Milan Magudia <milan@magudia.com>
     */
    class KeywordPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Support any class
         *
         * @param ClassNode $node
         *
         * @return boolean
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Remove methods that clash with php keywords
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

        /**
         * Returns array of php keywords.
         *
         * @return array
         */
        private function getKeywords() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Doubler\Generator\Node\MethodNode;
    use Prophecy\PhpDocumentor\ClassAndInterfaceTagRetriever;
    use Prophecy\PhpDocumentor\MethodTagRetrieverInterface;

    /**
     * Discover Magical API using "@method" PHPDoc format.
     *
     * @author Thomas Tourlourat <thomas@tourlourat.com>
     * @author Kévin Dunglas <dunglas@gmail.com>
     * @author Théo FIDRY <theo.fidry@gmail.com>
     */
    class MagicCallPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        private $tagRetriever;

        public function __construct(?\Prophecy\PhpDocumentor\MethodTagRetrieverInterface $tagRetriever = null) {}

        /**
         * Support any class
         *
         * @param ClassNode $node
         *
         * @return boolean
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Discover Magical API
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return integer Priority number (higher - earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ArgumentTypeNode;
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Doubler\Generator\Node\MethodNode;
    use Prophecy\Doubler\Generator\Node\ArgumentNode;
    use Prophecy\Doubler\Generator\Node\ReturnTypeNode;

    /**
     * Add Prophecy functionality to the double.
     * This is a core class patch for Prophecy.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ProphecySubjectPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Always returns true.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Apply Prophecy functionality to class node.
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;

    /**
     * ReflectionClass::newInstance patch.
     * Makes first argument of newInstance optional, since it works but signature is misleading
     *
     * @author Florian Klein <florian.klein@free.fr>
     */
    class ReflectionClassNewInstancePatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Supports ReflectionClass
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Updates newInstance's first argument to make it optional
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher = earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Doubler\Generator\Node\MethodNode;

    /**
     * SplFileInfo patch.
     * Makes SplFileInfo and derivative classes usable with Prophecy.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class SplFileInfoPatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Supports everything that extends SplFileInfo.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Updated constructor code to call parent one with dummy file argument.
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

        /**
         * @param ClassNode $node
         * @return boolean
         */
        private function nodeIsDirectoryIterator(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * @param ClassNode $node
         * @return boolean
         */
        private function nodeIsSplFileObject(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * @param ClassNode $node
         * @return boolean
         */
        private function nodeIsSymfonySplFileInfo(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Exception\Doubler\ClassCreatorException;

    class ThrowablePatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Checks if patch supports specific class node.
         *
         * @param ClassNode $node
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * @param ClassNode $node
         * @return bool
         */
        private function implementsAThrowableInterface(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * @param ClassNode $node
         * @return bool
         */
        private function doesNotExtendAThrowableClass(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Applies patch to the specific class node.
         *
         * @param ClassNode $node
         *
         * @return void
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        private function checkItCanBeDoubled(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        private function setParentClassToException(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\ClassPatch
{
    use Prophecy\Doubler\Generator\Node\ClassNode;
    use Prophecy\Doubler\Generator\Node\MethodNode;

    /**
     * Traversable interface patch.
     * Forces classes that implement interfaces, that extend Traversable to also implement Iterator.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class TraversablePatch implements \Prophecy\Doubler\ClassPatch\ClassPatchInterface
    {
        /**
         * Supports nodetree, that implement Traversable, but not Iterator or IteratorAggregate.
         *
         * @param ClassNode $node
         *
         * @return bool
         */
        public function supports(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Forces class to implement Iterator interface.
         *
         * @param ClassNode $node
         */
        public function apply(\Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        /**
         * Returns patch priority, which determines when patch will be applied.
         *
         * @return int Priority number (higher - earlier)
         */
        public function getPriority() {}

    }
}

namespace Prophecy\Doubler\Generator\Node
{

    /**
     * Argument node.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ArgumentNode
    {
        private $name;

        private $default;

        private $optional = false;

        private $byReference = false;

        private $isVariadic = false;

        /** @var ArgumentTypeNode */
        private $typeNode;

        /**
         * @param string $name
         */
        public function __construct($name) {}

        public function getName() {}

        public function setTypeNode(\Prophecy\Doubler\Generator\Node\ArgumentTypeNode $typeNode) {}

        public function getTypeNode(): \Prophecy\Doubler\Generator\Node\ArgumentTypeNode {}

        public function hasDefault() {}

        public function getDefault() {}

        public function setDefault($default = null) {}

        public function isOptional() {}

        public function setAsPassedByReference($byReference = true) {}

        public function isPassedByReference() {}

        public function setAsVariadic($isVariadic = true) {}

        public function isVariadic() {}

        /**
         * @deprecated use getArgumentTypeNode instead
         * @return string|null
         */
        public function getTypeHint() {}

        /**
         * @deprecated use setArgumentTypeNode instead
         * @param string|null $typeHint
         */
        public function setTypeHint($typeHint = null) {}

        /**
         * @deprecated use getArgumentTypeNode instead
         * @return bool
         */
        public function isNullable() {}

        /**
         * @deprecated use getArgumentTypeNode instead
         * @param bool $isNullable
         */
        public function setAsNullable($isNullable = true) {}

    }
}

namespace Prophecy\Doubler\Generator\Node
{
    use Prophecy\Exception\Doubler\DoubleException;

    class ArgumentTypeNode extends \Prophecy\Doubler\Generator\Node\TypeNodeAbstract
    {
    }
}

namespace Prophecy\Doubler\Generator\Node
{
    use Prophecy\Exception\Doubler\MethodNotExtendableException;
    use Prophecy\Exception\InvalidArgumentException;

    /**
     * Class node.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ClassNode
    {
        private $parentClass = 'stdClass';

        private $interfaces = [/** value is missing */];

        private $properties = [/** value is missing */];

        private $unextendableMethods = [/** value is missing */];

        /**
         * @var MethodNode[]
         */
        private $methods = [/** value is missing */];

        public function getParentClass() {}

        /**
         * @param string $class
         */
        public function setParentClass($class) {}

        /**
         * @return string[]
         */
        public function getInterfaces() {}

        /**
         * @param string $interface
         */
        public function addInterface($interface) {}

        /**
         * @param string $interface
         *
         * @return bool
         */
        public function hasInterface($interface) {}

        public function getProperties() {}

        public function addProperty($name, $visibility = 'public') {}

        /**
         * @return MethodNode[]
         */
        public function getMethods() {}

        public function addMethod(\Prophecy\Doubler\Generator\Node\MethodNode $method, $force = false) {}

        public function removeMethod($name) {}

        /**
         * @param string $name
         *
         * @return MethodNode|null
         */
        public function getMethod($name) {}

        /**
         * @param string $name
         *
         * @return bool
         */
        public function hasMethod($name) {}

        /**
         * @return string[]
         */
        public function getUnextendableMethods() {}

        /**
         * @param string $unextendableMethod
         */
        public function addUnextendableMethod($unextendableMethod) {}

        /**
         * @param string $method
         * @return bool
         */
        public function isExtendable($method) {}

    }
}

namespace Prophecy\Doubler\Generator\Node
{
    use Prophecy\Doubler\Generator\TypeHintReference;
    use Prophecy\Exception\InvalidArgumentException;

    /**
     * Method node.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class MethodNode
    {
        private $name;

        private $code;

        private $visibility = 'public';

        private $static = false;

        private $returnsReference = false;

        /** @var ReturnTypeNode */
        private $returnTypeNode;

        /**
         * @var ArgumentNode[]
         */
        private $arguments = [/** value is missing */];

        /**
         * @param string $name
         * @param string $code
         */
        public function __construct($name, $code = null, ?\Prophecy\Doubler\Generator\TypeHintReference $typeHintReference = null) {}

        public function getVisibility() {}

        /**
         * @param string $visibility
         */
        public function setVisibility($visibility) {}

        public function isStatic() {}

        public function setStatic($static = true) {}

        public function returnsReference() {}

        public function setReturnsReference() {}

        public function getName() {}

        public function addArgument(\Prophecy\Doubler\Generator\Node\ArgumentNode $argument) {}

        /**
         * @return ArgumentNode[]
         */
        public function getArguments() {}

        /**
         * @deprecated use getReturnTypeNode instead
         * @return bool
         */
        public function hasReturnType() {}

        public function setReturnTypeNode(\Prophecy\Doubler\Generator\Node\ReturnTypeNode $returnTypeNode): \void {}

        /**
         * @deprecated use setReturnTypeNode instead
         * @param string $type
         */
        public function setReturnType($type = null) {}

        /**
         * @deprecated use setReturnTypeNode instead
         * @param bool $bool
         */
        public function setNullableReturnType($bool = true) {}

        /**
         * @deprecated use getReturnTypeNode instead
         * @return string|null
         */
        public function getReturnType() {}

        public function getReturnTypeNode(): \Prophecy\Doubler\Generator\Node\ReturnTypeNode {}

        /**
         * @deprecated use getReturnTypeNode instead
         * @return bool
         */
        public function hasNullableReturnType() {}

        /**
         * @param string $code
         */
        public function setCode($code) {}

        public function getCode() {}

        public function useParentCode() {}

        private function generateArgument(\Prophecy\Doubler\Generator\Node\ArgumentNode $arg) {}

    }
}

namespace Prophecy\Doubler\Generator\Node
{
    use Prophecy\Exception\Doubler\DoubleException;

    final class ReturnTypeNode extends \Prophecy\Doubler\Generator\Node\TypeNodeAbstract
    {
        protected function getRealType(string $type): string {}

        protected function guardIsValidType() {}

        public function isVoid(): bool {}

    }
}

namespace Prophecy\Doubler\Generator\Node
{
    use Prophecy\Exception\Doubler\DoubleException;

    abstract class TypeNodeAbstract
    {
        /** @var string[] */
        protected $types = [/** value is missing */];

        public function __construct(string ...$types) {}

        public function canUseNullShorthand(): bool {}

        public function getTypes(): array {}

        public function getNonNullTypes(): array {}

        protected function prefixWithNsSeparator(string $type): string {}

        protected function getRealType(string $type): string {}

        protected function guardIsValidType() {}

    }
}

namespace Prophecy\Doubler\Generator
{
    use Prophecy\Doubler\Generator\Node\ReturnTypeNode;
    use Prophecy\Doubler\Generator\Node\TypeNodeAbstract;

    /**
     * Class code creator.
     * Generates PHP code for specific class node tree.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ClassCodeGenerator
    {
        public function __construct(?\Prophecy\Doubler\Generator\TypeHintReference $typeHintReference = null) {}

        /**
         * Generates PHP code for class node.
         *
         * @param string         $classname
         * @param Node\ClassNode $class
         *
         * @return string
         */
        public function generate($classname, \Prophecy\Doubler\Generator\Node\ClassNode $class) {}

        private function generateMethod(\Prophecy\Doubler\Generator\Node\MethodNode $method) {}

        private function generateTypes(\Prophecy\Doubler\Generator\Node\TypeNodeAbstract $typeNode): string {}

        private function generateArguments(array $arguments) {}

    }
}

namespace Prophecy\Doubler\Generator
{
    use Prophecy\Exception\Doubler\ClassCreatorException;

    /**
     * Class creator.
     * Creates specific class in current environment.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ClassCreator
    {
        private $generator;

        /**
         * Initializes creator.
         *
         * @param ClassCodeGenerator $generator
         */
        public function __construct(?\Prophecy\Doubler\Generator\ClassCodeGenerator $generator = null) {}

        /**
         * Creates class.
         *
         * @param string         $classname
         * @param Node\ClassNode $class
         *
         * @return mixed
         *
         * @throws \Prophecy\Exception\Doubler\ClassCreatorException
         */
        public function create($classname, \Prophecy\Doubler\Generator\Node\ClassNode $class) {}

    }
}

namespace Prophecy\Doubler\Generator
{
    use Prophecy\Doubler\Generator\Node\ArgumentTypeNode;
    use Prophecy\Doubler\Generator\Node\ReturnTypeNode;
    use Prophecy\Exception\InvalidArgumentException;
    use Prophecy\Exception\Doubler\ClassMirrorException;
    use ReflectionClass;
    use ReflectionMethod;
    use ReflectionNamedType;
    use ReflectionParameter;
    use ReflectionType;
    use ReflectionUnionType;

    /**
     * Class mirror.
     * Core doubler class. Mirrors specific class and/or interfaces into class node tree.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ClassMirror
    {
        private static $reflectableMethods = [/** value is missing */];

        /**
         * Reflects provided arguments into class node.
         *
         * @param ReflectionClass|null $class
         * @param ReflectionClass[] $interfaces
         *
         * @return Node\ClassNode
         *
         */
        public function reflect(?\ReflectionClass $class, array $interfaces) {}

        private function reflectClassToNode(\ReflectionClass $class, \Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        private function reflectInterfaceToNode(\ReflectionClass $interface, \Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        private function reflectMethodToNode(\ReflectionMethod $method, \Prophecy\Doubler\Generator\Node\ClassNode $classNode) {}

        private function reflectArgumentToNode(\ReflectionParameter $parameter, \Prophecy\Doubler\Generator\Node\MethodNode $methodNode) {}

        private function hasDefaultValue(\ReflectionParameter $parameter) {}

        private function getDefaultValue(\ReflectionParameter $parameter) {}

        private function getTypeHints(?\ReflectionType $type, ?\ReflectionClass $class, bool $allowsNull): array {}

    }
}

namespace Prophecy\Doubler\Generator
{

    /**
     * Reflection interface.
     * All reflected classes implement this interface.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface ReflectionInterface
    {
    }
}

namespace Prophecy\Doubler\Generator
{

    /**
     * Tells whether a keyword refers to a class or to a built-in type for the
     * current version of php
     *
     * @deprecated in favour of Node\TypeNodeAbstract
     */
    final class TypeHintReference
    {
        public function isBuiltInParamTypeHint($type) {}

        public function isBuiltInReturnTypeHint($type) {}

    }
}

namespace Prophecy\Doubler
{
    use ReflectionClass;

    /**
     * Cached class doubler.
     * Prevents mirroring/creation of the same structure twice.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CachedDoubler extends \Prophecy\Doubler\Doubler
    {
        private static $classes = [/** value is missing */];

        /**
         * {@inheritdoc}
         */
        protected function createDoubleClass(?\ReflectionClass $class = null, array $interfaces) {}

        /**
         * @param ReflectionClass   $class
         * @param ReflectionClass[] $interfaces
         *
         * @return string
         */
        private function generateClassId(?\ReflectionClass $class = null, array $interfaces) {}

        public function resetCache() {}

    }
}

namespace Prophecy\Doubler
{

    /**
     * Core double interface.
     * All doubled classes will implement this one.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface DoubleInterface
    {
    }
}

namespace Prophecy\Doubler
{
    use Doctrine\Instantiator\Instantiator;
    use Prophecy\Doubler\ClassPatch\ClassPatchInterface;
    use Prophecy\Doubler\Generator\ClassMirror;
    use Prophecy\Doubler\Generator\ClassCreator;
    use Prophecy\Exception\InvalidArgumentException;
    use ReflectionClass;

    /**
     * Cached class doubler.
     * Prevents mirroring/creation of the same structure twice.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class Doubler
    {
        private $mirror;

        private $creator;

        private $namer;

        /**
         * @var ClassPatchInterface[]
         */
        private $patches = [/** value is missing */];

        /**
         * @var \Doctrine\Instantiator\Instantiator
         */
        private $instantiator;

        /**
         * Initializes doubler.
         *
         * @param ClassMirror   $mirror
         * @param ClassCreator  $creator
         * @param NameGenerator $namer
         */
        public function __construct(?\Prophecy\Doubler\Generator\ClassMirror $mirror = null, ?\Prophecy\Doubler\Generator\ClassCreator $creator = null, ?\Prophecy\Doubler\NameGenerator $namer = null) {}

        /**
         * Returns list of registered class patches.
         *
         * @return ClassPatchInterface[]
         */
        public function getClassPatches() {}

        /**
         * Registers new class patch.
         *
         * @param ClassPatchInterface $patch
         */
        public function registerClassPatch(\Prophecy\Doubler\ClassPatch\ClassPatchInterface $patch) {}

        /**
         * Creates double from specific class or/and list of interfaces.
         *
         * @param ReflectionClass   $class
         * @param ReflectionClass[] $interfaces Array of ReflectionClass instances
         * @param array             $args       Constructor arguments
         *
         * @return DoubleInterface
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function double(?\ReflectionClass $class = null, array $interfaces, ?array $args = null) {}

        /**
         * Creates double class and returns its FQN.
         *
         * @param ReflectionClass   $class
         * @param ReflectionClass[] $interfaces
         *
         * @return string
         */
        protected function createDoubleClass(?\ReflectionClass $class = null, array $interfaces) {}

    }
}

namespace Prophecy\Doubler
{
    use Prophecy\Exception\Doubler\DoubleException;
    use Prophecy\Exception\Doubler\ClassNotFoundException;
    use Prophecy\Exception\Doubler\InterfaceNotFoundException;
    use ReflectionClass;

    /**
     * Lazy double.
     * Gives simple interface to describe double before creating it.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class LazyDouble
    {
        private $doubler;

        private $class;

        private $interfaces = [/** value is missing */];

        private $arguments;

        private $double;

        /**
         * Initializes lazy double.
         *
         * @param Doubler $doubler
         */
        public function __construct(\Prophecy\Doubler\Doubler $doubler) {}

        /**
         * Tells doubler to use specific class as parent one for double.
         *
         * @param string|ReflectionClass $class
         *
         * @throws \Prophecy\Exception\Doubler\ClassNotFoundException
         * @throws \Prophecy\Exception\Doubler\DoubleException
         */
        public function setParentClass($class) {}

        /**
         * Tells doubler to implement specific interface with double.
         *
         * @param string|ReflectionClass $interface
         *
         * @throws \Prophecy\Exception\Doubler\InterfaceNotFoundException
         * @throws \Prophecy\Exception\Doubler\DoubleException
         */
        public function addInterface($interface) {}

        /**
         * Sets constructor arguments.
         *
         * @param array $arguments
         */
        public function setArguments(?array $arguments = null) {}

        /**
         * Creates double instance or returns already created one.
         *
         * @return DoubleInterface
         */
        public function getInstance() {}

    }
}

namespace Prophecy\Doubler
{
    use ReflectionClass;

    /**
     * Name generator.
     * Generates classname for double.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class NameGenerator
    {
        private static $counter = 1;

        /**
         * Generates name.
         *
         * @param ReflectionClass   $class
         * @param ReflectionClass[] $interfaces
         *
         * @return string
         */
        public function name(?\ReflectionClass $class = null, array $interfaces) {}

    }
}

namespace Prophecy\Exception\Call
{
    use Prophecy\Exception\Prophecy\ObjectProphecyException;
    use Prophecy\Prophecy\ObjectProphecy;

    class UnexpectedCallException extends \Prophecy\Exception\Prophecy\ObjectProphecyException
    {
        private $methodName;

        private $arguments;

        public function __construct($message, \Prophecy\Prophecy\ObjectProphecy $objectProphecy, $methodName, array $arguments) {}

        public function getMethodName() {}

        public function getArguments() {}

    }
}

namespace Prophecy\Exception\Doubler
{
    use Prophecy\Doubler\Generator\Node\ClassNode;

    class ClassCreatorException extends \RuntimeException
    {
        private $node;

        public function __construct($message, \Prophecy\Doubler\Generator\Node\ClassNode $node) {}

        public function getClassNode() {}

    }
}

namespace Prophecy\Exception\Doubler
{
    use ReflectionClass;

    class ClassMirrorException extends \RuntimeException
    {
        private $class;

        public function __construct($message, \ReflectionClass $class) {}

        public function getReflectedClass() {}

    }
}

namespace Prophecy\Exception\Doubler
{

    class ClassNotFoundException extends \Prophecy\Exception\Doubler\DoubleException
    {
        private $classname;

        /**
         * @param string $message
         * @param string $classname
         */
        public function __construct($message, $classname) {}

        public function getClassname() {}

    }
}

namespace Prophecy\Exception\Doubler
{
    use RuntimeException;

    class DoubleException extends \RuntimeException
    {
    }
}

namespace Prophecy\Exception\Doubler
{
    use Prophecy\Exception\Exception;

    interface DoublerException extends \Prophecy\Exception\Exception
    {
    }
}

namespace Prophecy\Exception\Doubler
{

    class InterfaceNotFoundException extends \Prophecy\Exception\Doubler\ClassNotFoundException
    {
        public function getInterfaceName() {}

    }
}

namespace Prophecy\Exception\Doubler
{

    class MethodNotExtendableException extends \Prophecy\Exception\Doubler\DoubleException
    {
        private $methodName;

        private $className;

        /**
         * @param string $message
         * @param string $className
         * @param string $methodName
         */
        public function __construct($message, $className, $methodName) {}

        /**
         * @return string
         */
        public function getMethodName() {}

        /**
         * @return string
         */
        public function getClassName() {}

    }
}

namespace Prophecy\Exception\Doubler
{

    class MethodNotFoundException extends \Prophecy\Exception\Doubler\DoubleException
    {
        /**
         * @var string|object
         */
        private $classname;

        /**
         * @var string
         */
        private $methodName;

        /**
         * @var array
         */
        private $arguments;

        /**
         * @param string $message
         * @param string|object $classname
         * @param string $methodName
         * @param null|Argument\ArgumentsWildcard|array $arguments
         */
        public function __construct($message, $classname, $methodName, $arguments = null) {}

        public function getClassname() {}

        public function getMethodName() {}

        public function getArguments() {}

    }
}

namespace Prophecy\Exception\Doubler
{

    class ReturnByReferenceException extends \Prophecy\Exception\Doubler\DoubleException
    {
        private $classname;

        private $methodName;

        /**
         * @param string $message
         * @param string $classname
         * @param string $methodName
         */
        public function __construct($message, $classname, $methodName) {}

        public function getClassname() {}

        public function getMethodName() {}

    }
}

namespace Prophecy\Exception\Prediction
{
    use Prophecy\Prophecy\ObjectProphecy;

    class AggregateException extends \RuntimeException
    {
        private $exceptions = [/** value is missing */];

        private $objectProphecy;

        public function append(\Prophecy\Exception\Prediction\PredictionException $exception) {}

        /**
         * @return PredictionException[]
         */
        public function getExceptions() {}

        public function setObjectProphecy(\Prophecy\Prophecy\ObjectProphecy $objectProphecy) {}

        /**
         * @return ObjectProphecy
         */
        public function getObjectProphecy() {}

    }
}

namespace Prophecy\Exception\Prediction
{
    use RuntimeException;

    /**
     * Basic failed prediction exception.
     * Use it for custom prediction failures.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class FailedPredictionException extends \RuntimeException
    {
    }
}

namespace Prophecy\Exception\Prediction
{
    use Prophecy\Exception\Prophecy\MethodProphecyException;

    class NoCallsException extends \Prophecy\Exception\Prophecy\MethodProphecyException implements \Prophecy\Exception\Prediction\PredictionException
    {
    }
}

namespace Prophecy\Exception\Prediction
{
    use Prophecy\Exception\Exception;

    interface PredictionException extends \Prophecy\Exception\Exception
    {
    }
}

namespace Prophecy\Exception\Prediction
{
    use Prophecy\Prophecy\MethodProphecy;

    class UnexpectedCallsCountException extends \Prophecy\Exception\Prediction\UnexpectedCallsException
    {
        private $expectedCount;

        public function __construct($message, \Prophecy\Prophecy\MethodProphecy $methodProphecy, $count, array $calls) {}

        public function getExpectedCount() {}

    }
}

namespace Prophecy\Exception\Prediction
{
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Exception\Prophecy\MethodProphecyException;

    class UnexpectedCallsException extends \Prophecy\Exception\Prophecy\MethodProphecyException implements \Prophecy\Exception\Prediction\PredictionException
    {
        private $calls = [/** value is missing */];

        public function __construct($message, \Prophecy\Prophecy\MethodProphecy $methodProphecy, array $calls) {}

        public function getCalls() {}

    }
}

namespace Prophecy\Exception\Prophecy
{
    use Prophecy\Prophecy\MethodProphecy;

    class MethodProphecyException extends \Prophecy\Exception\Prophecy\ObjectProphecyException
    {
        private $methodProphecy;

        public function __construct($message, \Prophecy\Prophecy\MethodProphecy $methodProphecy) {}

        /**
         * @return MethodProphecy
         */
        public function getMethodProphecy() {}

    }
}

namespace Prophecy\Exception\Prophecy
{
    use Prophecy\Prophecy\ObjectProphecy;

    class ObjectProphecyException extends \RuntimeException
    {
        private $objectProphecy;

        public function __construct($message, \Prophecy\Prophecy\ObjectProphecy $objectProphecy) {}

        /**
         * @return ObjectProphecy
         */
        public function getObjectProphecy() {}

    }
}

namespace Prophecy\Exception\Prophecy
{
    use Prophecy\Exception\Exception;

    interface ProphecyException extends \Prophecy\Exception\Exception
    {
    }
}

namespace Prophecy\Exception
{

    /**
     * Core Prophecy exception interface.
     * All Prophecy exceptions implement it.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface Exception
    {
        /**
         * @return string
         */
        public function getMessage();

    }
}

namespace Prophecy\Exception
{

    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace Prophecy\PhpDocumentor
{
    use phpDocumentor\Reflection\DocBlock\Tag\MethodTag as LegacyMethodTag;
    use phpDocumentor\Reflection\DocBlock\Tags\Method;

    /**
     * @author Théo FIDRY <theo.fidry@gmail.com>
     *
     * @internal
     */
    final class ClassAndInterfaceTagRetriever implements \Prophecy\PhpDocumentor\MethodTagRetrieverInterface
    {
        private $classRetriever;

        public function __construct(?\Prophecy\PhpDocumentor\MethodTagRetrieverInterface $classRetriever = null) {}

        /**
         * @param \ReflectionClass $reflectionClass
         *
         * @return LegacyMethodTag[]|Method[]
         */
        public function getTagList(\ReflectionClass $reflectionClass) {}

        /**
         * @param \ReflectionClass $reflectionClass
         *
         * @return LegacyMethodTag[]|Method[]
         */
        private function getInterfacesTagList(\ReflectionClass $reflectionClass) {}

    }
}

namespace Prophecy\PhpDocumentor
{
    use phpDocumentor\Reflection\DocBlock\Tags\Method;
    use phpDocumentor\Reflection\DocBlockFactory;
    use phpDocumentor\Reflection\Types\ContextFactory;

    /**
     * @author Théo FIDRY <theo.fidry@gmail.com>
     *
     * @internal
     */
    final class ClassTagRetriever implements \Prophecy\PhpDocumentor\MethodTagRetrieverInterface
    {
        private $docBlockFactory;

        private $contextFactory;

        public function __construct() {}

        /**
         * @param \ReflectionClass $reflectionClass
         *
         * @return Method[]
         */
        public function getTagList(\ReflectionClass $reflectionClass) {}

    }
}

namespace Prophecy\PhpDocumentor
{
    use phpDocumentor\Reflection\DocBlock;
    use phpDocumentor\Reflection\DocBlock\Tag\MethodTag as LegacyMethodTag;

    /**
     * @author Théo FIDRY <theo.fidry@gmail.com>
     *
     * @internal
     */
    final class LegacyClassTagRetriever implements \Prophecy\PhpDocumentor\MethodTagRetrieverInterface
    {
        /**
         * @param \ReflectionClass $reflectionClass
         *
         * @return LegacyMethodTag[]
         */
        public function getTagList(\ReflectionClass $reflectionClass) {}

    }
}

namespace Prophecy\PhpDocumentor
{
    use phpDocumentor\Reflection\DocBlock\Tag\MethodTag as LegacyMethodTag;
    use phpDocumentor\Reflection\DocBlock\Tags\Method;

    /**
     * @author Théo FIDRY <theo.fidry@gmail.com>
     *
     * @internal
     */
    interface MethodTagRetrieverInterface
    {
        /**
         * @param \ReflectionClass $reflectionClass
         *
         * @return LegacyMethodTag[]|Method[]
         */
        public function getTagList(\ReflectionClass $reflectionClass);

    }
}

namespace Prophecy\Prediction
{
    use Prophecy\Call\Call;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Argument\ArgumentsWildcard;
    use Prophecy\Argument\Token\AnyValuesToken;
    use Prophecy\Util\StringUtil;
    use Prophecy\Exception\Prediction\NoCallsException;

    /**
     * Call prediction.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallPrediction implements \Prophecy\Prediction\PredictionInterface
    {
        private $util;

        /**
         * Initializes prediction.
         *
         * @param StringUtil $util
         */
        public function __construct(?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Tests that there was at least one call.
         *
         * @param Call[]         $calls
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @throws \Prophecy\Exception\Prediction\NoCallsException
         */
        public function check(array $calls, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Prediction
{
    use Prophecy\Call\Call;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Argument\ArgumentsWildcard;
    use Prophecy\Argument\Token\AnyValuesToken;
    use Prophecy\Util\StringUtil;
    use Prophecy\Exception\Prediction\UnexpectedCallsCountException;

    /**
     * Prediction interface.
     * Predictions are logical test blocks, tied to `should...` keyword.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallTimesPrediction implements \Prophecy\Prediction\PredictionInterface
    {
        private $times;

        private $util;

        /**
         * Initializes prediction.
         *
         * @param int        $times
         * @param StringUtil $util
         */
        public function __construct($times, ?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Tests that there was exact amount of calls made.
         *
         * @param Call[]         $calls
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @throws \Prophecy\Exception\Prediction\UnexpectedCallsCountException
         */
        public function check(array $calls, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Prediction
{
    use Prophecy\Call\Call;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Exception\InvalidArgumentException;
    use Closure;

    /**
     * Callback prediction.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallbackPrediction implements \Prophecy\Prediction\PredictionInterface
    {
        private $callback;

        /**
         * Initializes callback prediction.
         *
         * @param callable $callback Custom callback
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function __construct($callback) {}

        /**
         * Executes preset callback.
         *
         * @param Call[]         $calls
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         */
        public function check(array $calls, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Prediction
{
    use Prophecy\Call\Call;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Util\StringUtil;
    use Prophecy\Exception\Prediction\UnexpectedCallsException;

    /**
     * No calls prediction.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class NoCallsPrediction implements \Prophecy\Prediction\PredictionInterface
    {
        private $util;

        /**
         * Initializes prediction.
         *
         * @param null|StringUtil $util
         */
        public function __construct(?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Tests that there were no calls made.
         *
         * @param Call[]         $calls
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @throws \Prophecy\Exception\Prediction\UnexpectedCallsException
         */
        public function check(array $calls, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Prediction
{
    use Prophecy\Call\Call;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;

    /**
     * Prediction interface.
     * Predictions are logical test blocks, tied to `should...` keyword.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface PredictionInterface
    {
        /**
         * Tests that double fulfilled prediction.
         *
         * @param Call[]        $calls
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @throws object
         * @return void
         */
        public function check(array $calls, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method);

    }
}

namespace Prophecy\Promise
{
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Exception\InvalidArgumentException;
    use Closure;

    /**
     * Callback promise.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class CallbackPromise implements \Prophecy\Promise\PromiseInterface
    {
        private $callback;

        /**
         * Initializes callback promise.
         *
         * @param callable $callback Custom callback
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function __construct($callback) {}

        /**
         * Evaluates promise callback.
         *
         * @param array          $args
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @return mixed
         */
        public function execute(array $args, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Promise
{
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;

    /**
     * Promise interface.
     * Promises are logical blocks, tied to `will...` keyword.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface PromiseInterface
    {
        /**
         * Evaluates promise.
         *
         * @param array          $args
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @return mixed
         */
        public function execute(array $args, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method);

    }
}

namespace Prophecy\Promise
{
    use Prophecy\Exception\InvalidArgumentException;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;

    /**
     * Return argument promise.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ReturnArgumentPromise implements \Prophecy\Promise\PromiseInterface
    {
        /**
         * @var int
         */
        private $index;

        /**
         * Initializes callback promise.
         *
         * @param int $index The zero-indexed number of the argument to return
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function __construct($index = 0) {}

        /**
         * Returns nth argument if has one, null otherwise.
         *
         * @param array          $args
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @return null|mixed
         */
        public function execute(array $args, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Promise
{
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;

    /**
     * Return promise.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ReturnPromise implements \Prophecy\Promise\PromiseInterface
    {
        private $returnValues = [/** value is missing */];

        /**
         * Initializes promise.
         *
         * @param array $returnValues Array of values
         */
        public function __construct(array $returnValues) {}

        /**
         * Returns saved values one by one until last one, then continuously returns last value.
         *
         * @param array          $args
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @return mixed
         */
        public function execute(array $args, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

    }
}

namespace Prophecy\Promise
{
    use Doctrine\Instantiator\Instantiator;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Exception\InvalidArgumentException;
    use ReflectionClass;

    /**
     * Throw promise.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ThrowPromise implements \Prophecy\Promise\PromiseInterface
    {
        private $exception;

        /**
         * @var \Doctrine\Instantiator\Instantiator
         */
        private $instantiator;

        /**
         * Initializes promise.
         *
         * @param string|\Exception|\Throwable $exception Exception class name or instance
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function __construct($exception) {}

        /**
         * Throws predefined exception.
         *
         * @param array          $args
         * @param ObjectProphecy $object
         * @param MethodProphecy $method
         *
         * @throws object
         */
        public function execute(array $args, \Prophecy\Prophecy\ObjectProphecy $object, \Prophecy\Prophecy\MethodProphecy $method) {}

        /**
         * @param string $exception
         *
         * @return bool
         */
        private function isAValidThrowable($exception) {}

    }
}

namespace Prophecy\Prophecy
{
    use Prophecy\Argument;
    use Prophecy\Prophet;
    use Prophecy\Promise;
    use Prophecy\Prediction;
    use Prophecy\Exception\Doubler\MethodNotFoundException;
    use Prophecy\Exception\InvalidArgumentException;
    use Prophecy\Exception\Prophecy\MethodProphecyException;
    use ReflectionNamedType;
    use ReflectionType;
    use ReflectionUnionType;

    /**
     * Method prophecy.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class MethodProphecy
    {
        private $objectProphecy;

        private $methodName;

        private $argumentsWildcard;

        private $promise;

        private $prediction;

        private $checkedPredictions = [/** value is missing */];

        private $bound = false;

        private $voidReturnType = false;

        /**
         * Initializes method prophecy.
         *
         * @param ObjectProphecy                        $objectProphecy
         * @param string                                $methodName
         * @param null|Argument\ArgumentsWildcard|array $arguments
         *
         * @throws \Prophecy\Exception\Doubler\MethodNotFoundException If method not found
         */
        public function __construct(\Prophecy\Prophecy\ObjectProphecy $objectProphecy, $methodName, $arguments = null) {}

        /**
         * Sets argument wildcard.
         *
         * @param array|Argument\ArgumentsWildcard $arguments
         *
         * @return $this
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function withArguments($arguments) {}

        /**
         * Sets custom promise to the prophecy.
         *
         * @param callable|Promise\PromiseInterface $promise
         *
         * @return $this
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function will($promise) {}

        /**
         * Sets return promise to the prophecy.
         *
         * @see \Prophecy\Promise\ReturnPromise
         *
         * @return $this
         */
        public function willReturn() {}

        /**
         * @param array $items
         *
         * @return $this
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function willYield($items) {}

        /**
         * Sets return argument promise to the prophecy.
         *
         * @param int $index The zero-indexed number of the argument to return
         *
         * @see \Prophecy\Promise\ReturnArgumentPromise
         *
         * @return $this
         */
        public function willReturnArgument($index = 0) {}

        /**
         * Sets throw promise to the prophecy.
         *
         * @see \Prophecy\Promise\ThrowPromise
         *
         * @param string|\Exception $exception Exception class or instance
         *
         * @return $this
         */
        public function willThrow($exception) {}

        /**
         * Sets custom prediction to the prophecy.
         *
         * @param callable|Prediction\PredictionInterface $prediction
         *
         * @return $this
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function should($prediction) {}

        /**
         * Sets call prediction to the prophecy.
         *
         * @see \Prophecy\Prediction\CallPrediction
         *
         * @return $this
         */
        public function shouldBeCalled() {}

        /**
         * Sets no calls prediction to the prophecy.
         *
         * @see \Prophecy\Prediction\NoCallsPrediction
         *
         * @return $this
         */
        public function shouldNotBeCalled() {}

        /**
         * Sets call times prediction to the prophecy.
         *
         * @see \Prophecy\Prediction\CallTimesPrediction
         *
         * @param $count
         *
         * @return $this
         */
        public function shouldBeCalledTimes($count) {}

        /**
         * Sets call times prediction to the prophecy.
         *
         * @see \Prophecy\Prediction\CallTimesPrediction
         *
         * @return $this
         */
        public function shouldBeCalledOnce() {}

        /**
         * Checks provided prediction immediately.
         *
         * @param callable|Prediction\PredictionInterface $prediction
         *
         * @return $this
         *
         * @throws \Prophecy\Exception\InvalidArgumentException
         */
        public function shouldHave($prediction) {}

        /**
         * Checks call prediction.
         *
         * @see \Prophecy\Prediction\CallPrediction
         *
         * @return $this
         */
        public function shouldHaveBeenCalled() {}

        /**
         * Checks no calls prediction.
         *
         * @see \Prophecy\Prediction\NoCallsPrediction
         *
         * @return $this
         */
        public function shouldNotHaveBeenCalled() {}

        /**
         * Checks no calls prediction.
         *
         * @see \Prophecy\Prediction\NoCallsPrediction
         * @deprecated
         *
         * @return $this
         */
        public function shouldNotBeenCalled() {}

        /**
         * Checks call times prediction.
         *
         * @see \Prophecy\Prediction\CallTimesPrediction
         *
         * @param int $count
         *
         * @return $this
         */
        public function shouldHaveBeenCalledTimes($count) {}

        /**
         * Checks call times prediction.
         *
         * @see \Prophecy\Prediction\CallTimesPrediction
         *
         * @return $this
         */
        public function shouldHaveBeenCalledOnce() {}

        /**
         * Checks currently registered [with should(...)] prediction.
         */
        public function checkPrediction() {}

        /**
         * Returns currently registered promise.
         *
         * @return null|Promise\PromiseInterface
         */
        public function getPromise() {}

        /**
         * Returns currently registered prediction.
         *
         * @return null|Prediction\PredictionInterface
         */
        public function getPrediction() {}

        /**
         * Returns predictions that were checked on this object.
         *
         * @return Prediction\PredictionInterface[]
         */
        public function getCheckedPredictions() {}

        /**
         * Returns object prophecy this method prophecy is tied to.
         *
         * @return ObjectProphecy
         */
        public function getObjectProphecy() {}

        /**
         * Returns method name.
         *
         * @return string
         */
        public function getMethodName() {}

        /**
         * Returns arguments wildcard.
         *
         * @return Argument\ArgumentsWildcard
         */
        public function getArgumentsWildcard() {}

        /**
         * @return bool
         */
        public function hasReturnVoid() {}

        private function bindToObjectProphecy() {}

    }
}

namespace Prophecy\Prophecy
{
    use SebastianBergmann\Comparator\ComparisonFailure;
    use Prophecy\Comparator\Factory as ComparatorFactory;
    use Prophecy\Call\Call;
    use Prophecy\Doubler\LazyDouble;
    use Prophecy\Argument\ArgumentsWildcard;
    use Prophecy\Call\CallCenter;
    use Prophecy\Exception\Prophecy\ObjectProphecyException;
    use Prophecy\Exception\Prophecy\MethodProphecyException;
    use Prophecy\Exception\Prediction\AggregateException;
    use Prophecy\Exception\Prediction\PredictionException;

    /**
     * Object prophecy.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class ObjectProphecy implements \Prophecy\Prophecy\ProphecyInterface
    {
        private $lazyDouble;

        private $callCenter;

        private $revealer;

        private $comparatorFactory;

        /**
         * @var MethodProphecy[][]
         */
        private $methodProphecies = [/** value is missing */];

        /**
         * Initializes object prophecy.
         *
         * @param LazyDouble        $lazyDouble
         * @param CallCenter        $callCenter
         * @param RevealerInterface $revealer
         * @param ComparatorFactory $comparatorFactory
         */
        public function __construct(\Prophecy\Doubler\LazyDouble $lazyDouble, ?\Prophecy\Call\CallCenter $callCenter = null, ?\Prophecy\Prophecy\RevealerInterface $revealer = null, ?\Prophecy\Comparator\Factory $comparatorFactory = null) {}

        /**
         * Forces double to extend specific class.
         *
         * @param string $class
         *
         * @return $this
         */
        public function willExtend($class) {}

        /**
         * Forces double to implement specific interface.
         *
         * @param string $interface
         *
         * @return $this
         */
        public function willImplement($interface) {}

        /**
         * Sets constructor arguments.
         *
         * @param array $arguments
         *
         * @return $this
         */
        public function willBeConstructedWith(?array $arguments = null) {}

        /**
         * Reveals double.
         *
         * @return object
         *
         * @throws \Prophecy\Exception\Prophecy\ObjectProphecyException If double doesn't implement needed interface
         */
        public function reveal() {}

        /**
         * Adds method prophecy to object prophecy.
         *
         * @param MethodProphecy $methodProphecy
         *
         * @throws \Prophecy\Exception\Prophecy\MethodProphecyException If method prophecy doesn't
         *                                                              have arguments wildcard
         */
        public function addMethodProphecy(\Prophecy\Prophecy\MethodProphecy $methodProphecy) {}

        /**
         * Returns either all or related to single method prophecies.
         *
         * @param null|string $methodName
         *
         * @return MethodProphecy[]
         */
        public function getMethodProphecies($methodName = null) {}

        /**
         * Makes specific method call.
         *
         * @param string $methodName
         * @param array  $arguments
         *
         * @return mixed
         */
        public function makeProphecyMethodCall($methodName, array $arguments) {}

        /**
         * Finds calls by method name & arguments wildcard.
         *
         * @param string            $methodName
         * @param ArgumentsWildcard $wildcard
         *
         * @return Call[]
         */
        public function findProphecyMethodCalls($methodName, \Prophecy\Argument\ArgumentsWildcard $wildcard) {}

        /**
         * Checks that registered method predictions do not fail.
         *
         * @throws \Prophecy\Exception\Prediction\AggregateException If any of registered predictions fail
         * @throws \Prophecy\Exception\Call\UnexpectedCallException
         */
        public function checkProphecyMethodsPredictions() {}

        /**
         * Creates new method prophecy using specified method name and arguments.
         *
         * @param string $methodName
         * @param array  $arguments
         *
         * @return MethodProphecy
         */
        public function __call($methodName, array $arguments) {}

        /**
         * Tries to get property value from double.
         *
         * @param string $name
         *
         * @return mixed
         */
        public function __get($name) {}

        /**
         * Tries to set property value to double.
         *
         * @param string $name
         * @param mixed  $value
         */
        public function __set($name, $value) {}

    }
}

namespace Prophecy\Prophecy
{

    /**
     * Core Prophecy interface.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface ProphecyInterface
    {
        /**
         * Reveals prophecy object (double) .
         *
         * @return object
         */
        public function reveal();

    }
}

namespace Prophecy\Prophecy
{

    /**
     * Controllable doubles interface.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface ProphecySubjectInterface
    {
        /**
         * Sets subject prophecy.
         *
         * @param ProphecyInterface $prophecy
         */
        public function setProphecy(\Prophecy\Prophecy\ProphecyInterface $prophecy);

        /**
         * Returns subject prophecy.
         *
         * @return ProphecyInterface
         */
        public function getProphecy();

    }
}

namespace Prophecy\Prophecy
{

    /**
     * Basic prophecies revealer.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class Revealer implements \Prophecy\Prophecy\RevealerInterface
    {
        /**
         * Unwraps value(s).
         *
         * @param mixed $value
         *
         * @return mixed
         */
        public function reveal($value) {}

    }
}

namespace Prophecy\Prophecy
{

    /**
     * Prophecies revealer interface.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    interface RevealerInterface
    {
        /**
         * Unwraps value(s).
         *
         * @param mixed $value
         *
         * @return mixed
         */
        public function reveal($value);

    }
}

namespace Prophecy\Util
{
    use Prophecy\Prophecy\ProphecyInterface;
    use SebastianBergmann\RecursionContext\Context;

    /**
     * This class is a modification from sebastianbergmann/exporter
     * @see https://github.com/sebastianbergmann/exporter
     */
    class ExportUtil
    {
        /**
         * Exports a value as a string
         *
         * The output of this method is similar to the output of print_r(), but
         * improved in various aspects:
         *
         *  - NULL is rendered as "null" (instead of "")
         *  - TRUE is rendered as "true" (instead of "1")
         *  - FALSE is rendered as "false" (instead of "")
         *  - Strings are always quoted with single quotes
         *  - Carriage returns and newlines are normalized to \n
         *  - Recursion and repeated rendering is treated properly
         *
         * @param  mixed  $value
         * @param  int    $indentation The indentation level of the 2nd+ line
         * @return string
         */
        public static function export($value, $indentation = 0) {}

        /**
         * Converts an object to an array containing all of its private, protected
         * and public properties.
         *
         * @param  mixed $value
         * @return array
         */
        public static function toArray($value) {}

        /**
         * Recursive implementation of export
         *
         * @param  mixed                                       $value       The value to export
         * @param  int                                         $indentation The indentation level of the 2nd+ line
         * @param  \SebastianBergmann\RecursionContext\Context $processed   Previously processed objects
         * @return string
         * @see    SebastianBergmann\Exporter\Exporter::export
         */
        protected static function recursiveExport(&$value, $indentation, $processed = null) {}

    }
}

namespace Prophecy\Util
{
    use Prophecy\Call\Call;

    /**
     * String utility.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class StringUtil
    {
        private $verbose;

        /**
         * @param bool $verbose
         */
        public function __construct($verbose = true) {}

        /**
         * Stringifies any provided value.
         *
         * @param mixed   $value
         * @param boolean $exportObject
         *
         * @return string
         */
        public function stringify($value, $exportObject = true) {}

        /**
         * Stringifies provided array of calls.
         *
         * @param Call[] $calls Array of Call instances
         *
         * @return string
         */
        public function stringifyCalls(array $calls) {}

    }
}

namespace Prophecy
{
    use Prophecy\Argument\Token;

    /**
     * Argument tokens shortcuts.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class Argument
    {
        /**
         * Checks that argument is exact value or object.
         *
         * @param mixed $value
         *
         * @return Token\ExactValueToken
         */
        public static function exact($value) {}

        /**
         * Checks that argument is of specific type or instance of specific class.
         *
         * @param string $type Type name (`integer`, `string`) or full class name
         *
         * @return Token\TypeToken
         */
        public static function type($type) {}

        /**
         * Checks that argument object has specific state.
         *
         * @param string $methodName
         * @param mixed  $value
         *
         * @return Token\ObjectStateToken
         */
        public static function which($methodName, $value) {}

        /**
         * Checks that argument matches provided callback.
         *
         * @param callable $callback
         *
         * @return Token\CallbackToken
         */
        public static function that($callback) {}

        /**
         * Matches any single value.
         *
         * @return Token\AnyValueToken
         */
        public static function any() {}

        /**
         * Matches all values to the rest of the signature.
         *
         * @return Token\AnyValuesToken
         */
        public static function cetera() {}

        /**
         * Checks that argument matches all tokens
         *
         * @param mixed ... a list of tokens
         *
         * @return Token\LogicalAndToken
         */
        public static function allOf() {}

        /**
         * Checks that argument array or countable object has exact number of elements.
         *
         * @param integer $value array elements count
         *
         * @return Token\ArrayCountToken
         */
        public static function size($value) {}

        /**
         * Checks that argument array contains (key, value) pair
         *
         * @param mixed $key   exact value or token
         * @param mixed $value exact value or token
         *
         * @return Token\ArrayEntryToken
         */
        public static function withEntry($key, $value) {}

        /**
         * Checks that arguments array entries all match value
         *
         * @param mixed $value
         *
         * @return Token\ArrayEveryEntryToken
         */
        public static function withEveryEntry($value) {}

        /**
         * Checks that argument array contains value
         *
         * @param mixed $value
         *
         * @return Token\ArrayEntryToken
         */
        public static function containing($value) {}

        /**
         * Checks that argument array has key
         *
         * @param mixed $key exact value or token
         *
         * @return Token\ArrayEntryToken
         */
        public static function withKey($key) {}

        /**
         * Checks that argument does not match the value|token.
         *
         * @param mixed $value either exact value or argument token
         *
         * @return Token\LogicalNotToken
         */
        public static function not($value) {}

        /**
         * @param string $value
         *
         * @return Token\StringContainsToken
         */
        public static function containingString($value) {}

        /**
         * Checks that argument is identical value.
         *
         * @param mixed $value
         *
         * @return Token\IdenticalValueToken
         */
        public static function is($value) {}

        /**
         * Check that argument is same value when rounding to the
         * given precision.
         *
         * @param float $value
         * @param float $precision
         *
         * @return Token\ApproximateValueToken
         */
        public static function approximate($value, $precision = 0) {}

        /**
         * Checks that argument is in array.
         *
         * @param array $value
         *
         * @return Token\InArrayToken
         */
        public function in($value) {}

        /**
         * Checks that argument is in array.
         *
         * @param array $value
         *
         * @return Token\InArrayToken
         */
        public function notIn($value) {}

    }
}

namespace Prophecy
{
    use Prophecy\Doubler\CachedDoubler;
    use Prophecy\Doubler\Doubler;
    use Prophecy\Doubler\LazyDouble;
    use Prophecy\Doubler\ClassPatch;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophecy\RevealerInterface;
    use Prophecy\Prophecy\Revealer;
    use Prophecy\Call\CallCenter;
    use Prophecy\Util\StringUtil;
    use Prophecy\Exception\Prediction\PredictionException;
    use Prophecy\Exception\Prediction\AggregateException;

    /**
     * Prophet creates prophecies.
     *
     * @author Konstantin Kudryashov <ever.zet@gmail.com>
     */
    class Prophet
    {
        private $doubler;

        private $revealer;

        private $util;

        /**
         * @var ObjectProphecy[]
         */
        private $prophecies = [/** value is missing */];

        /**
         * Initializes Prophet.
         *
         * @param null|Doubler           $doubler
         * @param null|RevealerInterface $revealer
         * @param null|StringUtil        $util
         */
        public function __construct(?\Prophecy\Doubler\Doubler $doubler = null, ?\Prophecy\Prophecy\RevealerInterface $revealer = null, ?\Prophecy\Util\StringUtil $util = null) {}

        /**
         * Creates new object prophecy.
         *
         * @param null|string $classOrInterface Class or interface name
         *
         * @return ObjectProphecy
         */
        public function prophesize($classOrInterface = null) {}

        /**
         * Returns all created object prophecies.
         *
         * @return ObjectProphecy[]
         */
        public function getProphecies() {}

        /**
         * Returns Doubler instance assigned to this Prophet.
         *
         * @return Doubler
         */
        public function getDoubler() {}

        /**
         * Checks all predictions defined by prophecies of this Prophet.
         *
         * @throws Exception\Prediction\AggregateException If any prediction fails
         */
        public function checkPredictions() {}

    }
}

namespace Prophecy\PhpUnit
{
    use PHPUnit\Framework\AssertionFailedError;
    use PHPUnit\Framework\TestCase;
    use Prophecy\Exception\Doubler\DoubleException;
    use Prophecy\Exception\Doubler\InterfaceNotFoundException;
    use Prophecy\Exception\Prediction\PredictionException;
    use Prophecy\Prophecy\MethodProphecy;
    use Prophecy\Prophecy\ObjectProphecy;
    use Prophecy\Prophet;

    /**
     * @mixin TestCase
     */
    trait ProphecyTrait
    {
        /**
         * @var Prophet|null
         *
         * @internal
         */
        private $prophet;

        /**
         * @var bool
         *
         * @internal
         */
        private $prophecyAssertionsCounted = false;

        /**
         * @throws DoubleException
         * @throws InterfaceNotFoundException
         *
         * @psalm-param class-string|null $type
         */
        protected function prophesize(?string $classOrInterface = null): \Prophecy\Prophecy\ObjectProphecy {}

        /**
         * @postCondition
         */
        protected function verifyProphecyDoubles(): \void {}

        /**
         * @after
         */
        protected function tearDownProphecy(): \void {}

        /**
         * @internal
         */
        private function countProphecyAssertions(): \void {}

        /**
         * @internal
         */
        private function getProphet(): \Prophecy\Prophet {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use sprintf;
    use SebastianBergmann\CodeCoverage\BranchAndPathCoverageNotSupportedException;
    use SebastianBergmann\CodeCoverage\DeadCodeDetectionNotSupportedException;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\NoCodeCoverageDriverAvailableException;
    use SebastianBergmann\CodeCoverage\NoCodeCoverageDriverWithPathCoverageSupportAvailableException;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    abstract class Driver
    {
        /**
         * @var int
         *
         * @see http://xdebug.org/docs/code_coverage
         */
        const LINE_NOT_EXECUTABLE = null;

        /**
         * @var int
         *
         * @see http://xdebug.org/docs/code_coverage
         */
        const LINE_NOT_EXECUTED = null;

        /**
         * @var int
         *
         * @see http://xdebug.org/docs/code_coverage
         */
        const LINE_EXECUTED = 1;

        /**
         * @var int
         *
         * @see http://xdebug.org/docs/code_coverage
         */
        const BRANCH_NOT_HIT = 0;

        /**
         * @var int
         *
         * @see http://xdebug.org/docs/code_coverage
         */
        const BRANCH_HIT = 1;

        /**
         * @var bool
         */
        private $collectBranchAndPathCoverage = false;

        /**
         * @var bool
         */
        private $detectDeadCode = false;

        /**
         * @throws NoCodeCoverageDriverAvailableException
         * @throws PcovNotAvailableException
         * @throws PhpdbgNotAvailableException
         * @throws XdebugNotAvailableException
         * @throws Xdebug2NotEnabledException
         * @throws Xdebug3NotEnabledException
         *
         * @deprecated Use DriverSelector::forLineCoverage() instead
         */
        public static function forLineCoverage(\SebastianBergmann\CodeCoverage\Filter $filter): self {}

        /**
         * @throws NoCodeCoverageDriverWithPathCoverageSupportAvailableException
         * @throws XdebugNotAvailableException
         * @throws Xdebug2NotEnabledException
         * @throws Xdebug3NotEnabledException
         *
         * @deprecated Use DriverSelector::forLineAndPathCoverage() instead
         */
        public static function forLineAndPathCoverage(\SebastianBergmann\CodeCoverage\Filter $filter): self {}

        public function canCollectBranchAndPathCoverage(): bool {}

        public function collectsBranchAndPathCoverage(): bool {}

        /**
         * @throws BranchAndPathCoverageNotSupportedException
         */
        public function enableBranchAndPathCoverage(): \void {}

        public function disableBranchAndPathCoverage(): \void {}

        public function canDetectDeadCode(): bool {}

        public function detectsDeadCode(): bool {}

        /**
         * @throws DeadCodeDetectionNotSupportedException
         */
        public function enableDeadCodeDetection(): \void {}

        public function disableDeadCodeDetection(): \void {}

        abstract public function nameAndVersion(): string;

        abstract public function start(): \void;

        abstract public function stop(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use extension_loaded;
    use phpversion;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class PcovDriver extends \SebastianBergmann\CodeCoverage\Driver\Driver
    {
        /**
         * @var Filter
         */
        private $filter;

        /**
         * @throws PcovNotAvailableException
         */
        public function __construct(\SebastianBergmann\CodeCoverage\Filter $filter) {}

        public function start(): \void {}

        public function stop(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        public function nameAndVersion(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use PHP_SAPI;
    use PHP_VERSION;
    use array_diff;
    use array_keys;
    use array_merge;
    use get_included_files;
    use phpdbg_end_oplog;
    use phpdbg_get_executable;
    use phpdbg_start_oplog;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class PhpdbgDriver extends \SebastianBergmann\CodeCoverage\Driver\Driver
    {
        /**
         * @throws PhpdbgNotAvailableException
         */
        public function __construct() {}

        public function start(): \void {}

        public function stop(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        public function nameAndVersion(): string {}

        private function detectExecutedLines(array $sourceLines, array $dbgData): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use phpversion;
    use version_compare;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\NoCodeCoverageDriverAvailableException;
    use SebastianBergmann\CodeCoverage\NoCodeCoverageDriverWithPathCoverageSupportAvailableException;
    use SebastianBergmann\Environment\Runtime;

    final class Selector
    {
        /**
         * @throws NoCodeCoverageDriverAvailableException
         * @throws PcovNotAvailableException
         * @throws PhpdbgNotAvailableException
         * @throws XdebugNotAvailableException
         * @throws Xdebug2NotEnabledException
         * @throws Xdebug3NotEnabledException
         */
        public function forLineCoverage(\SebastianBergmann\CodeCoverage\Filter $filter): \SebastianBergmann\CodeCoverage\Driver\Driver {}

        /**
         * @throws NoCodeCoverageDriverWithPathCoverageSupportAvailableException
         * @throws XdebugNotAvailableException
         * @throws Xdebug2NotEnabledException
         * @throws Xdebug3NotEnabledException
         */
        public function forLineAndPathCoverage(\SebastianBergmann\CodeCoverage\Filter $filter): \SebastianBergmann\CodeCoverage\Driver\Driver {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use XDEBUG_CC_BRANCH_CHECK;
    use XDEBUG_CC_DEAD_CODE;
    use XDEBUG_CC_UNUSED;
    use XDEBUG_FILTER_CODE_COVERAGE;
    use XDEBUG_PATH_INCLUDE;
    use XDEBUG_PATH_WHITELIST;
    use defined;
    use extension_loaded;
    use ini_get;
    use phpversion;
    use sprintf;
    use version_compare;
    use xdebug_get_code_coverage;
    use xdebug_set_filter;
    use xdebug_start_code_coverage;
    use xdebug_stop_code_coverage;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Xdebug2Driver extends \SebastianBergmann\CodeCoverage\Driver\Driver
    {
        /**
         * @var bool
         */
        private $pathCoverageIsMixedCoverage;

        /**
         * @throws XdebugNotAvailableException
         * @throws WrongXdebugVersionException
         * @throws Xdebug2NotEnabledException
         */
        public function __construct(\SebastianBergmann\CodeCoverage\Filter $filter) {}

        public function canCollectBranchAndPathCoverage(): bool {}

        public function canDetectDeadCode(): bool {}

        public function start(): \void {}

        public function stop(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        public function nameAndVersion(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use XDEBUG_CC_BRANCH_CHECK;
    use XDEBUG_CC_DEAD_CODE;
    use XDEBUG_CC_UNUSED;
    use XDEBUG_FILTER_CODE_COVERAGE;
    use XDEBUG_PATH_INCLUDE;
    use extension_loaded;
    use in_array;
    use ini_get;
    use phpversion;
    use sprintf;
    use version_compare;
    use xdebug_get_code_coverage;
    use xdebug_set_filter;
    use xdebug_start_code_coverage;
    use xdebug_stop_code_coverage;
    use SebastianBergmann\CodeCoverage\Filter;
    use SebastianBergmann\CodeCoverage\RawCodeCoverageData;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Xdebug3Driver extends \SebastianBergmann\CodeCoverage\Driver\Driver
    {
        /**
         * @throws XdebugNotAvailableException
         * @throws WrongXdebugVersionException
         * @throws Xdebug3NotEnabledException
         */
        public function __construct(\SebastianBergmann\CodeCoverage\Filter $filter) {}

        public function canCollectBranchAndPathCoverage(): bool {}

        public function canDetectDeadCode(): bool {}

        public function start(): \void {}

        public function stop(): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        public function nameAndVersion(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use sprintf;
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class PathExistsButIsNotDirectoryException extends \RuntimeException
    {
        public function __construct(string $path) {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class PcovNotAvailableException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class PhpdbgNotAvailableException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use sprintf;
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class WriteOperationFailedException extends \RuntimeException
    {
        public function __construct(string $path) {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class WrongXdebugVersionException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class Xdebug2NotEnabledException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class Xdebug3NotEnabledException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage\Driver
{
    use RuntimeException;
    use SebastianBergmann\CodeCoverage\Exception;

    final class XdebugNotAvailableException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class BranchAndPathCoverageNotSupportedException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class DeadCodeDetectionNotSupportedException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class DirectoryCouldNotBeCreatedException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{

    /**
     * Exception interface for php-code-coverage component.
     */
    interface Exception
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{

    final class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class NoCodeCoverageDriverAvailableException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class NoCodeCoverageDriverWithPathCoverageSupportAvailableException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class ParserException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class ReflectionException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class ReportAlreadyFinalizedException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class StaticAnalysisCacheNotConfiguredException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class TestIdMissingException extends \RuntimeException
    {
        public function __construct() {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class UnintentionallyCoveredCodeException extends \RuntimeException
    {
        /**
         * @var array
         */
        private $unintentionallyCoveredUnits;

        public function __construct(array $unintentionallyCoveredUnits) {}

        public function getUnintentionallyCoveredUnits(): array {}

        private function toString(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use RuntimeException;

    final class XmlException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeCoverage
{
    use array_diff;
    use array_diff_key;
    use array_flip;
    use array_keys;
    use array_merge;
    use array_unique;
    use array_values;
    use count;
    use explode;
    use get_class;
    use is_array;
    use is_file;
    use sort;
    use PHPUnit\Framework\TestCase;
    use PHPUnit\Runner\PhptTestCase;
    use PHPUnit\Util\Test;
    use ReflectionClass;
    use SebastianBergmann\CodeCoverage\Driver\Driver;
    use SebastianBergmann\CodeCoverage\Node\Builder;
    use SebastianBergmann\CodeCoverage\Node\Directory;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\CachingCoveredFileAnalyser;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\CachingUncoveredFileAnalyser;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingCoveredFileAnalyser;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingUncoveredFileAnalyser;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser;
    use SebastianBergmann\CodeUnitReverseLookup\Wizard;

    /**
     * Provides collection functionality for PHP code coverage information.
     */
    final class CodeCoverage
    {
        const UNCOVERED_FILES = 'UNCOVERED_FILES';

        /**
         * @var Driver
         */
        private $driver;

        /**
         * @var Filter
         */
        private $filter;

        /**
         * @var Wizard
         */
        private $wizard;

        /**
         * @var bool
         */
        private $checkForUnintentionallyCoveredCode = false;

        /**
         * @var bool
         */
        private $includeUncoveredFiles = true;

        /**
         * @var bool
         */
        private $processUncoveredFiles = false;

        /**
         * @var bool
         */
        private $ignoreDeprecatedCode = false;

        /**
         * @var PhptTestCase|string|TestCase
         */
        private $currentId;

        /**
         * Code coverage data.
         *
         * @var ProcessedCodeCoverageData
         */
        private $data;

        /**
         * @var bool
         */
        private $useAnnotationsForIgnoringCode = true;

        /**
         * Test data.
         *
         * @var array
         */
        private $tests = [/** value is missing */];

        /**
         * @psalm-var list<class-string>
         */
        private $parentClassesExcludedFromUnintentionallyCoveredCodeCheck = [/** value is missing */];

        /**
         * @var ?CoveredFileAnalyser
         */
        private $coveredFileAnalyser;

        /**
         * @var ?UncoveredFileAnalyser
         */
        private $uncoveredFileAnalyser;

        /**
         * @var ?string
         */
        private $cacheDirectory;

        public function __construct(\SebastianBergmann\CodeCoverage\Driver\Driver $driver, \SebastianBergmann\CodeCoverage\Filter $filter) {}

        /**
         * Returns the code coverage information as a graph of node objects.
         */
        public function getReport(): \SebastianBergmann\CodeCoverage\Node\Directory {}

        /**
         * Clears collected code coverage data.
         */
        public function clear(): \void {}

        /**
         * Returns the filter object used.
         */
        public function filter(): \SebastianBergmann\CodeCoverage\Filter {}

        /**
         * Returns the collected code coverage data.
         */
        public function getData(bool $raw = false): \SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData {}

        /**
         * Sets the coverage data.
         */
        public function setData(\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $data): \void {}

        /**
         * Returns the test data.
         */
        public function getTests(): array {}

        /**
         * Sets the test data.
         */
        public function setTests(array $tests): \void {}

        /**
         * Start collection of code coverage information.
         *
         * @param PhptTestCase|string|TestCase $id
         */
        public function start($id, bool $clear = false): \void {}

        /**
         * Stop collection of code coverage information.
         *
         * @param array|false $linesToBeCovered
         */
        public function stop(bool $append = true, $linesToBeCovered = [/** value is missing */], array $linesToBeUsed = [/** value is missing */]): \SebastianBergmann\CodeCoverage\RawCodeCoverageData {}

        /**
         * Appends code coverage data.
         *
         * @param PhptTestCase|string|TestCase $id
         * @param array|false                  $linesToBeCovered
         *
         * @throws UnintentionallyCoveredCodeException
         * @throws TestIdMissingException
         * @throws ReflectionException
         */
        public function append(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData, $id = null, bool $append = true, $linesToBeCovered = [/** value is missing */], array $linesToBeUsed = [/** value is missing */]): \void {}

        /**
         * Merges the data from another instance.
         */
        public function merge(self $that): \void {}

        public function enableCheckForUnintentionallyCoveredCode(): \void {}

        public function disableCheckForUnintentionallyCoveredCode(): \void {}

        public function includeUncoveredFiles(): \void {}

        public function excludeUncoveredFiles(): \void {}

        public function processUncoveredFiles(): \void {}

        public function doNotProcessUncoveredFiles(): \void {}

        public function enableAnnotationsForIgnoringCode(): \void {}

        public function disableAnnotationsForIgnoringCode(): \void {}

        public function ignoreDeprecatedCode(): \void {}

        public function doNotIgnoreDeprecatedCode(): \void {}

        /**
         * @psalm-assert-if-true !null $this->cacheDirectory
         */
        public function cachesStaticAnalysis(): bool {}

        public function cacheStaticAnalysis(string $directory): \void {}

        public function doNotCacheStaticAnalysis(): \void {}

        /**
         * @throws StaticAnalysisCacheNotConfiguredException
         */
        public function cacheDirectory(): string {}

        /**
         * @psalm-param class-string $className
         */
        public function excludeSubclassesOfThisClassFromUnintentionallyCoveredCodeCheck(string $className): \void {}

        public function enableBranchAndPathCoverage(): \void {}

        public function disableBranchAndPathCoverage(): \void {}

        public function collectsBranchAndPathCoverage(): bool {}

        public function detectsDeadCode(): bool {}

        /**
         * Applies the @covers annotation filtering.
         *
         * @param array|false $linesToBeCovered
         *
         * @throws UnintentionallyCoveredCodeException
         * @throws ReflectionException
         */
        private function applyCoversAnnotationFilter(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData, $linesToBeCovered, array $linesToBeUsed): \void {}

        private function applyFilter(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data): \void {}

        private function applyIgnoredLinesFilter(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data): \void {}

        /**
         * @throws UnintentionallyCoveredCodeException
         */
        private function addUncoveredFilesFromFilter(): \void {}

        /**
         * @throws UnintentionallyCoveredCodeException
         */
        private function processUncoveredFilesFromFilter(): \void {}

        /**
         * @throws UnintentionallyCoveredCodeException
         * @throws ReflectionException
         */
        private function performUnintentionallyCoveredCodeCheck(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data, array $linesToBeCovered, array $linesToBeUsed): \void {}

        private function getAllowedLines(array $linesToBeCovered, array $linesToBeUsed): array {}

        /**
         * @throws ReflectionException
         */
        private function processUnintentionallyCoveredUnits(array $unintentionallyCoveredUnits): array {}

        private function coveredFileAnalyser(): \SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser {}

        private function uncoveredFileAnalyser(): \SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class CrapIndex
    {
        /**
         * @var int
         */
        private $cyclomaticComplexity;

        /**
         * @var float
         */
        private $codeCoverage;

        public static function fromCyclomaticComplexityAndCoveragePercentage(int $cyclomaticComplexity, float $codeCoverage): self {}

        public function __construct(int $cyclomaticComplexity, float $codeCoverage) {}

        public function asString(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use is_dir;
    use mkdir;
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Directory
    {
        /**
         * @throws DirectoryCouldNotBeCreatedException
         */
        public static function create(string $directory): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use array_keys;
    use is_file;
    use realpath;
    use strpos;
    use SebastianBergmann\FileIterator\Facade as FileIteratorFacade;

    final class Filter
    {
        /**
         * @psalm-var array<string,true>
         */
        private $files = [/** value is missing */];

        /**
         * @psalm-var array<string,bool>
         */
        private $isFileCache = [/** value is missing */];

        public function includeDirectory(string $directory, string $suffix = '.php', string $prefix = ''): \void {}

        /**
         * @psalm-param list<string> $files
         */
        public function includeFiles(array $filenames): \void {}

        public function includeFile(string $filename): \void {}

        public function excludeDirectory(string $directory, string $suffix = '.php', string $prefix = ''): \void {}

        public function excludeFile(string $filename): \void {}

        public function isFile(string $filename): bool {}

        public function isExcluded(string $filename): bool {}

        /**
         * @psalm-return list<string>
         */
        public function files(): array {}

        public function isEmpty(): bool {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use sprintf;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Percentage
    {
        /**
         * @var float
         */
        private $fraction;

        /**
         * @var float
         */
        private $total;

        public static function fromFractionAndTotal(float $fraction, float $total): self {}

        private function __construct(float $fraction, float $total) {}

        public function asFloat(): float {}

        public function asString(): string {}

        public function asFixedWidthString(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use array_key_exists;
    use array_keys;
    use array_merge;
    use array_unique;
    use count;
    use is_array;
    use ksort;
    use SebastianBergmann\CodeCoverage\Driver\Driver;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class ProcessedCodeCoverageData
    {
        /**
         * Line coverage data.
         * An array of filenames, each having an array of linenumbers, each executable line having an array of testcase ids.
         *
         * @var array
         */
        private $lineCoverage = [/** value is missing */];

        /**
         * Function coverage data.
         * Maintains base format of raw data (@see https://xdebug.org/docs/code_coverage), but each 'hit' entry is an array
         * of testcase ids.
         *
         * @var array
         */
        private $functionCoverage = [/** value is missing */];

        public function initializeUnseenData(\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData): \void {}

        public function markCodeAsExecutedByTestCase(string $testCaseId, \SebastianBergmann\CodeCoverage\RawCodeCoverageData $executedCode): \void {}

        public function setLineCoverage(array $lineCoverage): \void {}

        public function lineCoverage(): array {}

        public function setFunctionCoverage(array $functionCoverage): \void {}

        public function functionCoverage(): array {}

        public function coveredFiles(): array {}

        public function renameFile(string $oldFile, string $newFile): \void {}

        public function merge(self $newData): \void {}

        /**
         * Determine the priority for a line.
         *
         * 1 = the line is not set
         * 2 = the line has not been tested
         * 3 = the line is dead code
         * 4 = the line has been tested
         *
         * During a merge, a higher number is better.
         */
        private function priorityForLine(array $data, int $line): int {}

        /**
         * For a function we have never seen before, copy all data over and simply init the 'hit' array.
         */
        private function initPreviouslyUnseenFunction(string $file, string $functionName, array $functionData): \void {}

        /**
         * For a function we have seen before, only copy over and init the 'hit' array for any unseen branches and paths.
         * Techniques such as mocking and where the contents of a file are different vary during tests (e.g. compiling
         * containers) mean that the functions inside a file cannot be relied upon to be static.
         */
        private function initPreviouslySeenFunction(string $file, string $functionName, array $functionData): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use array_diff;
    use array_diff_key;
    use array_flip;
    use array_intersect;
    use array_intersect_key;
    use count;
    use file;
    use in_array;
    use range;
    use SebastianBergmann\CodeCoverage\Driver\Driver;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class RawCodeCoverageData
    {
        /**
         * @var array<string, array<int>>
         */
        private static $emptyLineCache = [/** value is missing */];

        /**
         * @var array
         *
         * @see https://xdebug.org/docs/code_coverage for format
         */
        private $lineCoverage;

        /**
         * @var array
         *
         * @see https://xdebug.org/docs/code_coverage for format
         */
        private $functionCoverage;

        public static function fromXdebugWithoutPathCoverage(array $rawCoverage): self {}

        public static function fromXdebugWithPathCoverage(array $rawCoverage): self {}

        public static function fromXdebugWithMixedCoverage(array $rawCoverage): self {}

        public static function fromUncoveredFile(string $filename, \SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser): self {}

        private function __construct(array $lineCoverage, array $functionCoverage) {}

        public function clear(): \void {}

        public function lineCoverage(): array {}

        public function functionCoverage(): array {}

        public function removeCoverageDataForFile(string $filename): \void {}

        /**
         * @param int[] $lines
         */
        public function keepCoverageDataOnlyForLines(string $filename, array $lines): \void {}

        /**
         * @param int[] $lines
         */
        public function removeCoverageDataForLines(string $filename, array $lines): \void {}

        /**
         * At the end of a file, the PHP interpreter always sees an implicit return. Where this occurs in a file that has
         * e.g. a class definition, that line cannot be invoked from a test and results in confusing coverage. This engine
         * implementation detail therefore needs to be masked which is done here by simply ensuring that all empty lines
         * are skipped over for coverage purposes.
         *
         * @see https://github.com/sebastianbergmann/php-code-coverage/issues/799
         */
        private function skipEmptyLines(): \void {}

        private function getEmptyLinesForFile(string $filename): array {}

    }
}

namespace SebastianBergmann\CodeCoverage
{
    use dirname;
    use SebastianBergmann\Version as VersionId;

    final class Version
    {
        /**
         * @var string
         */
        private static $version;

        public static function id(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Node
{
    use DIRECTORY_SEPARATOR;
    use array_merge;
    use str_replace;
    use substr;
    use Countable;
    use SebastianBergmann\CodeCoverage\Percentage;
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    abstract class AbstractNode
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var string
         */
        private $pathAsString;

        /**
         * @var array
         */
        private $pathAsArray;

        /**
         * @var AbstractNode
         */
        private $parent;

        /**
         * @var string
         */
        private $id;

        public function __construct(string $name, ?self $parent = null) {}

        public function name(): string {}

        public function id(): string {}

        public function pathAsString(): string {}

        public function pathAsArray(): array {}

        public function parent(): ?self {}

        public function percentageOfTestedClasses(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfTestedTraits(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfTestedClassesAndTraits(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfTestedFunctions(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfTestedMethods(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfTestedFunctionsAndMethods(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfExecutedLines(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfExecutedBranches(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function percentageOfExecutedPaths(): \SebastianBergmann\CodeCoverage\Percentage {}

        public function numberOfClassesAndTraits(): int {}

        public function numberOfTestedClassesAndTraits(): int {}

        public function classesAndTraits(): array {}

        public function numberOfFunctionsAndMethods(): int {}

        public function numberOfTestedFunctionsAndMethods(): int {}

        abstract public function classes(): array;

        abstract public function traits(): array;

        abstract public function functions(): array;

        abstract public function linesOfCode(): \SebastianBergmann\LinesOfCode\LinesOfCode;

        abstract public function numberOfExecutableLines(): int;

        abstract public function numberOfExecutedLines(): int;

        abstract public function numberOfExecutableBranches(): int;

        abstract public function numberOfExecutedBranches(): int;

        abstract public function numberOfExecutablePaths(): int;

        abstract public function numberOfExecutedPaths(): int;

        abstract public function numberOfClasses(): int;

        abstract public function numberOfTestedClasses(): int;

        abstract public function numberOfTraits(): int;

        abstract public function numberOfTestedTraits(): int;

        abstract public function numberOfMethods(): int;

        abstract public function numberOfTestedMethods(): int;

        abstract public function numberOfFunctions(): int;

        abstract public function numberOfTestedFunctions(): int;

    }
}

namespace SebastianBergmann\CodeCoverage\Node
{
    use DIRECTORY_SEPARATOR;
    use array_shift;
    use basename;
    use count;
    use dirname;
    use explode;
    use implode;
    use is_file;
    use str_replace;
    use strpos;
    use substr;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData;
    use SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Builder
    {
        /**
         * @var CoveredFileAnalyser
         */
        private $coveredFileAnalyser;

        public function __construct(\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser) {}

        public function build(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage): \SebastianBergmann\CodeCoverage\Node\Directory {}

        private function addItems(\SebastianBergmann\CodeCoverage\Node\Directory $root, array $items, array $tests): \void {}

        /**
         * Builds an array representation of the directory structure.
         *
         * For instance,
         *
         * <code>
         * Array
         * (
         *     [Money.php] => Array
         *         (
         *             ...
         *         )
         *
         *     [MoneyBag.php] => Array
         *         (
         *             ...
         *         )
         * )
         * </code>
         *
         * is transformed into
         *
         * <code>
         * Array
         * (
         *     [.] => Array
         *         (
         *             [Money.php] => Array
         *                 (
         *                     ...
         *                 )
         *
         *             [MoneyBag.php] => Array
         *                 (
         *                     ...
         *                 )
         *         )
         * )
         * </code>
         */
        private function buildDirectoryStructure(\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $data): array {}

        /**
         * Reduces the paths by cutting the longest common start path.
         *
         * For instance,
         *
         * <code>
         * Array
         * (
         *     [/home/sb/Money/Money.php] => Array
         *         (
         *             ...
         *         )
         *
         *     [/home/sb/Money/MoneyBag.php] => Array
         *         (
         *             ...
         *         )
         * )
         * </code>
         *
         * is reduced to
         *
         * <code>
         * Array
         * (
         *     [Money.php] => Array
         *         (
         *             ...
         *         )
         *
         *     [MoneyBag.php] => Array
         *         (
         *             ...
         *         )
         * )
         * </code>
         */
        private function reducePaths(\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $coverage): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Node
{
    use array_merge;
    use count;
    use IteratorAggregate;
    use RecursiveIteratorIterator;
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Directory extends \SebastianBergmann\CodeCoverage\Node\AbstractNode
    {
        /**
         * @var AbstractNode[]
         */
        private $children = [/** value is missing */];

        /**
         * @var Directory[]
         */
        private $directories = [/** value is missing */];

        /**
         * @var File[]
         */
        private $files = [/** value is missing */];

        /**
         * @var array
         */
        private $classes;

        /**
         * @var array
         */
        private $traits;

        /**
         * @var array
         */
        private $functions;

        /**
         * @var LinesOfCode
         */
        private $linesOfCode;

        /**
         * @var int
         */
        private $numFiles;

        /**
         * @var int
         */
        private $numExecutableLines;

        /**
         * @var int
         */
        private $numExecutedLines;

        /**
         * @var int
         */
        private $numExecutableBranches;

        /**
         * @var int
         */
        private $numExecutedBranches;

        /**
         * @var int
         */
        private $numExecutablePaths;

        /**
         * @var int
         */
        private $numExecutedPaths;

        /**
         * @var int
         */
        private $numClasses;

        /**
         * @var int
         */
        private $numTestedClasses;

        /**
         * @var int
         */
        private $numTraits;

        /**
         * @var int
         */
        private $numTestedTraits;

        /**
         * @var int
         */
        private $numMethods;

        /**
         * @var int
         */
        private $numTestedMethods;

        /**
         * @var int
         */
        private $numFunctions;

        /**
         * @var int
         */
        private $numTestedFunctions;

        public function count(): int {}

        public function getIterator(): \RecursiveIteratorIterator {}

        public function addDirectory(string $name): self {}

        public function addFile(\SebastianBergmann\CodeCoverage\Node\File $file): \void {}

        public function directories(): array {}

        public function files(): array {}

        public function children(): array {}

        public function classes(): array {}

        public function traits(): array {}

        public function functions(): array {}

        public function linesOfCode(): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        public function numberOfExecutableLines(): int {}

        public function numberOfExecutedLines(): int {}

        public function numberOfExecutableBranches(): int {}

        public function numberOfExecutedBranches(): int {}

        public function numberOfExecutablePaths(): int {}

        public function numberOfExecutedPaths(): int {}

        public function numberOfClasses(): int {}

        public function numberOfTestedClasses(): int {}

        public function numberOfTraits(): int {}

        public function numberOfTestedTraits(): int {}

        public function numberOfMethods(): int {}

        public function numberOfTestedMethods(): int {}

        public function numberOfFunctions(): int {}

        public function numberOfTestedFunctions(): int {}

    }
}

namespace SebastianBergmann\CodeCoverage\Node
{
    use array_filter;
    use count;
    use range;
    use SebastianBergmann\CodeCoverage\CrapIndex;
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class File extends \SebastianBergmann\CodeCoverage\Node\AbstractNode
    {
        /**
         * @var array
         */
        private $lineCoverageData;

        /**
         * @var array
         */
        private $functionCoverageData;

        /**
         * @var array
         */
        private $testData;

        /**
         * @var int
         */
        private $numExecutableLines = 0;

        /**
         * @var int
         */
        private $numExecutedLines = 0;

        /**
         * @var int
         */
        private $numExecutableBranches = 0;

        /**
         * @var int
         */
        private $numExecutedBranches = 0;

        /**
         * @var int
         */
        private $numExecutablePaths = 0;

        /**
         * @var int
         */
        private $numExecutedPaths = 0;

        /**
         * @var array
         */
        private $classes = [/** value is missing */];

        /**
         * @var array
         */
        private $traits = [/** value is missing */];

        /**
         * @var array
         */
        private $functions = [/** value is missing */];

        /**
         * @var LinesOfCode
         */
        private $linesOfCode;

        /**
         * @var int
         */
        private $numClasses;

        /**
         * @var int
         */
        private $numTestedClasses = 0;

        /**
         * @var int
         */
        private $numTraits;

        /**
         * @var int
         */
        private $numTestedTraits = 0;

        /**
         * @var int
         */
        private $numMethods;

        /**
         * @var int
         */
        private $numTestedMethods;

        /**
         * @var int
         */
        private $numTestedFunctions;

        /**
         * @var array
         */
        private $codeUnitsByLine = [/** value is missing */];

        public function __construct(string $name, \SebastianBergmann\CodeCoverage\Node\AbstractNode $parent, array $lineCoverageData, array $functionCoverageData, array $testData, array $classes, array $traits, array $functions, \SebastianBergmann\LinesOfCode\LinesOfCode $linesOfCode) {}

        public function count(): int {}

        public function lineCoverageData(): array {}

        public function functionCoverageData(): array {}

        public function testData(): array {}

        public function classes(): array {}

        public function traits(): array {}

        public function functions(): array {}

        public function linesOfCode(): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        public function numberOfExecutableLines(): int {}

        public function numberOfExecutedLines(): int {}

        public function numberOfExecutableBranches(): int {}

        public function numberOfExecutedBranches(): int {}

        public function numberOfExecutablePaths(): int {}

        public function numberOfExecutedPaths(): int {}

        public function numberOfClasses(): int {}

        public function numberOfTestedClasses(): int {}

        public function numberOfTraits(): int {}

        public function numberOfTestedTraits(): int {}

        public function numberOfMethods(): int {}

        public function numberOfTestedMethods(): int {}

        public function numberOfFunctions(): int {}

        public function numberOfTestedFunctions(): int {}

        private function calculateStatistics(array $classes, array $traits, array $functions): \void {}

        private function processClasses(array $classes): \void {}

        private function processTraits(array $traits): \void {}

        private function processFunctions(array $functions): \void {}

        private function newMethod(string $className, string $methodName, array $method, string $link): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\Node
{
    use count;
    use RecursiveIterator;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Iterator
    {
        /**
         * @var int
         */
        private $position;

        /**
         * @var AbstractNode[]
         */
        private $nodes;

        public function __construct(\SebastianBergmann\CodeCoverage\Node\Directory $node) {}

        /**
         * Rewinds the Iterator to the first element.
         */
        public function rewind(): \void {}

        /**
         * Checks if there is a current element after calls to rewind() or next().
         */
        public function valid(): bool {}

        /**
         * Returns the key of the current element.
         */
        public function key(): int {}

        /**
         * Returns the current element.
         */
        public function current(): ?\SebastianBergmann\CodeCoverage\Node\AbstractNode {}

        /**
         * Moves forward to next element.
         */
        public function next(): \void {}

        /**
         * Returns the sub iterator for the current element.
         *
         * @return Iterator
         */
        public function getChildren(): self {}

        /**
         * Checks whether the current element has children.
         */
        public function hasChildren(): bool {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Html
{
    use array_values;
    use arsort;
    use asort;
    use count;
    use explode;
    use floor;
    use json_encode;
    use sprintf;
    use str_replace;
    use SebastianBergmann\CodeCoverage\Node\AbstractNode;
    use SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
    use SebastianBergmann\Template\Template;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Dashboard extends \SebastianBergmann\CodeCoverage\Report\Html\Renderer
    {
        public function render(\SebastianBergmann\CodeCoverage\Node\Directory $node, string $file): \void {}

        protected function activeBreadcrumb(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node): string {}

        /**
         * Returns the data for the Class/Method Complexity charts.
         */
        private function complexity(array $classes, string $baseLink): array {}

        /**
         * Returns the data for the Class / Method Coverage Distribution chart.
         */
        private function coverageDistribution(array $classes): array {}

        /**
         * Returns the classes / methods with insufficient coverage.
         */
        private function insufficientCoverage(array $classes, string $baseLink): array {}

        /**
         * Returns the project risks according to the CRAP index.
         */
        private function projectRisks(array $classes, string $baseLink): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Html
{
    use count;
    use sprintf;
    use str_repeat;
    use SebastianBergmann\CodeCoverage\Node\AbstractNode;
    use SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
    use SebastianBergmann\Template\Template;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Directory extends \SebastianBergmann\CodeCoverage\Report\Html\Renderer
    {
        public function render(\SebastianBergmann\CodeCoverage\Node\Directory $node, string $file): \void {}

        private function renderItem(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, bool $total = false): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Html
{
    use ENT_COMPAT;
    use ENT_HTML401;
    use ENT_SUBSTITUTE;
    use T_ABSTRACT;
    use T_ARRAY;
    use T_AS;
    use T_BREAK;
    use T_CALLABLE;
    use T_CASE;
    use T_CATCH;
    use T_CLASS;
    use T_CLONE;
    use T_COMMENT;
    use T_CONST;
    use T_CONTINUE;
    use T_DECLARE;
    use T_DEFAULT;
    use T_DO;
    use T_DOC_COMMENT;
    use T_ECHO;
    use T_ELSE;
    use T_ELSEIF;
    use T_EMPTY;
    use T_ENDDECLARE;
    use T_ENDFOR;
    use T_ENDFOREACH;
    use T_ENDIF;
    use T_ENDSWITCH;
    use T_ENDWHILE;
    use T_EVAL;
    use T_EXIT;
    use T_EXTENDS;
    use T_FINAL;
    use T_FINALLY;
    use T_FOR;
    use T_FOREACH;
    use T_FUNCTION;
    use T_GLOBAL;
    use T_GOTO;
    use T_HALT_COMPILER;
    use T_IF;
    use T_IMPLEMENTS;
    use T_INCLUDE;
    use T_INCLUDE_ONCE;
    use T_INLINE_HTML;
    use T_INSTANCEOF;
    use T_INSTEADOF;
    use T_INTERFACE;
    use T_ISSET;
    use T_LIST;
    use T_NAMESPACE;
    use T_NEW;
    use T_PRINT;
    use T_PRIVATE;
    use T_PROTECTED;
    use T_PUBLIC;
    use T_REQUIRE;
    use T_REQUIRE_ONCE;
    use T_RETURN;
    use T_STATIC;
    use T_SWITCH;
    use T_THROW;
    use T_TRAIT;
    use T_TRY;
    use T_UNSET;
    use T_USE;
    use T_VAR;
    use T_WHILE;
    use T_YIELD;
    use T_YIELD_FROM;
    use array_key_exists;
    use array_pop;
    use array_unique;
    use constant;
    use count;
    use defined;
    use explode;
    use file_get_contents;
    use htmlspecialchars;
    use is_string;
    use sprintf;
    use str_replace;
    use substr;
    use token_get_all;
    use trim;
    use PHPUnit\Runner\BaseTestRunner;
    use SebastianBergmann\CodeCoverage\Node\File as FileNode;
    use SebastianBergmann\CodeCoverage\Percentage;
    use SebastianBergmann\Template\Template;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class File extends \SebastianBergmann\CodeCoverage\Report\Html\Renderer
    {
        /**
         * @psalm-var array<int,true>
         */
        private static $keywordTokens = [/** value is missing */];

        /**
         * @var array
         */
        private static $formattedSourceCache = [/** value is missing */];

        /**
         * @var int
         */
        private $htmlSpecialCharsFlags = 10;

        public function render(\SebastianBergmann\CodeCoverage\Node\File $node, string $file): \void {}

        private function renderItems(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderTraitOrClassItems(array $items, \SebastianBergmann\Template\Template $template, \SebastianBergmann\Template\Template $methodItemTemplate): string {}

        private function renderFunctionItems(array $functions, \SebastianBergmann\Template\Template $template): string {}

        private function renderFunctionOrMethodItem(\SebastianBergmann\Template\Template $template, array $item, string $indent = ''): string {}

        private function renderSourceWithLineCoverage(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderSourceWithBranchCoverage(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderSourceWithPathCoverage(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderBranchStructure(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderBranchLines(array $branch, array $codeLines, array $testData): string {}

        private function renderPathStructure(\SebastianBergmann\CodeCoverage\Node\File $node): string {}

        private function renderPathLines(array $path, array $branches, array $codeLines, array $testData): string {}

        private function renderLine(\SebastianBergmann\Template\Template $template, int $lineNumber, string $lineContent, string $class, string $popover): string {}

        private function loadFile(string $file): array {}

        private function abbreviateClassName(string $className): string {}

        private function abbreviateMethodName(string $methodName): string {}

        private function createPopoverContentForTest(string $test, array $testData): string {}

        private function isComment(int $token): bool {}

        private function isInlineHtml(int $token): bool {}

        private function isKeyword(int $token): bool {}

        /**
         * @psalm-return array<int,true>
         */
        private static function keywordTokens(): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Html
{
    use DIRECTORY_SEPARATOR;
    use copy;
    use date;
    use dirname;
    use substr;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory as DirectoryUtil;
    use SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Facade
    {
        /**
         * @var string
         */
        private $templatePath;

        /**
         * @var string
         */
        private $generator;

        /**
         * @var int
         */
        private $lowUpperBound;

        /**
         * @var int
         */
        private $highLowerBound;

        public function __construct(int $lowUpperBound = 50, int $highLowerBound = 90, string $generator = '') {}

        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, string $target): \void {}

        private function copyFiles(string $target): \void {}

        private function directory(string $directory): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Html
{
    use array_pop;
    use count;
    use phpversion;
    use sprintf;
    use str_repeat;
    use substr_count;
    use SebastianBergmann\CodeCoverage\Node\AbstractNode;
    use SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
    use SebastianBergmann\CodeCoverage\Node\File as FileNode;
    use SebastianBergmann\CodeCoverage\Version;
    use SebastianBergmann\Environment\Runtime;
    use SebastianBergmann\Template\Template;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    abstract class Renderer
    {
        /**
         * @var string
         */
        protected $templatePath;

        /**
         * @var string
         */
        protected $generator;

        /**
         * @var string
         */
        protected $date;

        /**
         * @var int
         */
        protected $lowUpperBound;

        /**
         * @var int
         */
        protected $highLowerBound;

        /**
         * @var bool
         */
        protected $hasBranchCoverage;

        /**
         * @var string
         */
        protected $version;

        public function __construct(string $templatePath, string $generator, string $date, int $lowUpperBound, int $highLowerBound, bool $hasBranchCoverage) {}

        protected function renderItemTemplate(\SebastianBergmann\Template\Template $template, array $data): string {}

        protected function setCommonTemplateVariables(\SebastianBergmann\Template\Template $template, \SebastianBergmann\CodeCoverage\Node\AbstractNode $node): \void {}

        protected function breadcrumbs(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node): string {}

        protected function activeBreadcrumb(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node): string {}

        protected function inactiveBreadcrumb(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, string $pathToRoot): string {}

        protected function pathToRoot(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node): string {}

        protected function coverageBar(float $percent): string {}

        protected function colorLevel(float $percent): string {}

        private function runtimeString(): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use constant;
    use phpversion;
    use DateTimeImmutable;
    use DOMElement;
    use SebastianBergmann\Environment\Runtime;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class BuildInformation
    {
        /**
         * @var DOMElement
         */
        private $contextNode;

        public function __construct(\DOMElement $contextNode) {}

        public function setRuntimeInformation(\SebastianBergmann\Environment\Runtime $runtime): \void {}

        public function setBuildTime(\DateTimeImmutable $date): \void {}

        public function setGeneratorVersions(string $phpUnitVersion, string $coverageVersion): \void {}

        private function nodeByName(string $name): \DOMElement {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMElement;
    use SebastianBergmann\CodeCoverage\ReportAlreadyFinalizedException;
    use XMLWriter;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Coverage
    {
        /**
         * @var XMLWriter
         */
        private $writer;

        /**
         * @var DOMElement
         */
        private $contextNode;

        /**
         * @var bool
         */
        private $finalized = false;

        public function __construct(\DOMElement $context, string $line) {}

        /**
         * @throws ReportAlreadyFinalizedException
         */
        public function addTest(string $test): \void {}

        public function finalize(): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Directory extends \SebastianBergmann\CodeCoverage\Report\Xml\Node
    {
    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DIRECTORY_SEPARATOR;
    use PHP_EOL;
    use count;
    use dirname;
    use file_get_contents;
    use file_put_contents;
    use is_array;
    use is_dir;
    use is_file;
    use is_writable;
    use libxml_clear_errors;
    use libxml_get_errors;
    use libxml_use_internal_errors;
    use sprintf;
    use strlen;
    use substr;
    use DateTimeImmutable;
    use DOMDocument;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory as DirectoryUtil;
    use SebastianBergmann\CodeCoverage\Driver\PathExistsButIsNotDirectoryException;
    use SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
    use SebastianBergmann\CodeCoverage\Node\AbstractNode;
    use SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
    use SebastianBergmann\CodeCoverage\Node\File as FileNode;
    use SebastianBergmann\CodeCoverage\Version;
    use SebastianBergmann\CodeCoverage\XmlException;
    use SebastianBergmann\Environment\Runtime;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Facade
    {
        /**
         * @var string
         */
        private $target;

        /**
         * @var Project
         */
        private $project;

        /**
         * @var string
         */
        private $phpUnitVersion;

        public function __construct(string $version) {}

        /**
         * @throws XmlException
         */
        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, string $target): \void {}

        private function setBuildInformation(): \void {}

        /**
         * @throws PathExistsButIsNotDirectoryException
         * @throws WriteOperationFailedException
         */
        private function initTargetDirectory(string $directory): \void {}

        /**
         * @throws XmlException
         */
        private function processDirectory(\SebastianBergmann\CodeCoverage\Node\Directory $directory, \SebastianBergmann\CodeCoverage\Report\Xml\Node $context): \void {}

        /**
         * @throws XmlException
         */
        private function processFile(\SebastianBergmann\CodeCoverage\Node\File $file, \SebastianBergmann\CodeCoverage\Report\Xml\Directory $context): \void {}

        private function processUnit(array $unit, \SebastianBergmann\CodeCoverage\Report\Xml\Report $report): \void {}

        private function processFunction(array $function, \SebastianBergmann\CodeCoverage\Report\Xml\Report $report): \void {}

        private function processTests(array $tests): \void {}

        private function setTotals(\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, \SebastianBergmann\CodeCoverage\Report\Xml\Totals $totals): \void {}

        private function targetDirectory(): string {}

        /**
         * @throws XmlException
         */
        private function saveDocument(\DOMDocument $document, string $name): \void {}

        /**
         * @throws XmlException
         *
         * @see https://bugs.php.net/bug.php?id=79191
         */
        private function documentAsString(\DOMDocument $document): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    class File
    {
        /**
         * @var DOMDocument
         */
        private $dom;

        /**
         * @var DOMElement
         */
        private $contextNode;

        public function __construct(\DOMElement $context) {}

        public function totals(): \SebastianBergmann\CodeCoverage\Report\Xml\Totals {}

        public function lineCoverage(string $line): \SebastianBergmann\CodeCoverage\Report\Xml\Coverage {}

        protected function contextNode(): \DOMElement {}

        protected function dom(): \DOMDocument {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Method
    {
        /**
         * @var DOMElement
         */
        private $contextNode;

        public function __construct(\DOMElement $context, string $name) {}

        public function setSignature(string $signature): \void {}

        public function setLines(string $start, ?string $end = null): \void {}

        public function setTotals(string $executable, string $executed, string $coverage): \void {}

        public function setCrap(string $crap): \void {}

        private function setName(string $name): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMDocument;
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    abstract class Node
    {
        /**
         * @var DOMDocument
         */
        private $dom;

        /**
         * @var DOMElement
         */
        private $contextNode;

        public function __construct(\DOMElement $context) {}

        public function dom(): \DOMDocument {}

        public function totals(): \SebastianBergmann\CodeCoverage\Report\Xml\Totals {}

        public function addDirectory(string $name): \SebastianBergmann\CodeCoverage\Report\Xml\Directory {}

        public function addFile(string $name, string $href): \SebastianBergmann\CodeCoverage\Report\Xml\File {}

        protected function setContextNode(\DOMElement $context): \void {}

        protected function contextNode(): \DOMElement {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Project extends \SebastianBergmann\CodeCoverage\Report\Xml\Node
    {
        public function __construct(string $directory) {}

        public function projectSourceDirectory(): string {}

        public function buildInformation(): \SebastianBergmann\CodeCoverage\Report\Xml\BuildInformation {}

        public function tests(): \SebastianBergmann\CodeCoverage\Report\Xml\Tests {}

        public function asDom(): \DOMDocument {}

        private function init(): \void {}

        private function setProjectSourceDirectory(string $name): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use basename;
    use dirname;
    use DOMDocument;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Report extends \SebastianBergmann\CodeCoverage\Report\Xml\File
    {
        public function __construct(string $name) {}

        public function asDom(): \DOMDocument {}

        public function functionObject($name): \SebastianBergmann\CodeCoverage\Report\Xml\Method {}

        public function classObject($name): \SebastianBergmann\CodeCoverage\Report\Xml\Unit {}

        public function traitObject($name): \SebastianBergmann\CodeCoverage\Report\Xml\Unit {}

        public function source(): \SebastianBergmann\CodeCoverage\Report\Xml\Source {}

        private function setName(string $name): \void {}

        private function unitObject(string $tagName, $name): \SebastianBergmann\CodeCoverage\Report\Xml\Unit {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMElement;
    use TheSeer\Tokenizer\NamespaceUri;
    use TheSeer\Tokenizer\Tokenizer;
    use TheSeer\Tokenizer\XMLSerializer;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Source
    {
        /** @var DOMElement */
        private $context;

        public function __construct(\DOMElement $context) {}

        public function setSourceCode(string $source): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Tests
    {
        private $contextNode;

        private $codeMap = [/** value is missing */];

        public function __construct(\DOMElement $context) {}

        public function addTest(string $test, array $result): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use sprintf;
    use DOMElement;
    use DOMNode;
    use SebastianBergmann\CodeCoverage\Percentage;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Totals
    {
        /**
         * @var DOMNode
         */
        private $container;

        /**
         * @var DOMElement
         */
        private $linesNode;

        /**
         * @var DOMElement
         */
        private $methodsNode;

        /**
         * @var DOMElement
         */
        private $functionsNode;

        /**
         * @var DOMElement
         */
        private $classesNode;

        /**
         * @var DOMElement
         */
        private $traitsNode;

        public function __construct(\DOMElement $container) {}

        public function container(): \DOMNode {}

        public function setNumLines(int $loc, int $cloc, int $ncloc, int $executable, int $executed): \void {}

        public function setNumClasses(int $count, int $tested): \void {}

        public function setNumTraits(int $count, int $tested): \void {}

        public function setNumMethods(int $count, int $tested): \void {}

        public function setNumFunctions(int $count, int $tested): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report\Xml
{
    use DOMElement;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Unit
    {
        /**
         * @var DOMElement
         */
        private $contextNode;

        public function __construct(\DOMElement $context, string $name) {}

        public function setLines(int $start, int $executable, int $executed): \void {}

        public function setCrap(float $crap): \void {}

        public function setNamespace(string $namespace): \void {}

        public function addMethod(string $name): \SebastianBergmann\CodeCoverage\Report\Xml\Method {}

        private function setName(string $name): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report
{
    use count;
    use dirname;
    use file_put_contents;
    use is_string;
    use ksort;
    use max;
    use range;
    use time;
    use DOMDocument;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory;
    use SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
    use SebastianBergmann\CodeCoverage\Node\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Clover
    {
        /**
         * @throws WriteOperationFailedException
         */
        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report
{
    use count;
    use dirname;
    use file_put_contents;
    use range;
    use time;
    use DOMImplementation;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory;
    use SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
    use SebastianBergmann\CodeCoverage\Node\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Cobertura
    {
        /**
         * @throws WriteOperationFailedException
         */
        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report
{
    use date;
    use dirname;
    use file_put_contents;
    use htmlspecialchars;
    use is_string;
    use round;
    use DOMDocument;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory;
    use SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
    use SebastianBergmann\CodeCoverage\Node\File;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Crap4j
    {
        /**
         * @var int
         */
        private $threshold;

        public function __construct(int $threshold = 30) {}

        /**
         * @throws WriteOperationFailedException
         */
        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null): string {}

        private function crapLoad(float $crapValue, int $cyclomaticComplexity, float $coveragePercent): float {}

        private function roundValue(float $value): float {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report
{
    use addcslashes;
    use dirname;
    use file_put_contents;
    use serialize;
    use sprintf;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Directory;
    use SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class PHP
    {
        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\Report
{
    use PHP_EOL;
    use array_map;
    use date;
    use ksort;
    use max;
    use sprintf;
    use str_pad;
    use strlen;
    use SebastianBergmann\CodeCoverage\CodeCoverage;
    use SebastianBergmann\CodeCoverage\Node\File;
    use SebastianBergmann\CodeCoverage\Percentage;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class Text
    {
        /**
         * @var string
         */
        const COLOR_GREEN = '[30;42m';

        /**
         * @var string
         */
        const COLOR_YELLOW = '[30;43m';

        /**
         * @var string
         */
        const COLOR_RED = '[37;41m';

        /**
         * @var string
         */
        const COLOR_HEADER = '[1;37;40m';

        /**
         * @var string
         */
        const COLOR_RESET = '[0m';

        /**
         * @var string
         */
        const COLOR_EOL = '[2K';

        /**
         * @var int
         */
        private $lowUpperBound;

        /**
         * @var int
         */
        private $highLowerBound;

        /**
         * @var bool
         */
        private $showUncoveredFiles;

        /**
         * @var bool
         */
        private $showOnlySummary;

        public function __construct(int $lowUpperBound = 50, int $highLowerBound = 90, bool $showUncoveredFiles = false, bool $showOnlySummary = false) {}

        public function process(\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, bool $showColors = false): string {}

        private function coverageColor(int $numberOfCoveredElements, int $totalNumberOfElements): string {}

        private function printCoverageCounts(int $numberOfCoveredElements, int $totalNumberOfElements, int $precision): string {}

        /**
         * @param false|string $string
         */
        private function format(string $color, int $padding, $string): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use DIRECTORY_SEPARATOR;
    use file_get_contents;
    use file_put_contents;
    use filemtime;
    use hash;
    use is_file;
    use serialize;
    use unserialize;
    use SebastianBergmann\CodeCoverage\Directory;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    abstract class Cache
    {
        /**
         * @var string
         */
        private $directory;

        public function __construct(string $directory) {}

        protected function has(string $filename, string $key): bool {}

        /**
         * @psalm-param list<class-string> $allowedClasses
         *
         * @return mixed
         */
        protected function read(string $filename, string $key, array $allowedClasses = [/** value is missing */]) {}

        /**
         * @param mixed $data
         */
        protected function write(string $filename, string $key, $data): \void {}

        private function cacheFile(string $filename, string $key): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use SebastianBergmann\CodeCoverage\Filter;

    final class CacheWarmer
    {
        public function warmCache(string $cacheDirectory, bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecatedCode, \SebastianBergmann\CodeCoverage\Filter $filter): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class CachingCoveredFileAnalyser extends \SebastianBergmann\CodeCoverage\StaticAnalysis\Cache implements \SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser
    {
        /**
         * @var CoveredFileAnalyser
         */
        private $coveredFileAnalyser;

        /**
         * @var array
         */
        private $cache = [/** value is missing */];

        public function __construct(string $directory, \SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser) {}

        public function classesIn(string $filename): array {}

        public function traitsIn(string $filename): array {}

        public function functionsIn(string $filename): array {}

        public function linesOfCodeFor(string $filename): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        public function ignoredLinesFor(string $filename): array {}

        public function process(string $filename): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class CachingUncoveredFileAnalyser extends \SebastianBergmann\CodeCoverage\StaticAnalysis\Cache implements \SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser
    {
        /**
         * @var UncoveredFileAnalyser
         */
        private $uncoveredFileAnalyser;

        public function __construct(string $directory, \SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser) {}

        public function executableLinesIn(string $filename): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use implode;
    use rtrim;
    use trim;
    use PhpParser\Node;
    use PhpParser\Node\Identifier;
    use PhpParser\Node\Name;
    use PhpParser\Node\NullableType;
    use PhpParser\Node\Stmt\Class_;
    use PhpParser\Node\Stmt\ClassMethod;
    use PhpParser\Node\Stmt\Function_;
    use PhpParser\Node\Stmt\Interface_;
    use PhpParser\Node\Stmt\Trait_;
    use PhpParser\Node\UnionType;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitorAbstract;
    use SebastianBergmann\Complexity\CyclomaticComplexityCalculatingVisitor;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class CodeUnitFindingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @var array
         */
        private $classes = [/** value is missing */];

        /**
         * @var array
         */
        private $traits = [/** value is missing */];

        /**
         * @var array
         */
        private $functions = [/** value is missing */];

        public function enterNode(\PhpParser\Node $node) {}

        public function classes(): array {}

        public function traits(): array {}

        public function functions(): array {}

        /**
         * @psalm-param ClassMethod|Function_ $node
         */
        private function cyclomaticComplexity(\PhpParser\Node $node): int {}

        /**
         * @psalm-param ClassMethod|Function_ $node
         */
        private function signature(\PhpParser\Node $node): string {}

        /**
         * @psalm-param Identifier|Name|NullableType|UnionType $type
         */
        private function type(\PhpParser\Node $type): string {}

        private function visibility(\PhpParser\Node\Stmt\ClassMethod $node): string {}

        private function processClass(\PhpParser\Node\Stmt\Class_ $node): \void {}

        private function processTrait(\PhpParser\Node\Stmt\Trait_ $node): \void {}

        private function processMethod(\PhpParser\Node\Stmt\ClassMethod $node): \void {}

        private function processFunction(\PhpParser\Node\Stmt\Function_ $node): \void {}

        private function namespace(string $namespacedName, string $name): string {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    interface CoveredFileAnalyser
    {
        public function classesIn(string $filename): array;

        public function traitsIn(string $filename): array;

        public function functionsIn(string $filename): array;

        public function linesOfCodeFor(string $filename): \SebastianBergmann\LinesOfCode\LinesOfCode;

        public function ignoredLinesFor(string $filename): array;

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use array_unique;
    use sort;
    use PhpParser\Node;
    use PhpParser\Node\Stmt\Break_;
    use PhpParser\Node\Stmt\Case_;
    use PhpParser\Node\Stmt\Catch_;
    use PhpParser\Node\Stmt\Continue_;
    use PhpParser\Node\Stmt\Do_;
    use PhpParser\Node\Stmt\Echo_;
    use PhpParser\Node\Stmt\Else_;
    use PhpParser\Node\Stmt\ElseIf_;
    use PhpParser\Node\Stmt\Expression;
    use PhpParser\Node\Stmt\Finally_;
    use PhpParser\Node\Stmt\For_;
    use PhpParser\Node\Stmt\Foreach_;
    use PhpParser\Node\Stmt\Goto_;
    use PhpParser\Node\Stmt\If_;
    use PhpParser\Node\Stmt\Return_;
    use PhpParser\Node\Stmt\Switch_;
    use PhpParser\Node\Stmt\Throw_;
    use PhpParser\Node\Stmt\TryCatch;
    use PhpParser\Node\Stmt\Unset_;
    use PhpParser\Node\Stmt\While_;
    use PhpParser\NodeVisitorAbstract;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class ExecutableLinesFindingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @psalm-var list<int>
         */
        private $executableLines = [/** value is missing */];

        public function enterNode(\PhpParser\Node $node): \void {}

        /**
         * @psalm-return list<int>
         */
        public function executableLines(): array {}

        private function isExecutable(\PhpParser\Node $node): bool {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use array_merge;
    use range;
    use strpos;
    use PhpParser\Node;
    use PhpParser\Node\Stmt\Class_;
    use PhpParser\Node\Stmt\ClassMethod;
    use PhpParser\Node\Stmt\Function_;
    use PhpParser\Node\Stmt\Interface_;
    use PhpParser\Node\Stmt\Trait_;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitorAbstract;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class IgnoredLinesFindingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @psalm-var list<int>
         */
        private $ignoredLines = [/** value is missing */];

        /**
         * @var bool
         */
        private $useAnnotationsForIgnoringCode;

        /**
         * @var bool
         */
        private $ignoreDeprecated;

        public function __construct(bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecated) {}

        public function enterNode(\PhpParser\Node $node): ?int {}

        /**
         * @psalm-return list<int>
         */
        public function ignoredLines(): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use array_unique;
    use assert;
    use file_get_contents;
    use is_array;
    use sprintf;
    use substr_count;
    use token_get_all;
    use trim;
    use PhpParser\Error;
    use PhpParser\Lexer;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitor\NameResolver;
    use PhpParser\NodeVisitor\ParentConnectingVisitor;
    use PhpParser\ParserFactory;
    use SebastianBergmann\CodeCoverage\ParserException;
    use SebastianBergmann\LinesOfCode\LineCountingVisitor;
    use SebastianBergmann\LinesOfCode\LinesOfCode;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class ParsingCoveredFileAnalyser implements \SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser
    {
        /**
         * @var array
         */
        private $classes = [/** value is missing */];

        /**
         * @var array
         */
        private $traits = [/** value is missing */];

        /**
         * @var array
         */
        private $functions = [/** value is missing */];

        /**
         * @var LinesOfCode[]
         */
        private $linesOfCode = [/** value is missing */];

        /**
         * @var array
         */
        private $ignoredLines = [/** value is missing */];

        /**
         * @var bool
         */
        private $useAnnotationsForIgnoringCode;

        /**
         * @var bool
         */
        private $ignoreDeprecatedCode;

        public function __construct(bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecatedCode) {}

        public function classesIn(string $filename): array {}

        public function traitsIn(string $filename): array {}

        public function functionsIn(string $filename): array {}

        public function linesOfCodeFor(string $filename): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        public function ignoredLinesFor(string $filename): array {}

        /**
         * @throws ParserException
         */
        private function analyse(string $filename): \void {}

        private function findLinesIgnoredByLineBasedAnnotations(string $filename, string $source, bool $useAnnotationsForIgnoringCode): \void {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{
    use PhpParser\Error;
    use PhpParser\Lexer;
    use PhpParser\NodeTraverser;
    use PhpParser\ParserFactory;

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    final class ParsingUncoveredFileAnalyser implements \SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser
    {
        public function executableLinesIn(string $filename): array {}

    }
}

namespace SebastianBergmann\CodeCoverage\StaticAnalysis
{

    /**
     * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
     */
    interface UncoveredFileAnalyser
    {
        public function executableLinesIn(string $filename): array;

    }
}

namespace SebastianBergmann\FileIterator
{
    use DIRECTORY_SEPARATOR;
    use array_unique;
    use count;
    use dirname;
    use explode;
    use is_file;
    use is_string;
    use realpath;
    use sort;

    class Facade
    {
        /**
         * @param array|string $paths
         * @param array|string $suffixes
         * @param array|string $prefixes
         */
        public function getFilesAsArray($paths, $suffixes = '', $prefixes = '', array $exclude = [/** value is missing */], bool $commonPath = false): array {}

        protected function getCommonPath(array $files): string {}

    }
}

namespace SebastianBergmann\FileIterator
{
    use GLOB_ONLYDIR;
    use array_filter;
    use array_map;
    use array_merge;
    use glob;
    use is_dir;
    use is_string;
    use realpath;
    use AppendIterator;
    use RecursiveDirectoryIterator;
    use RecursiveIteratorIterator;

    class Factory
    {
        /**
         * @param array|string $paths
         * @param array|string $suffixes
         * @param array|string $prefixes
         */
        public function getFileIterator($paths, $suffixes = '', $prefixes = '', array $exclude = [/** value is missing */]): \AppendIterator {}

        protected function getPathsAfterResolvingWildcards(array $paths): array {}

    }
}

namespace SebastianBergmann\FileIterator
{
    use array_filter;
    use array_map;
    use preg_match;
    use realpath;
    use str_replace;
    use strlen;
    use strpos;
    use substr;
    use FilterIterator;

    class Iterator extends \FilterIterator
    {
        const PREFIX = 0;

        const SUFFIX = 1;

        /**
         * @var string
         */
        private $basePath;

        /**
         * @var array
         */
        private $suffixes = [/** value is missing */];

        /**
         * @var array
         */
        private $prefixes = [/** value is missing */];

        /**
         * @var array
         */
        private $exclude = [/** value is missing */];

        public function __construct(string $basePath, \Iterator $iterator, array $suffixes = [/** value is missing */], array $prefixes = [/** value is missing */], array $exclude = [/** value is missing */]) {}

        public function accept(): bool {}

        private function acceptPath(string $path): bool {}

        private function acceptPrefix(string $filename): bool {}

        private function acceptSuffix(string $filename): bool {}

        private function acceptSubString(string $filename, array $subStrings, int $type): bool {}

    }
}

namespace SebastianBergmann\Invoker
{
    use Throwable;

    interface Exception
    {
    }
}

namespace SebastianBergmann\Invoker
{
    use RuntimeException;

    final class ProcessControlExtensionNotLoadedException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Invoker
{
    use RuntimeException;

    final class TimeoutException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Invoker
{
    use SIGALRM;
    use call_user_func_array;
    use function_exists;
    use pcntl_alarm;
    use pcntl_async_signals;
    use pcntl_signal;
    use sprintf;
    use Throwable;

    final class Invoker
    {
        /**
         * @var int
         */
        private $timeout;

        /**
         * @throws Throwable
         */
        public function invoke(callable $callable, array $arguments, int $timeout) {}

        public function canInvokeWithTimeout(): bool {}

    }
}

namespace SebastianBergmann\Template
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Template
{

    final class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\Template
{
    use InvalidArgumentException;

    final class RuntimeException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\Template
{
    use array_merge;
    use file_exists;
    use file_get_contents;
    use file_put_contents;
    use sprintf;
    use str_replace;

    final class Template
    {
        /**
         * @var string
         */
        private $template = '';

        /**
         * @var string
         */
        private $openDelimiter;

        /**
         * @var string
         */
        private $closeDelimiter;

        /**
         * @var array
         */
        private $values = [/** value is missing */];

        /**
         * @throws InvalidArgumentException
         */
        public function __construct(string $file = '', string $openDelimiter = '{', string $closeDelimiter = '}') {}

        /**
         * @throws InvalidArgumentException
         */
        public function setFile(string $file): \void {}

        public function setVar(array $values, bool $merge = true): \void {}

        public function render(): string {}

        /**
         * @codeCoverageIgnore
         */
        public function renderTo(string $target): \void {}

    }
}

namespace SebastianBergmann\Timer
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Timer
{
    use LogicException;

    final class NoActiveTimerException extends \LogicException
    {
    }
}

namespace SebastianBergmann\Timer
{
    use RuntimeException;

    final class TimeSinceStartOfRequestNotAvailableException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Timer
{
    use floor;
    use sprintf;

    /**
     * @psalm-immutable
     */
    final class Duration
    {
        /**
         * @var float
         */
        private $nanoseconds;

        /**
         * @var int
         */
        private $hours;

        /**
         * @var int
         */
        private $minutes;

        /**
         * @var int
         */
        private $seconds;

        /**
         * @var int
         */
        private $milliseconds;

        public static function fromMicroseconds(float $microseconds): self {}

        public static function fromNanoseconds(float $nanoseconds): self {}

        private function __construct(float $nanoseconds) {}

        public function asNanoseconds(): float {}

        public function asMicroseconds(): float {}

        public function asMilliseconds(): float {}

        public function asSeconds(): float {}

        public function asString(): string {}

    }
}

namespace SebastianBergmann\Timer
{
    use is_float;
    use memory_get_peak_usage;
    use microtime;
    use sprintf;

    final class ResourceUsageFormatter
    {
        /**
         * @psalm-var array<string,int>
         */
        const SIZES = [/** value is missing */];

        public function resourceUsage(\SebastianBergmann\Timer\Duration $duration): string {}

        /**
         * @throws TimeSinceStartOfRequestNotAvailableException
         */
        public function resourceUsageSinceStartOfRequest(): string {}

        private function bytesToString(int $bytes): string {}

    }
}

namespace SebastianBergmann\Timer
{
    use array_pop;
    use hrtime;

    final class Timer
    {
        /**
         * @psalm-var list<float>
         */
        private $startTimes = [/** value is missing */];

        public function start(): \void {}

        /**
         * @throws NoActiveTimerException
         */
        public function stop(): \SebastianBergmann\Timer\Duration {}

    }
}

namespace SebastianBergmann\CliParser
{
    use sprintf;
    use RuntimeException;

    final class AmbiguousOptionException extends \RuntimeException
    {
        public function __construct(string $option) {}

    }
}

namespace SebastianBergmann\CliParser
{
    use Throwable;

    interface Exception
    {
    }
}

namespace SebastianBergmann\CliParser
{
    use sprintf;
    use RuntimeException;

    final class OptionDoesNotAllowArgumentException extends \RuntimeException
    {
        public function __construct(string $option) {}

    }
}

namespace SebastianBergmann\CliParser
{
    use sprintf;
    use RuntimeException;

    final class RequiredOptionArgumentMissingException extends \RuntimeException
    {
        public function __construct(string $option) {}

    }
}

namespace SebastianBergmann\CliParser
{
    use sprintf;
    use RuntimeException;

    final class UnknownOptionException extends \RuntimeException
    {
        public function __construct(string $option) {}

    }
}

namespace SebastianBergmann\CliParser
{
    use array_map;
    use array_merge;
    use array_shift;
    use array_slice;
    use assert;
    use count;
    use current;
    use explode;
    use is_array;
    use is_int;
    use is_string;
    use key;
    use next;
    use preg_replace;
    use reset;
    use sort;
    use strlen;
    use strpos;
    use strstr;
    use substr;

    final class Parser
    {
        /**
         * @psalm-param list<string> $argv
         * @psalm-param list<string> $longOptions
         *
         * @throws AmbiguousOptionException
         * @throws RequiredOptionArgumentMissingException
         * @throws OptionDoesNotAllowArgumentException
         * @throws UnknownOptionException
         */
        public function parse(array $argv, string $shortOptions, ?array $longOptions = null): array {}

        /**
         * @throws RequiredOptionArgumentMissingException
         */
        private function parseShortOption(string $arg, string $shortOptions, array &$opts, array &$args): \void {}

        /**
         * @psalm-param list<string> $longOptions
         *
         * @throws AmbiguousOptionException
         * @throws RequiredOptionArgumentMissingException
         * @throws OptionDoesNotAllowArgumentException
         * @throws UnknownOptionException
         */
        private function parseLongOption(string $arg, array $longOptions, array &$opts, array &$args): \void {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\CodeUnit
{
    use RuntimeException;

    final class InvalidCodeUnitException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeUnit
{
    use RuntimeException;

    final class NoTraitException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeUnit
{
    use RuntimeException;

    final class ReflectionException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class ClassMethodUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true ClassMethodUnit $this
         */
        public function isClassMethod(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class ClassUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true ClassUnit $this
         */
        public function isClass(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{
    use range;
    use sprintf;
    use ReflectionClass;
    use ReflectionFunction;
    use ReflectionMethod;

    /**
     * @psalm-immutable
     */
    abstract class CodeUnit
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var string
         */
        private $sourceFileName;

        /**
         * @var array
         * @psalm-var list<int>
         */
        private $sourceLines;

        /**
         * @psalm-param class-string $className
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forClass(string $className): \SebastianBergmann\CodeUnit\ClassUnit {}

        /**
         * @psalm-param class-string $className
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forClassMethod(string $className, string $methodName): \SebastianBergmann\CodeUnit\ClassMethodUnit {}

        /**
         * @psalm-param class-string $interfaceName
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forInterface(string $interfaceName): \SebastianBergmann\CodeUnit\InterfaceUnit {}

        /**
         * @psalm-param class-string $interfaceName
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forInterfaceMethod(string $interfaceName, string $methodName): \SebastianBergmann\CodeUnit\InterfaceMethodUnit {}

        /**
         * @psalm-param class-string $traitName
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forTrait(string $traitName): \SebastianBergmann\CodeUnit\TraitUnit {}

        /**
         * @psalm-param class-string $traitName
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forTraitMethod(string $traitName, string $methodName): \SebastianBergmann\CodeUnit\TraitMethodUnit {}

        /**
         * @psalm-param callable-string $functionName
         *
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public static function forFunction(string $functionName): \SebastianBergmann\CodeUnit\FunctionUnit {}

        /**
         * @psalm-param list<int> $sourceLines
         */
        private function __construct(string $name, string $sourceFileName, array $sourceLines) {}

        public function name(): string {}

        public function sourceFileName(): string {}

        /**
         * @psalm-return list<int>
         */
        public function sourceLines(): array {}

        public function isClass(): bool {}

        public function isClassMethod(): bool {}

        public function isInterface(): bool {}

        public function isInterfaceMethod(): bool {}

        public function isTrait(): bool {}

        public function isTraitMethod(): bool {}

        public function isFunction(): bool {}

        /**
         * @psalm-param class-string $className
         *
         * @throws InvalidCodeUnitException
         */
        private static function ensureUserDefinedClass(string $className): \void {}

        /**
         * @psalm-param class-string $interfaceName
         *
         * @throws InvalidCodeUnitException
         */
        private static function ensureUserDefinedInterface(string $interfaceName): \void {}

        /**
         * @psalm-param class-string $traitName
         *
         * @throws InvalidCodeUnitException
         */
        private static function ensureUserDefinedTrait(string $traitName): \void {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private static function reflectorForClass(string $className): \ReflectionClass {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private static function reflectorForClassMethod(string $className, string $methodName): \ReflectionMethod {}

        /**
         * @psalm-param callable-string $functionName
         *
         * @throws ReflectionException
         */
        private static function reflectorForFunction(string $functionName): \ReflectionFunction {}

    }
}

namespace SebastianBergmann\CodeUnit
{
    use array_merge;
    use count;
    use Countable;
    use IteratorAggregate;

    final class CodeUnitCollection
    {
        /**
         * @psalm-var list<CodeUnit>
         */
        private $codeUnits = [/** value is missing */];

        /**
         * @psalm-param list<CodeUnit> $items
         */
        public static function fromArray(array $items): self {}

        public static function fromList(\SebastianBergmann\CodeUnit\CodeUnit ...$items): self {}

        private function __construct() {}

        /**
         * @psalm-return list<CodeUnit>
         */
        public function asArray(): array {}

        public function getIterator(): \SebastianBergmann\CodeUnit\CodeUnitCollectionIterator {}

        public function count(): int {}

        public function isEmpty(): bool {}

        public function mergeWith(self $other): self {}

        private function add(\SebastianBergmann\CodeUnit\CodeUnit $item): \void {}

    }
}

namespace SebastianBergmann\CodeUnit
{
    use Iterator;

    final class CodeUnitCollectionIterator
    {
        /**
         * @psalm-var list<CodeUnit>
         */
        private $codeUnits;

        /**
         * @var int
         */
        private $position = 0;

        public function __construct(\SebastianBergmann\CodeUnit\CodeUnitCollection $collection) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \SebastianBergmann\CodeUnit\CodeUnit {}

        public function next(): \void {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class FunctionUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true FunctionUnit $this
         */
        public function isFunction(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class InterfaceMethodUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true InterfaceMethod $this
         */
        public function isInterfaceMethod(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class InterfaceUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true InterfaceUnit $this
         */
        public function isInterface(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{
    use array_keys;
    use array_merge;
    use array_unique;
    use array_values;
    use class_exists;
    use explode;
    use function_exists;
    use interface_exists;
    use ksort;
    use method_exists;
    use sort;
    use sprintf;
    use str_replace;
    use strpos;
    use trait_exists;
    use ReflectionClass;
    use ReflectionFunction;
    use ReflectionMethod;

    final class Mapper
    {
        /**
         * @psalm-return array<string,list<int>>
         */
        public function codeUnitsToSourceLines(\SebastianBergmann\CodeUnit\CodeUnitCollection $codeUnits): array {}

        /**
         * @throws InvalidCodeUnitException
         * @throws ReflectionException
         */
        public function stringToCodeUnits(string $unit): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function publicMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function publicAndProtectedMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function publicAndPrivateMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function protectedMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function protectedAndPrivateMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function privateMethodsOfClass(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function methodsOfClass(string $className, int $filter): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function classAndParentClassesAndTraits(string $className): \SebastianBergmann\CodeUnit\CodeUnitCollection {}

        /**
         * @psalm-param class-string $className
         *
         * @throws ReflectionException
         */
        private function reflectorForClass(string $className): \ReflectionClass {}

        /**
         * @throws ReflectionException
         */
        private function isUserDefinedFunction(string $functionName): bool {}

        /**
         * @throws ReflectionException
         */
        private function isUserDefinedClass(string $className): bool {}

        /**
         * @throws ReflectionException
         */
        private function isUserDefinedInterface(string $interfaceName): bool {}

        /**
         * @throws ReflectionException
         */
        private function isUserDefinedTrait(string $traitName): bool {}

        /**
         * @throws ReflectionException
         */
        private function isUserDefinedMethod(string $className, string $methodName): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class TraitMethodUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true TraitMethodUnit $this
         */
        public function isTraitMethod(): bool {}

    }
}

namespace SebastianBergmann\CodeUnit
{

    /**
     * @psalm-immutable
     */
    final class TraitUnit extends \SebastianBergmann\CodeUnit\CodeUnit
    {
        /**
         * @psalm-assert-if-true TraitUnit $this
         */
        public function isTrait(): bool {}

    }
}

namespace SebastianBergmann\CodeUnitReverseLookup
{
    use array_merge;
    use assert;
    use get_declared_classes;
    use get_declared_traits;
    use get_defined_functions;
    use is_array;
    use range;
    use ReflectionClass;
    use ReflectionFunction;
    use ReflectionFunctionAbstract;
    use ReflectionMethod;

    /**
     * @since Class available since Release 1.0.0
     */
    class Wizard
    {
        /**
         * @var array
         */
        private $lookupTable = [/** value is missing */];

        /**
         * @var array
         */
        private $processedClasses = [/** value is missing */];

        /**
         * @var array
         */
        private $processedFunctions = [/** value is missing */];

        /**
         * @param string $filename
         * @param int    $lineNumber
         *
         * @return string
         */
        public function lookup($filename, $lineNumber) {}

        private function updateLookupTable(): \void {}

        private function processClassesAndTraits(): \void {}

        private function processFunctions(): \void {}

        private function processFunctionOrMethod(\ReflectionFunctionAbstract $functionOrMethod): \void {}

    }
}

namespace SebastianBergmann\Comparator
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Comparator
{

    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Comparator
{
    use array_key_exists;
    use is_array;
    use sort;
    use sprintf;
    use str_replace;
    use trim;

    /**
     * Compares arrays for equality.
     *
     * Arrays are equal if they contain the same key-value pairs.
     * The order of the keys does not matter.
     * The types of key-value pairs do not matter.
     */
    class ArrayComparator extends \SebastianBergmann\Comparator\Comparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two arrays are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         * @param array $processed    List of already processed elements (used to prevent infinite recursion)
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

        protected function indent($lines) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use SebastianBergmann\Exporter\Exporter;

    /**
     * Abstract base class for comparators which compare values for equality.
     */
    abstract class Comparator
    {
        /**
         * @var Factory
         */
        protected $factory;

        /**
         * @var Exporter
         */
        protected $exporter;

        public function __construct() {}

        public function setFactory(\SebastianBergmann\Comparator\Factory $factory) {}

        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        abstract public function accepts($expected, $actual);

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        abstract public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false);

    }
}

namespace SebastianBergmann\Comparator
{
    use RuntimeException;
    use SebastianBergmann\Diff\Differ;
    use SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;

    /**
     * Thrown when an assertion for string equality failed.
     */
    class ComparisonFailure extends \RuntimeException
    {
        /**
         * Expected value of the retrieval which does not match $actual.
         *
         * @var mixed
         */
        protected $expected;

        /**
         * Actually retrieved value which does not match $expected.
         *
         * @var mixed
         */
        protected $actual;

        /**
         * The string representation of the expected value.
         *
         * @var string
         */
        protected $expectedAsString;

        /**
         * The string representation of the actual value.
         *
         * @var string
         */
        protected $actualAsString;

        /**
         * @var bool
         */
        protected $identical;

        /**
         * Optional message which is placed in front of the first line
         * returned by toString().
         *
         * @var string
         */
        protected $message;

        /**
         * Initialises with the expected value and the actual value.
         *
         * @param mixed  $expected         expected value retrieved
         * @param mixed  $actual           actual value retrieved
         * @param string $expectedAsString
         * @param string $actualAsString
         * @param bool   $identical
         * @param string $message          a string which is prefixed on all returned lines
         *                                 in the difference output
         */
        public function __construct($expected, $actual, $expectedAsString, $actualAsString, $identical = false, $message = '') {}

        public function getActual() {}

        public function getExpected() {}

        /**
         * @return string
         */
        public function getActualAsString() {}

        /**
         * @return string
         */
        public function getExpectedAsString() {}

        /**
         * @return string
         */
        public function getDiff() {}

        /**
         * @return string
         */
        public function toString() {}

    }
}

namespace SebastianBergmann\Comparator
{
    use sprintf;
    use strtolower;
    use DOMDocument;
    use DOMNode;
    use ValueError;

    /**
     * Compares DOMNode instances for equality.
     */
    class DOMNodeComparator extends \SebastianBergmann\Comparator\ObjectComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         * @param array $processed    List of already processed elements (used to prevent infinite recursion)
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

        /**
         * Returns the normalized, whitespace-cleaned, and indented textual
         * representation of a DOMNode.
         */
        private function nodeToText(\DOMNode $node, bool $canonicalize, bool $ignoreCase): string {}

    }
}

namespace SebastianBergmann\Comparator
{
    use abs;
    use floor;
    use sprintf;
    use DateInterval;
    use DateTime;
    use DateTimeInterface;
    use DateTimeZone;
    use Exception;

    /**
     * Compares DateTimeInterface instances for equality.
     */
    class DateTimeComparator extends \SebastianBergmann\Comparator\ObjectComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         * @param array $processed    List of already processed elements (used to prevent infinite recursion)
         *
         * @throws Exception
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

        /**
         * Returns an ISO 8601 formatted string representation of a datetime or
         * 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly
         * initialized.
         */
        private function dateTimeToString(\DateTimeInterface $datetime): string {}

    }
}

namespace SebastianBergmann\Comparator
{
    use is_float;
    use is_numeric;

    /**
     * Compares doubles for equality.
     */
    class DoubleComparator extends \SebastianBergmann\Comparator\NumericComparator
    {
        /**
         * Smallest value available in PHP.
         *
         * @var float
         */
        const EPSILON = 1.0E-10;

        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use Exception;

    /**
     * Compares Exception instances for equality.
     */
    class ExceptionComparator extends \SebastianBergmann\Comparator\ObjectComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Converts an object to an array containing all of its private, protected
         * and public properties.
         *
         * @param object $object
         *
         * @return array
         */
        protected function toArray($object) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use array_unshift;

    /**
     * Factory for comparators which compare values for equality.
     */
    class Factory
    {
        /**
         * @var Factory
         */
        private static $instance;

        /**
         * @var Comparator[]
         */
        private $customComparators = [/** value is missing */];

        /**
         * @var Comparator[]
         */
        private $defaultComparators = [/** value is missing */];

        /**
         * @return Factory
         */
        public static function getInstance() {}

        /**
         * Constructs a new factory.
         */
        public function __construct() {}

        /**
         * Returns the correct comparator for comparing two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return Comparator
         */
        public function getComparatorFor($expected, $actual) {}

        /**
         * Registers a new comparator.
         *
         * This comparator will be returned by getComparatorFor() if its accept() method
         * returns TRUE for the compared values. It has higher priority than the
         * existing comparators, meaning that its accept() method will be invoked
         * before those of the other comparators.
         *
         * @param Comparator $comparator The comparator to be registered
         */
        public function register(\SebastianBergmann\Comparator\Comparator $comparator) {}

        /**
         * Unregisters a comparator.
         *
         * This comparator will no longer be considered by getComparatorFor().
         *
         * @param Comparator $comparator The comparator to be unregistered
         */
        public function unregister(\SebastianBergmann\Comparator\Comparator $comparator) {}

        /**
         * Unregisters all non-default comparators.
         */
        public function reset() {}

        private function registerDefaultComparators(): \void {}

        private function registerDefaultComparator(\SebastianBergmann\Comparator\Comparator $comparator): \void {}

    }
}

namespace SebastianBergmann\Comparator
{
    use PHPUnit\Framework\MockObject\MockObject;

    /**
     * Compares PHPUnit\Framework\MockObject\MockObject instances for equality.
     */
    class MockObjectComparator extends \SebastianBergmann\Comparator\ObjectComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Converts an object to an array containing all of its private, protected
         * and public properties.
         *
         * @param object $object
         *
         * @return array
         */
        protected function toArray($object) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use abs;
    use is_float;
    use is_infinite;
    use is_nan;
    use is_numeric;
    use is_string;
    use sprintf;

    /**
     * Compares numerical values for equality.
     */
    class NumericComparator extends \SebastianBergmann\Comparator\ScalarComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

        private function isInfinite($value): bool {}

        private function isNan($value): bool {}

    }
}

namespace SebastianBergmann\Comparator
{
    use get_class;
    use in_array;
    use is_object;
    use sprintf;
    use substr_replace;

    /**
     * Compares objects for equality.
     */
    class ObjectComparator extends \SebastianBergmann\Comparator\ArrayComparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         * @param array $processed    List of already processed elements (used to prevent infinite recursion)
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false, array &$processed = [/** value is missing */]) {}

        /**
         * Converts an object to an array containing all of its private, protected
         * and public properties.
         *
         * @param object $object
         *
         * @return array
         */
        protected function toArray($object) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use is_resource;

    /**
     * Compares resources for equality.
     */
    class ResourceComparator extends \SebastianBergmann\Comparator\Comparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use is_object;
    use is_scalar;
    use is_string;
    use method_exists;
    use sprintf;
    use strtolower;

    /**
     * Compares scalar or NULL values for equality.
     */
    class ScalarComparator extends \SebastianBergmann\Comparator\Comparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         *
         * @since  Method available since Release 3.6.0
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use SplObjectStorage;

    /**
     * Compares \SplObjectStorage instances for equality.
     */
    class SplObjectStorageComparator extends \SebastianBergmann\Comparator\Comparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

    }
}

namespace SebastianBergmann\Comparator
{
    use gettype;
    use sprintf;

    /**
     * Compares values for type equality.
     */
    class TypeComparator extends \SebastianBergmann\Comparator\Comparator
    {
        /**
         * Returns whether the comparator can compare two values.
         *
         * @param mixed $expected The first value to compare
         * @param mixed $actual   The second value to compare
         *
         * @return bool
         */
        public function accepts($expected, $actual) {}

        /**
         * Asserts that two values are equal.
         *
         * @param mixed $expected     First value to compare
         * @param mixed $actual       Second value to compare
         * @param float $delta        Allowed numerical distance between two values to consider them equal
         * @param bool  $canonicalize Arrays are sorted before comparison when set to true
         * @param bool  $ignoreCase   Case is ignored when set to true
         *
         * @throws ComparisonFailure
         */
        public function assertEquals($expected, $actual, $delta = 0, $canonicalize = false, $ignoreCase = false) {}

    }
}

namespace SebastianBergmann\Complexity
{

    /**
     * @psalm-immutable
     */
    final class Complexity
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var int
         */
        private $cyclomaticComplexity;

        public function __construct(string $name, int $cyclomaticComplexity) {}

        public function name(): string {}

        public function cyclomaticComplexity(): int {}

    }
}

namespace SebastianBergmann\Complexity
{
    use count;
    use Countable;
    use IteratorAggregate;

    /**
     * @psalm-immutable
     */
    final class ComplexityCollection
    {
        /**
         * @psalm-var list<Complexity>
         */
        private $items = [/** value is missing */];

        public static function fromList(\SebastianBergmann\Complexity\Complexity ...$items): self {}

        /**
         * @psalm-param list<Complexity> $items
         */
        private function __construct(array $items) {}

        /**
         * @psalm-return list<Complexity>
         */
        public function asArray(): array {}

        public function getIterator(): \SebastianBergmann\Complexity\ComplexityCollectionIterator {}

        public function count(): int {}

        public function isEmpty(): bool {}

        public function cyclomaticComplexity(): int {}

    }
}

namespace SebastianBergmann\Complexity
{
    use Iterator;

    final class ComplexityCollectionIterator
    {
        /**
         * @psalm-var list<Complexity>
         */
        private $items;

        /**
         * @var int
         */
        private $position = 0;

        public function __construct(\SebastianBergmann\Complexity\ComplexityCollection $items) {}

        public function rewind(): \void {}

        public function valid(): bool {}

        public function key(): int {}

        public function current(): \SebastianBergmann\Complexity\Complexity {}

        public function next(): \void {}

    }
}

namespace SebastianBergmann\Complexity
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Complexity
{

    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Complexity
{
    use assert;
    use is_array;
    use PhpParser\Node;
    use PhpParser\Node\Name;
    use PhpParser\Node\Stmt;
    use PhpParser\Node\Stmt\Class_;
    use PhpParser\Node\Stmt\ClassMethod;
    use PhpParser\Node\Stmt\Function_;
    use PhpParser\Node\Stmt\Trait_;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitorAbstract;

    final class ComplexityCalculatingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @psalm-var list<Complexity>
         */
        private $result = [/** value is missing */];

        /**
         * @var bool
         */
        private $shortCircuitTraversal;

        public function __construct(bool $shortCircuitTraversal) {}

        public function enterNode(\PhpParser\Node $node): ?int {}

        public function result(): \SebastianBergmann\Complexity\ComplexityCollection {}

        /**
         * @param Stmt[] $statements
         */
        private function cyclomaticComplexity(array $statements): int {}

        private function classMethodName(\PhpParser\Node\Stmt\ClassMethod $node): string {}

        private function functionName(\PhpParser\Node\Stmt\Function_ $node): string {}

    }
}

namespace SebastianBergmann\Complexity
{
    use get_class;
    use PhpParser\Node;
    use PhpParser\Node\Expr\BinaryOp\BooleanAnd;
    use PhpParser\Node\Expr\BinaryOp\BooleanOr;
    use PhpParser\Node\Expr\BinaryOp\LogicalAnd;
    use PhpParser\Node\Expr\BinaryOp\LogicalOr;
    use PhpParser\Node\Expr\Ternary;
    use PhpParser\Node\Stmt\Case_;
    use PhpParser\Node\Stmt\Catch_;
    use PhpParser\Node\Stmt\ElseIf_;
    use PhpParser\Node\Stmt\For_;
    use PhpParser\Node\Stmt\Foreach_;
    use PhpParser\Node\Stmt\If_;
    use PhpParser\Node\Stmt\While_;
    use PhpParser\NodeVisitorAbstract;

    final class CyclomaticComplexityCalculatingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @var int
         */
        private $cyclomaticComplexity = 1;

        public function enterNode(\PhpParser\Node $node): \void {}

        public function cyclomaticComplexity(): int {}

    }
}

namespace SebastianBergmann\Complexity
{
    use PhpParser\Error;
    use PhpParser\Lexer;
    use PhpParser\Node;
    use PhpParser\NodeTraverser;
    use PhpParser\NodeVisitor\NameResolver;
    use PhpParser\NodeVisitor\ParentConnectingVisitor;
    use PhpParser\Parser;
    use PhpParser\ParserFactory;

    final class Calculator
    {
        /**
         * @throws RuntimeException
         */
        public function calculateForSourceFile(string $sourceFile): \SebastianBergmann\Complexity\ComplexityCollection {}

        /**
         * @throws RuntimeException
         */
        public function calculateForSourceString(string $source): \SebastianBergmann\Complexity\ComplexityCollection {}

        /**
         * @param Node[] $nodes
         *
         * @throws RuntimeException
         */
        public function calculateForAbstractSyntaxTree(array $nodes): \SebastianBergmann\Complexity\ComplexityCollection {}

        private function parser(): \PhpParser\Parser {}

    }
}

namespace SebastianBergmann\Diff
{
    use get_class;
    use gettype;
    use is_object;
    use sprintf;
    use Exception;

    final class ConfigurationException extends \SebastianBergmann\Diff\InvalidArgumentException
    {
        public function __construct(string $option, string $expected, $value, int $code = 0, ?\Exception $previous = null) {}

    }
}

namespace SebastianBergmann\Diff
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Diff
{

    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\Diff
{

    final class Chunk
    {
        /**
         * @var int
         */
        private $start;

        /**
         * @var int
         */
        private $startRange;

        /**
         * @var int
         */
        private $end;

        /**
         * @var int
         */
        private $endRange;

        /**
         * @var Line[]
         */
        private $lines;

        public function __construct(int $start = 0, int $startRange = 1, int $end = 0, int $endRange = 1, array $lines = [/** value is missing */]) {}

        public function getStart(): int {}

        public function getStartRange(): int {}

        public function getEnd(): int {}

        public function getEndRange(): int {}

        /**
         * @return Line[]
         */
        public function getLines(): array {}

        /**
         * @param Line[] $lines
         */
        public function setLines(array $lines): \void {}

    }
}

namespace SebastianBergmann\Diff
{

    final class Diff
    {
        /**
         * @var string
         */
        private $from;

        /**
         * @var string
         */
        private $to;

        /**
         * @var Chunk[]
         */
        private $chunks;

        /**
         * @param Chunk[] $chunks
         */
        public function __construct(string $from, string $to, array $chunks = [/** value is missing */]) {}

        public function getFrom(): string {}

        public function getTo(): string {}

        /**
         * @return Chunk[]
         */
        public function getChunks(): array {}

        /**
         * @param Chunk[] $chunks
         */
        public function setChunks(array $chunks): \void {}

    }
}

namespace SebastianBergmann\Diff
{
    use PHP_INT_SIZE;
    use PREG_SPLIT_DELIM_CAPTURE;
    use PREG_SPLIT_NO_EMPTY;
    use array_shift;
    use array_unshift;
    use array_values;
    use count;
    use current;
    use end;
    use get_class;
    use gettype;
    use is_array;
    use is_object;
    use is_string;
    use key;
    use min;
    use preg_split;
    use prev;
    use reset;
    use sprintf;
    use substr;
    use SebastianBergmann\Diff\Output\DiffOutputBuilderInterface;
    use SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;

    final class Differ
    {
        const OLD = 0;

        const ADDED = 1;

        const REMOVED = 2;

        const DIFF_LINE_END_WARNING = 3;

        const NO_LINE_END_EOF_WARNING = 4;

        /**
         * @var DiffOutputBuilderInterface
         */
        private $outputBuilder;

        /**
         * @param DiffOutputBuilderInterface $outputBuilder
         *
         * @throws InvalidArgumentException
         */
        public function __construct($outputBuilder = null) {}

        /**
         * Returns the diff between two arrays or strings as string.
         *
         * @param array|string $from
         * @param array|string $to
         */
        public function diff($from, $to, ?\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator $lcs = null): string {}

        /**
         * Returns the diff between two arrays or strings as array.
         *
         * Each array element contains two elements:
         *   - [0] => mixed $token
         *   - [1] => 2|1|0
         *
         * - 2: REMOVED: $token was removed from $from
         * - 1: ADDED: $token was added to $from
         * - 0: OLD: $token is not changed in $to
         *
         * @param array|string                       $from
         * @param array|string                       $to
         * @param LongestCommonSubsequenceCalculator $lcs
         */
        public function diffToArray($from, $to, ?\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator $lcs = null): array {}

        /**
         * Casts variable to string if it is not a string or array.
         *
         * @return array|string
         */
        private function normalizeDiffInput($input) {}

        /**
         * Checks if input is string, if so it will split it line-by-line.
         */
        private function splitStringByLines(string $input): array {}

        private function selectLcsImplementation(array $from, array $to): \SebastianBergmann\Diff\LongestCommonSubsequenceCalculator {}

        /**
         * Calculates the estimated memory footprint for the DP-based method.
         *
         * @return float|int
         */
        private function calculateEstimatedFootprint(array $from, array $to) {}

        /**
         * Returns true if line ends don't match in a diff.
         */
        private function detectUnmatchedLineEndings(array $diff): bool {}

        private function getLinebreak($line): string {}

        private static function getArrayDiffParted(array &$from, array &$to): array {}

    }
}

namespace SebastianBergmann\Diff
{

    final class Line
    {
        const ADDED = 1;

        const REMOVED = 2;

        const UNCHANGED = 3;

        /**
         * @var int
         */
        private $type;

        /**
         * @var string
         */
        private $content;

        public function __construct(int $type = self::UNCHANGED, string $content = '') {}

        public function getContent(): string {}

        public function getType(): int {}

    }
}

namespace SebastianBergmann\Diff
{

    interface LongestCommonSubsequenceCalculator
    {
        /**
         * Calculates the longest common subsequence of two arrays.
         */
        public function calculate(array $from, array $to): array;

    }
}

namespace SebastianBergmann\Diff
{
    use array_fill;
    use array_merge;
    use array_reverse;
    use array_slice;
    use count;
    use in_array;
    use max;

    final class MemoryEfficientLongestCommonSubsequenceCalculator implements \SebastianBergmann\Diff\LongestCommonSubsequenceCalculator
    {
        /**
         * {@inheritdoc}
         */
        public function calculate(array $from, array $to): array {}

        private function length(array $from, array $to): array {}

    }
}

namespace SebastianBergmann\Diff
{
    use array_pop;
    use count;
    use max;
    use preg_match;
    use preg_split;

    /**
     * Unified diff parser.
     */
    final class Parser
    {
        /**
         * @return Diff[]
         */
        public function parse(string $string): array {}

        private function parseFileDiff(\SebastianBergmann\Diff\Diff $diff, array $lines): \void {}

    }
}

namespace SebastianBergmann\Diff
{
    use array_reverse;
    use count;
    use max;
    use SplFixedArray;

    final class TimeEfficientLongestCommonSubsequenceCalculator implements \SebastianBergmann\Diff\LongestCommonSubsequenceCalculator
    {
        /**
         * {@inheritdoc}
         */
        public function calculate(array $from, array $to): array {}

    }
}

namespace SebastianBergmann\Diff\Output
{
    use count;

    abstract class AbstractChunkOutputBuilder implements \SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
    {
        /**
         * Takes input of the diff array and returns the common parts.
         * Iterates through diff line by line.
         */
        protected function getCommonChunks(array $diff, int $lineThreshold = 5): array {}

    }
}

namespace SebastianBergmann\Diff\Output
{
    use fclose;
    use fopen;
    use fwrite;
    use stream_get_contents;
    use substr;
    use SebastianBergmann\Diff\Differ;

    /**
     * Builds a diff string representation in a loose unified diff format
     * listing only changes lines. Does not include line numbers.
     */
    final class DiffOnlyOutputBuilder implements \SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
    {
        /**
         * @var string
         */
        private $header;

        public function __construct(string $header = '--- Original
+++ New
') {}

        public function getDiff(array $diff): string {}

    }
}

namespace SebastianBergmann\Diff\Output
{

    /**
     * Defines how an output builder should take a generated
     * diff array and return a string representation of that diff.
     */
    interface DiffOutputBuilderInterface
    {
        public function getDiff(array $diff): string;

    }
}

namespace SebastianBergmann\Diff\Output
{
    use array_merge;
    use array_splice;
    use count;
    use fclose;
    use fopen;
    use fwrite;
    use is_bool;
    use is_int;
    use is_string;
    use max;
    use min;
    use sprintf;
    use stream_get_contents;
    use substr;
    use SebastianBergmann\Diff\ConfigurationException;
    use SebastianBergmann\Diff\Differ;

    /**
     * Strict Unified diff output builder.
     *
     * Generates (strict) Unified diff's (unidiffs) with hunks.
     */
    final class StrictUnifiedDiffOutputBuilder implements \SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
    {
        private static $default = [/** value is missing */];

        /**
         * @var bool
         */
        private $changed;

        /**
         * @var bool
         */
        private $collapseRanges;

        /**
         * @var int >= 0
         */
        private $commonLineThreshold;

        /**
         * @var string
         */
        private $header;

        /**
         * @var int >= 0
         */
        private $contextLines;

        public function __construct(array $options = [/** value is missing */]) {}

        public function getDiff(array $diff): string {}

        private function writeDiffHunks($output, array $diff): \void {}

        private function writeHunk(array $diff, int $diffStartIndex, int $diffEndIndex, int $fromStart, int $fromRange, int $toStart, int $toRange, $output): \void {}

        private function assertString(array $options, string $option): \void {}

        private function assertStringOrNull(array $options, string $option): \void {}

    }
}

namespace SebastianBergmann\Diff\Output
{
    use array_splice;
    use count;
    use fclose;
    use fopen;
    use fwrite;
    use max;
    use min;
    use stream_get_contents;
    use strlen;
    use substr;
    use SebastianBergmann\Diff\Differ;

    /**
     * Builds a diff string representation in unified diff format in chunks.
     */
    final class UnifiedDiffOutputBuilder extends \SebastianBergmann\Diff\Output\AbstractChunkOutputBuilder
    {
        /**
         * @var bool
         */
        private $collapseRanges = true;

        /**
         * @var int >= 0
         */
        private $commonLineThreshold = 6;

        /**
         * @var int >= 0
         */
        private $contextLines = 3;

        /**
         * @var string
         */
        private $header;

        /**
         * @var bool
         */
        private $addLineNumbers;

        public function __construct(string $header = '--- Original
+++ New
', bool $addLineNumbers = false) {}

        public function getDiff(array $diff): string {}

        private function writeDiffHunks($output, array $diff): \void {}

        private function writeHunk(array $diff, int $diffStartIndex, int $diffEndIndex, int $fromStart, int $fromRange, int $toStart, int $toRange, $output): \void {}

    }
}

namespace SebastianBergmann\Environment
{
    use DIRECTORY_SEPARATOR;
    use STDIN;
    use STDOUT;
    use defined;
    use fclose;
    use fstat;
    use function_exists;
    use getenv;
    use is_resource;
    use is_string;
    use posix_isatty;
    use preg_match;
    use proc_close;
    use proc_open;
    use sapi_windows_vt100_support;
    use shell_exec;
    use stream_get_contents;
    use stream_isatty;
    use trim;

    final class Console
    {
        /**
         * @var int
         */
        const STDIN = 0;

        /**
         * @var int
         */
        const STDOUT = 1;

        /**
         * @var int
         */
        const STDERR = 2;

        /**
         * Returns true if STDOUT supports colorization.
         *
         * This code has been copied and adapted from
         * Symfony\Component\Console\Output\StreamOutput.
         */
        public function hasColorSupport(): bool {}

        /**
         * Returns the number of columns of the terminal.
         *
         * @codeCoverageIgnore
         */
        public function getNumberOfColumns(): int {}

        /**
         * Returns if the file descriptor is an interactive terminal or not.
         *
         * Normally, we want to use a resource as a parameter, yet sadly it's not always awailable,
         * eg when running code in interactive console (`php -a`), STDIN/STDOUT/STDERR constants are not defined.
         *
         * @param int|resource $fileDescriptor
         */
        public function isInteractive($fileDescriptor = self::STDOUT): bool {}

        private function isWindows(): bool {}

        /**
         * @codeCoverageIgnore
         */
        private function getNumberOfColumnsInteractive(): int {}

        /**
         * @codeCoverageIgnore
         */
        private function getNumberOfColumnsWindows(): int {}

    }
}

namespace SebastianBergmann\Environment
{
    use DIRECTORY_SEPARATOR;
    use PHP_OS;
    use PHP_OS_FAMILY;
    use defined;

    final class OperatingSystem
    {
        /**
         * Returns PHP_OS_FAMILY (if defined (which it is on PHP >= 7.2)).
         * Returns a string (compatible with PHP_OS_FAMILY) derived from PHP_OS otherwise.
         */
        public function getFamily(): string {}

    }
}

namespace SebastianBergmann\Environment
{
    use PHP_BINARY;
    use PHP_BINDIR;
    use PHP_MAJOR_VERSION;
    use PHP_SAPI;
    use PHP_VERSION;
    use array_map;
    use array_merge;
    use defined;
    use escapeshellarg;
    use explode;
    use extension_loaded;
    use getenv;
    use ini_get;
    use is_readable;
    use parse_ini_file;
    use php_ini_loaded_file;
    use php_ini_scanned_files;
    use phpversion;
    use sprintf;
    use strpos;

    /**
     * Utility class for HHVM/PHP environment handling.
     */
    final class Runtime
    {
        /**
         * @var string
         */
        private static $binary;

        /**
         * Returns true when Xdebug or PCOV is available or
         * the runtime used is PHPDBG.
         */
        public function canCollectCodeCoverage(): bool {}

        /**
         * Returns true when Zend OPcache is loaded, enabled,
         * and is configured to discard comments.
         */
        public function discardsComments(): bool {}

        /**
         * Returns true when Zend OPcache is loaded, enabled,
         * and is configured to perform just-in-time compilation.
         */
        public function performsJustInTimeCompilation(): bool {}

        /**
         * Returns the path to the binary of the current runtime.
         * Appends ' --php' to the path when the runtime is HHVM.
         */
        public function getBinary(): string {}

        public function getNameWithVersion(): string {}

        public function getNameWithVersionAndCodeCoverageDriver(): string {}

        public function getName(): string {}

        public function getVendorUrl(): string {}

        public function getVersion(): string {}

        /**
         * Returns true when the runtime used is PHP and Xdebug is loaded.
         */
        public function hasXdebug(): bool {}

        /**
         * Returns true when the runtime used is HHVM.
         */
        public function isHHVM(): bool {}

        /**
         * Returns true when the runtime used is PHP without the PHPDBG SAPI.
         */
        public function isPHP(): bool {}

        /**
         * Returns true when the runtime used is PHP with the PHPDBG SAPI.
         */
        public function isPHPDBG(): bool {}

        /**
         * Returns true when the runtime used is PHP with the PHPDBG SAPI
         * and the phpdbg_*_oplog() functions are available (PHP >= 7.0).
         */
        public function hasPHPDBGCodeCoverage(): bool {}

        /**
         * Returns true when the runtime used is PHP with PCOV loaded and enabled.
         */
        public function hasPCOV(): bool {}

        /**
         * Parses the loaded php.ini file (if any) as well as all
         * additional php.ini files from the additional ini dir for
         * a list of all configuration settings loaded from files
         * at startup. Then checks for each php.ini setting passed
         * via the `$values` parameter whether this setting has
         * been changed at runtime. Returns an array of strings
         * where each string has the format `key=value` denoting
         * the name of a changed php.ini setting with its new value.
         *
         * @return string[]
         */
        public function getCurrentSettings(array $values): array {}

        private function isOpcacheActive(): bool {}

    }
}

namespace SebastianBergmann\Exporter
{
    use bin2hex;
    use count;
    use function_exists;
    use get_class;
    use get_resource_type;
    use implode;
    use is_array;
    use is_float;
    use is_object;
    use is_resource;
    use is_string;
    use mb_strlen;
    use mb_substr;
    use preg_match;
    use spl_object_hash;
    use sprintf;
    use str_repeat;
    use str_replace;
    use strlen;
    use substr;
    use var_export;
    use SebastianBergmann\RecursionContext\Context;
    use SplObjectStorage;

    /**
     * A nifty utility for visualizing PHP variables.
     *
     * <code>
     * <?php
     * use SebastianBergmann\Exporter\Exporter;
     *
     * $exporter = new Exporter;
     * print $exporter->export(new Exception);
     * </code>
     */
    class Exporter
    {
        /**
         * Exports a value as a string.
         *
         * The output of this method is similar to the output of print_r(), but
         * improved in various aspects:
         *
         *  - NULL is rendered as "null" (instead of "")
         *  - TRUE is rendered as "true" (instead of "1")
         *  - FALSE is rendered as "false" (instead of "")
         *  - Strings are always quoted with single quotes
         *  - Carriage returns and newlines are normalized to \n
         *  - Recursion and repeated rendering is treated properly
         *
         * @param int $indentation The indentation level of the 2nd+ line
         *
         * @return string
         */
        public function export($value, $indentation = 0) {}

        /**
         * @param array<mixed> $data
         * @param Context      $context
         *
         * @return string
         */
        public function shortenedRecursiveExport(&$data, ?\SebastianBergmann\RecursionContext\Context $context = null) {}

        /**
         * Exports a value into a single-line string.
         *
         * The output of this method is similar to the output of
         * SebastianBergmann\Exporter\Exporter::export().
         *
         * Newlines are replaced by the visible string '\n'.
         * Contents of arrays and objects (if any) are replaced by '...'.
         *
         * @return string
         *
         * @see    SebastianBergmann\Exporter\Exporter::export
         */
        public function shortenedExport($value) {}

        /**
         * Converts an object to an array containing all of its private, protected
         * and public properties.
         *
         * @return array
         */
        public function toArray($value) {}

        /**
         * Recursive implementation of export.
         *
         * @param mixed                                       $value       The value to export
         * @param int                                         $indentation The indentation level of the 2nd+ line
         * @param \SebastianBergmann\RecursionContext\Context $processed   Previously processed objects
         *
         * @return string
         *
         * @see    SebastianBergmann\Exporter\Exporter::export
         */
        protected function recursiveExport(&$value, $indentation, $processed = null) {}

    }
}

namespace SebastianBergmann\GlobalState
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\GlobalState
{

    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\GlobalState
{
    use PHP_EOL;
    use is_array;
    use is_scalar;
    use serialize;
    use sprintf;
    use var_export;

    /**
     * Exports parts of a Snapshot as PHP code.
     */
    final class CodeExporter
    {
        public function constants(\SebastianBergmann\GlobalState\Snapshot $snapshot): string {}

        public function globalVariables(\SebastianBergmann\GlobalState\Snapshot $snapshot): string {}

        public function iniSettings(\SebastianBergmann\GlobalState\Snapshot $snapshot): string {}

        private function exportVariable($variable): string {}

        private function arrayOnlyContainsScalars(array $array): bool {}

    }
}

namespace SebastianBergmann\GlobalState
{
    use in_array;
    use strpos;
    use ReflectionClass;

    final class ExcludeList
    {
        /**
         * @var array
         */
        private $globalVariables = [/** value is missing */];

        /**
         * @var string[]
         */
        private $classes = [/** value is missing */];

        /**
         * @var string[]
         */
        private $classNamePrefixes = [/** value is missing */];

        /**
         * @var string[]
         */
        private $parentClasses = [/** value is missing */];

        /**
         * @var string[]
         */
        private $interfaces = [/** value is missing */];

        /**
         * @var array
         */
        private $staticAttributes = [/** value is missing */];

        public function addGlobalVariable(string $variableName): \void {}

        public function addClass(string $className): \void {}

        public function addSubclassesOf(string $className): \void {}

        public function addImplementorsOf(string $interfaceName): \void {}

        public function addClassNamePrefix(string $classNamePrefix): \void {}

        public function addStaticAttribute(string $className, string $attributeName): \void {}

        public function isGlobalVariableExcluded(string $variableName): bool {}

        public function isStaticAttributeExcluded(string $className, string $attributeName): bool {}

    }
}

namespace SebastianBergmann\GlobalState
{
    use array_diff;
    use array_key_exists;
    use array_keys;
    use array_merge;
    use function_exists;
    use get_defined_functions;
    use in_array;
    use is_array;
    use ReflectionClass;
    use ReflectionProperty;

    /**
     * Restorer of snapshots of global state.
     */
    class Restorer
    {
        /**
         * Deletes function definitions that are not defined in a snapshot.
         *
         * @throws RuntimeException when the uopz_delete() function is not available
         *
         * @see https://github.com/krakjoe/uopz
         */
        public function restoreFunctions(\SebastianBergmann\GlobalState\Snapshot $snapshot): \void {}

        /**
         * Restores all global and super-global variables from a snapshot.
         */
        public function restoreGlobalVariables(\SebastianBergmann\GlobalState\Snapshot $snapshot): \void {}

        /**
         * Restores all static attributes in user-defined classes from this snapshot.
         */
        public function restoreStaticAttributes(\SebastianBergmann\GlobalState\Snapshot $snapshot): \void {}

        /**
         * Restores a super-global variable array from this snapshot.
         */
        private function restoreSuperGlobalArray(\SebastianBergmann\GlobalState\Snapshot $snapshot, string $superGlobalArray): \void {}

    }
}

namespace SebastianBergmann\GlobalState
{
    use array_keys;
    use array_merge;
    use array_reverse;
    use func_get_args;
    use get_declared_classes;
    use get_declared_interfaces;
    use get_declared_traits;
    use get_defined_constants;
    use get_defined_functions;
    use get_included_files;
    use in_array;
    use ini_get_all;
    use is_array;
    use is_object;
    use is_resource;
    use is_scalar;
    use serialize;
    use unserialize;
    use ReflectionClass;
    use SebastianBergmann\ObjectReflector\ObjectReflector;
    use SebastianBergmann\RecursionContext\Context;
    use Throwable;

    /**
     * A snapshot of global state.
     */
    class Snapshot
    {
        /**
         * @var ExcludeList
         */
        private $excludeList;

        /**
         * @var array
         */
        private $globalVariables = [/** value is missing */];

        /**
         * @var array
         */
        private $superGlobalArrays = [/** value is missing */];

        /**
         * @var array
         */
        private $superGlobalVariables = [/** value is missing */];

        /**
         * @var array
         */
        private $staticAttributes = [/** value is missing */];

        /**
         * @var array
         */
        private $iniSettings = [/** value is missing */];

        /**
         * @var array
         */
        private $includedFiles = [/** value is missing */];

        /**
         * @var array
         */
        private $constants = [/** value is missing */];

        /**
         * @var array
         */
        private $functions = [/** value is missing */];

        /**
         * @var array
         */
        private $interfaces = [/** value is missing */];

        /**
         * @var array
         */
        private $classes = [/** value is missing */];

        /**
         * @var array
         */
        private $traits = [/** value is missing */];

        /**
         * Creates a snapshot of the current global state.
         */
        public function __construct(?\SebastianBergmann\GlobalState\ExcludeList $excludeList = null, bool $includeGlobalVariables = true, bool $includeStaticAttributes = true, bool $includeConstants = true, bool $includeFunctions = true, bool $includeClasses = true, bool $includeInterfaces = true, bool $includeTraits = true, bool $includeIniSettings = true, bool $includeIncludedFiles = true) {}

        public function excludeList(): \SebastianBergmann\GlobalState\ExcludeList {}

        public function globalVariables(): array {}

        public function superGlobalVariables(): array {}

        public function superGlobalArrays(): array {}

        public function staticAttributes(): array {}

        public function iniSettings(): array {}

        public function includedFiles(): array {}

        public function constants(): array {}

        public function functions(): array {}

        public function interfaces(): array {}

        public function classes(): array {}

        public function traits(): array {}

        /**
         * Creates a snapshot user-defined constants.
         */
        private function snapshotConstants(): \void {}

        /**
         * Creates a snapshot user-defined functions.
         */
        private function snapshotFunctions(): \void {}

        /**
         * Creates a snapshot user-defined classes.
         */
        private function snapshotClasses(): \void {}

        /**
         * Creates a snapshot user-defined interfaces.
         */
        private function snapshotInterfaces(): \void {}

        /**
         * Creates a snapshot of all global and super-global variables.
         */
        private function snapshotGlobals(): \void {}

        /**
         * Creates a snapshot a super-global variable array.
         */
        private function snapshotSuperGlobalArray(string $superGlobalArray): \void {}

        /**
         * Creates a snapshot of all static attributes in user-defined classes.
         */
        private function snapshotStaticAttributes(): \void {}

        /**
         * Returns a list of all super-global variable arrays.
         */
        private function setupSuperGlobalArrays(): \void {}

        private function canBeSerialized($variable): bool {}

        private function enumerateObjectsAndResources($variable): array {}

    }
}

namespace SebastianBergmann\LinesOfCode
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\LinesOfCode
{
    use LogicException;

    final class IllogicalValuesException extends \LogicException
    {
    }
}

namespace SebastianBergmann\LinesOfCode
{
    use InvalidArgumentException;

    final class NegativeValueException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\LinesOfCode
{

    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\LinesOfCode
{
    use substr_count;
    use PhpParser\Error;
    use PhpParser\Lexer;
    use PhpParser\Node;
    use PhpParser\NodeTraverser;
    use PhpParser\Parser;
    use PhpParser\ParserFactory;

    final class Counter
    {
        /**
         * @throws RuntimeException
         */
        public function countInSourceFile(string $sourceFile): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        /**
         * @throws RuntimeException
         */
        public function countInSourceString(string $source): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        /**
         * @param Node[] $nodes
         *
         * @throws RuntimeException
         */
        public function countInAbstractSyntaxTree(int $linesOfCode, array $nodes): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        private function parser(): \PhpParser\Parser {}

    }
}

namespace SebastianBergmann\LinesOfCode
{
    use array_merge;
    use array_unique;
    use count;
    use PhpParser\Comment;
    use PhpParser\Node;
    use PhpParser\NodeVisitorAbstract;

    final class LineCountingVisitor extends \PhpParser\NodeVisitorAbstract
    {
        /**
         * @var int
         */
        private $linesOfCode;

        /**
         * @var Comment[]
         */
        private $comments = [/** value is missing */];

        /**
         * @var int[]
         */
        private $linesWithStatements = [/** value is missing */];

        public function __construct(int $linesOfCode) {}

        public function enterNode(\PhpParser\Node $node): \void {}

        public function result(): \SebastianBergmann\LinesOfCode\LinesOfCode {}

        /**
         * @return Comment[]
         */
        private function comments(): array {}

    }
}

namespace SebastianBergmann\LinesOfCode
{

    /**
     * @psalm-immutable
     */
    final class LinesOfCode
    {
        /**
         * @var int
         */
        private $linesOfCode;

        /**
         * @var int
         */
        private $commentLinesOfCode;

        /**
         * @var int
         */
        private $nonCommentLinesOfCode;

        /**
         * @var int
         */
        private $logicalLinesOfCode;

        /**
         * @throws IllogicalValuesException
         * @throws NegativeValueException
         */
        public function __construct(int $linesOfCode, int $commentLinesOfCode, int $nonCommentLinesOfCode, int $logicalLinesOfCode) {}

        public function linesOfCode(): int {}

        public function commentLinesOfCode(): int {}

        public function nonCommentLinesOfCode(): int {}

        public function logicalLinesOfCode(): int {}

        public function plus(self $other): self {}

    }
}

namespace SebastianBergmann\ObjectEnumerator
{
    use array_merge;
    use func_get_args;
    use is_array;
    use is_object;
    use SebastianBergmann\ObjectReflector\ObjectReflector;
    use SebastianBergmann\RecursionContext\Context;

    /**
     * Traverses array structures and object graphs
     * to enumerate all referenced objects.
     */
    class Enumerator
    {
        /**
         * Returns an array of all objects referenced either
         * directly or indirectly by a variable.
         *
         * @param array|object $variable
         *
         * @return object[]
         */
        public function enumerate($variable) {}

    }
}

namespace SebastianBergmann\ObjectEnumerator
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\ObjectEnumerator
{

    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\ObjectReflector
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\ObjectReflector
{

    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\ObjectReflector
{
    use count;
    use explode;
    use get_class;
    use is_object;

    class ObjectReflector
    {
        /**
         * @param object $object
         *
         * @throws InvalidArgumentException
         */
        public function getAttributes($object): array {}

    }
}

namespace SebastianBergmann\RecursionContext
{
    use PHP_INT_MAX;
    use PHP_INT_MIN;
    use array_pop;
    use array_slice;
    use count;
    use is_array;
    use is_object;
    use random_int;
    use spl_object_hash;
    use SplObjectStorage;

    /**
     * A context containing previously processed arrays and objects
     * when recursively processing a value.
     */
    final class Context
    {
        /**
         * @var array[]
         */
        private $arrays;

        /**
         * @var SplObjectStorage
         */
        private $objects;

        /**
         * Initialises the context.
         */
        public function __construct() {}

        /**
         * @codeCoverageIgnore
         */
        public function __destruct() {}

        /**
         * Adds a value to the context.
         *
         * @param array|object $value the value to add
         *
         * @throws InvalidArgumentException Thrown if $value is not an array or object
         *
         * @return bool|int|string the ID of the stored value, either as a string or integer
         *
         * @psalm-template T
         * @psalm-param T $value
         * @param-out T $value
         */
        public function add(&$value) {}

        /**
         * Checks if the given value exists within the context.
         *
         * @param array|object $value the value to check
         *
         * @throws InvalidArgumentException Thrown if $value is not an array or object
         *
         * @return false|int|string the string or integer ID of the stored value if it has already been seen, or false if the value is not stored
         *
         * @psalm-template T
         * @psalm-param T $value
         * @param-out T $value
         */
        public function contains(&$value) {}

        /**
         * @return bool|int
         */
        private function addArray(array &$array) {}

        /**
         * @param object $object
         */
        private function addObject($object): string {}

        /**
         * @return false|int
         */
        private function containsArray(array &$array) {}

        /**
         * @param object $value
         *
         * @return false|string
         */
        private function containsObject($value) {}

    }
}

namespace SebastianBergmann\RecursionContext
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\RecursionContext
{

    final class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}

namespace SebastianBergmann\ResourceOperations
{

    final class ResourceOperations
    {
        /**
         * @return string[]
         */
        public static function getFunctions(): array {}

    }
}

namespace SebastianBergmann\Type
{

    interface Exception
    {
    }
}

namespace SebastianBergmann\Type
{

    final class RuntimeException extends \RuntimeException
    {
    }
}

namespace SebastianBergmann\Type
{
    use assert;
    use class_exists;
    use count;
    use explode;
    use function_exists;
    use is_array;
    use is_object;
    use is_string;
    use strpos;
    use Closure;
    use ReflectionClass;
    use ReflectionException;
    use ReflectionObject;

    final class CallableType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var bool
         */
        private $allowsNull;

        public function __construct(bool $nullable) {}

        /**
         * @throws RuntimeException
         */
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

        private function isClosure(\SebastianBergmann\Type\ObjectType $type): bool {}

        /**
         * @throws RuntimeException
         */
        private function hasInvokeMethod(\SebastianBergmann\Type\ObjectType $type): bool {}

        private function isFunction(\SebastianBergmann\Type\SimpleType $type): bool {}

        private function isObjectCallback(\SebastianBergmann\Type\SimpleType $type): bool {}

        private function isClassCallback(\SebastianBergmann\Type\SimpleType $type): bool {}

    }
}

namespace SebastianBergmann\Type
{

    final class GenericObjectType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var bool
         */
        private $allowsNull;

        public function __construct(bool $nullable) {}

        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{
    use assert;
    use class_exists;
    use is_iterable;
    use ReflectionClass;
    use ReflectionException;

    final class IterableType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var bool
         */
        private $allowsNull;

        public function __construct(bool $nullable) {}

        /**
         * @throws RuntimeException
         */
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{

    final class MixedType extends \SebastianBergmann\Type\Type
    {
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function asString(): string {}

        public function name(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{

    final class NullType extends \SebastianBergmann\Type\Type
    {
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function asString(): string {}

        /**
         * @deprecated
         *
         * @codeCoverageIgnore
         */
        public function getReturnTypeDeclaration(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{
    use is_subclass_of;
    use strcasecmp;

    final class ObjectType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var TypeName
         */
        private $className;

        /**
         * @var bool
         */
        private $allowsNull;

        public function __construct(\SebastianBergmann\Type\TypeName $className, bool $allowsNull) {}

        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

        public function className(): \SebastianBergmann\Type\TypeName {}

    }
}

namespace SebastianBergmann\Type
{
    use assert;
    use sprintf;
    use ReflectionMethod;
    use ReflectionNamedType;
    use ReflectionUnionType;

    final class ReflectionMapper
    {
        public function fromMethodReturnType(\ReflectionMethod $method): \SebastianBergmann\Type\Type {}

    }
}

namespace SebastianBergmann\Type
{
    use strtolower;

    final class SimpleType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var string
         */
        private $name;

        /**
         * @var bool
         */
        private $allowsNull;

        /**
         * @var mixed
         */
        private $value;

        public function __construct(string $name, bool $nullable, $value = null) {}

        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

        public function value() {}

        private function normalize(string $name): string {}

    }
}

namespace SebastianBergmann\Type
{

    final class StaticType extends \SebastianBergmann\Type\Type
    {
        /**
         * @var TypeName
         */
        private $className;

        /**
         * @var bool
         */
        private $allowsNull;

        public function __construct(\SebastianBergmann\Type\TypeName $className, bool $allowsNull) {}

        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{
    use get_class;
    use gettype;
    use strtolower;

    abstract class Type
    {
        public static function fromValue($value, bool $allowsNull): self {}

        public static function fromName(string $typeName, bool $allowsNull): self {}

        public function asString(): string {}

        /**
         * @deprecated
         *
         * @codeCoverageIgnore
         */
        public function getReturnTypeDeclaration(): string {}

        abstract public function isAssignable(\SebastianBergmann\Type\Type $other): bool;

        abstract public function name(): string;

        abstract public function allowsNull(): bool;

    }
}

namespace SebastianBergmann\Type
{
    use array_pop;
    use explode;
    use implode;
    use substr;
    use ReflectionClass;

    final class TypeName
    {
        /**
         * @var ?string
         */
        private $namespaceName;

        /**
         * @var string
         */
        private $simpleName;

        public static function fromQualifiedName(string $fullClassName): self {}

        public static function fromReflection(\ReflectionClass $type): self {}

        public function __construct(?string $namespaceName, string $simpleName) {}

        public function namespaceName(): ?string {}

        public function simpleName(): string {}

        public function qualifiedName(): string {}

        /**
         * @deprecated Use namespaceName() instead
         *
         * @codeCoverageIgnore
         */
        public function getNamespaceName(): ?string {}

        /**
         * @deprecated Use simpleName() instead
         *
         * @codeCoverageIgnore
         */
        public function getSimpleName(): string {}

        /**
         * @deprecated Use qualifiedName() instead
         *
         * @codeCoverageIgnore
         */
        public function getQualifiedName(): string {}

        public function isNamespaced(): bool {}

    }
}

namespace SebastianBergmann\Type
{
    use count;
    use implode;
    use sort;

    final class UnionType extends \SebastianBergmann\Type\Type
    {
        /**
         * @psalm-var list<Type>
         */
        private $types;

        /**
         * @throws RuntimeException
         */
        public function __construct(\SebastianBergmann\Type\Type ...$types) {}

        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function asString(): string {}

        /**
         * @deprecated
         *
         * @codeCoverageIgnore
         */
        public function getReturnTypeDeclaration(): string {}

        public function name(): string {}

        public function allowsNull(): bool {}

        /**
         * @throws RuntimeException
         */
        private function ensureMinimumOfTwoTypes(\SebastianBergmann\Type\Type ...$types): \void {}

        /**
         * @throws RuntimeException
         */
        private function ensureOnlyValidTypes(\SebastianBergmann\Type\Type ...$types): \void {}

    }
}

namespace SebastianBergmann\Type
{

    final class UnknownType extends \SebastianBergmann\Type\Type
    {
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function asString(): string {}

        /**
         * @deprecated
         *
         * @codeCoverageIgnore
         */
        public function getReturnTypeDeclaration(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann\Type
{

    final class VoidType extends \SebastianBergmann\Type\Type
    {
        public function isAssignable(\SebastianBergmann\Type\Type $other): bool {}

        public function name(): string {}

        public function allowsNull(): bool {}

    }
}

namespace SebastianBergmann
{

    final class Version
    {
        /**
         * @var string
         */
        private $path;

        /**
         * @var string
         */
        private $release;

        /**
         * @var string
         */
        private $version;

        public function __construct(string $release, string $path) {}

        public function getVersion(): string {}

        /**
         * @return bool|string
         */
        private function getGitInformation(string $path) {}

    }
}

namespace Symfony\Polyfill\Ctype
{

    /**
     * Ctype implementation through regex.
     *
     * @internal
     *
     * @author Gert de Pagter <BackEndTea@gmail.com>
     */
    final class Ctype
    {
        /**
         * Returns TRUE if every character in text is either a letter or a digit, FALSE otherwise.
         *
         * @see https://php.net/ctype-alnum
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_alnum($text) {}

        /**
         * Returns TRUE if every character in text is a letter, FALSE otherwise.
         *
         * @see https://php.net/ctype-alpha
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_alpha($text) {}

        /**
         * Returns TRUE if every character in text is a control character from the current locale, FALSE otherwise.
         *
         * @see https://php.net/ctype-cntrl
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_cntrl($text) {}

        /**
         * Returns TRUE if every character in the string text is a decimal digit, FALSE otherwise.
         *
         * @see https://php.net/ctype-digit
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_digit($text) {}

        /**
         * Returns TRUE if every character in text is printable and actually creates visible output (no white space), FALSE otherwise.
         *
         * @see https://php.net/ctype-graph
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_graph($text) {}

        /**
         * Returns TRUE if every character in text is a lowercase letter.
         *
         * @see https://php.net/ctype-lower
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_lower($text) {}

        /**
         * Returns TRUE if every character in text will actually create output (including blanks). Returns FALSE if text contains control characters or characters that do not have any output or control function at all.
         *
         * @see https://php.net/ctype-print
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_print($text) {}

        /**
         * Returns TRUE if every character in text is printable, but neither letter, digit or blank, FALSE otherwise.
         *
         * @see https://php.net/ctype-punct
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_punct($text) {}

        /**
         * Returns TRUE if every character in text creates some sort of white space, FALSE otherwise. Besides the blank character this also includes tab, vertical tab, line feed, carriage return and form feed characters.
         *
         * @see https://php.net/ctype-space
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_space($text) {}

        /**
         * Returns TRUE if every character in text is an uppercase letter.
         *
         * @see https://php.net/ctype-upper
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_upper($text) {}

        /**
         * Returns TRUE if every character in text is a hexadecimal 'digit', that is a decimal digit or a character from [A-Fa-f] , FALSE otherwise.
         *
         * @see https://php.net/ctype-xdigit
         *
         * @param string|int $text
         *
         * @return bool
         */
        public static function ctype_xdigit($text) {}

        /**
         * Converts integers to their char versions according to normal ctype behaviour, if needed.
         *
         * If an integer between -128 and 255 inclusive is provided,
         * it is interpreted as the ASCII value of a single character
         * (negative values have 256 added in order to allow characters in the Extended ASCII range).
         * Any other integer is interpreted as a string containing the decimal digits of the integer.
         *
         * @param string|int $int
         *
         * @return mixed
         */
        private static function convert_int_to_char_for_ctype($int) {}

    }
}

namespace TheSeer\Tokenizer
{

    class Exception extends \Exception
    {
    }
}

namespace TheSeer\Tokenizer
{

    class NamespaceUri
    {
        /** @var string */
        private $value;

        public function __construct(string $value) {}

        public function asString(): string {}

        private function ensureValidUri($value): \void {}

    }
}

namespace TheSeer\Tokenizer
{

    class NamespaceUriException extends \TheSeer\Tokenizer\Exception
    {
    }
}

namespace TheSeer\Tokenizer
{

    class Token
    {
        /** @var int */
        private $line;

        /** @var string */
        private $name;

        /** @var string */
        private $value;

        /**
         * Token constructor.
         */
        public function __construct(int $line, string $name, string $value) {}

        public function getLine(): int {}

        public function getName(): string {}

        public function getValue(): string {}

    }
}

namespace TheSeer\Tokenizer
{

    class TokenCollection
    {
        /** @var Token[] */
        private $tokens = [/** value is missing */];

        /** @var int */
        private $pos;

        public function addToken(\TheSeer\Tokenizer\Token $token): \void {}

        public function current(): \TheSeer\Tokenizer\Token {}

        public function key(): int {}

        public function next(): \void {}

        public function valid(): bool {}

        public function rewind(): \void {}

        public function count(): int {}

        public function offsetExists($offset): bool {}

        /**
         * @throws TokenCollectionException
         */
        public function offsetGet($offset): \TheSeer\Tokenizer\Token {}

        /**
         * @param Token $value
         *
         * @throws TokenCollectionException
         */
        public function offsetSet($offset, $value): \void {}

        public function offsetUnset($offset): \void {}

    }
}

namespace TheSeer\Tokenizer
{

    class TokenCollectionException extends \TheSeer\Tokenizer\Exception
    {
    }
}

namespace TheSeer\Tokenizer
{

    class Tokenizer
    {
        /**
         * Token Map for "non-tokens"
         *
         * @var array
         */
        private $map = [/** value is missing */];

        public function parse(string $source): \TheSeer\Tokenizer\TokenCollection {}

        private function fillBlanks(\TheSeer\Tokenizer\TokenCollection $tokens, int $maxLine): \TheSeer\Tokenizer\TokenCollection {}

    }
}

namespace TheSeer\Tokenizer
{
    use DOMDocument;

    class XMLSerializer
    {
        /** @var \XMLWriter */
        private $writer;

        /** @var Token */
        private $previousToken;

        /** @var NamespaceUri */
        private $xmlns;

        /**
         * XMLSerializer constructor.
         *
         * @param NamespaceUri $xmlns
         */
        public function __construct(?\TheSeer\Tokenizer\NamespaceUri $xmlns = null) {}

        public function toDom(\TheSeer\Tokenizer\TokenCollection $tokens): \DOMDocument {}

        public function toXML(\TheSeer\Tokenizer\TokenCollection $tokens): string {}

        private function addToken(\TheSeer\Tokenizer\Token $token): \void {}

    }
}

namespace Webmozart\Assert
{
    use ArrayAccess;
    use BadMethodCallException;
    use Closure;
    use Countable;
    use DateTime;
    use DateTimeImmutable;
    use Exception;
    use InvalidArgumentException;
    use ResourceBundle;
    use SimpleXMLElement;
    use Throwable;
    use Traversable;

    /**
     * Efficient assertions to validate the input/output of your methods.
     *
     * @mixin Mixin
     *
     * @since  1.0
     *
     * @author Bernhard Schussek <bschussek@gmail.com>
     */
    class Assert
    {
        /**
         * @psalm-pure
         * @psalm-assert string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function string($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert non-empty-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function stringNotEmpty($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function integer($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function integerish($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert float $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function float($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function numeric($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function natural($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert bool $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function boolean($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert scalar $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function scalar($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert object $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function object($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert resource $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function resource($value, $type = null, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert callable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isCallable($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert array $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isArray($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert iterable $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isTraversable($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert array|ArrayAccess $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isArrayAccessible($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert countable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isCountable($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert iterable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isIterable($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isInstanceOf($value, $class, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert !ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function notInstanceOf($value, $class, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function isInstanceOfAny($value, array $classes, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType|class-string<ExpectedType> $value
         *
         * @param object|string $value
         * @param string        $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isAOf($value, $class, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         * @psalm-assert !UnexpectedType $value
         * @psalm-assert !class-string<UnexpectedType> $value
         *
         * @param object|string $value
         * @param string        $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNotA($value, $class, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param object|string $value
         * @param string[]      $classes
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isAnyOf($value, array $classes, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isEmpty($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert !empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEmpty($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function null($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert !null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notNull($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert true $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function true($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert false $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function false($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert !false $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notFalse($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ip($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ipv4($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ipv6($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function email($value, $message = '') {}

        /**
         * Does non strict comparisons on the items, so ['3', 3] will not pass the assertion.
         *
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function uniqueValues(array $values, $message = '') {}

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function eq($value, $expect, $message = '') {}

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEq($value, $expect, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function same($value, $expect, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notSame($value, $expect, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function greaterThan($value, $limit, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function greaterThanEq($value, $limit, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lessThan($value, $limit, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lessThanEq($value, $limit, $message = '') {}

        /**
         * Inclusive range, so Assert::(3, 3, 5) passes.
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function range($value, $min, $max, $message = '') {}

        /**
         * A more human-readable alias of Assert::inArray().
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function oneOf($value, array $values, $message = '') {}

        /**
         * Does strict comparison, so Assert::inArray(3, ['3']) does not pass the assertion.
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function inArray($value, array $values, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $subString
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function contains($value, $subString, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $subString
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notContains($value, $subString, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notWhitespaceOnly($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $prefix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function startsWith($value, $prefix, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $prefix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notStartsWith($value, $prefix, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function startsWithLetter($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $suffix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function endsWith($value, $suffix, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $suffix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEndsWith($value, $suffix, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $pattern
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function regex($value, $pattern, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $pattern
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notRegex($value, $pattern, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function unicodeLetters($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function alpha($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function digits($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function alnum($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert lowercase-string $value
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lower($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert !lowercase-string $value
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function upper($value, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param int    $length
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function length($value, $length, $message = '') {}

        /**
         * Inclusive min.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $min
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function minLength($value, $min, $message = '') {}

        /**
         * Inclusive max.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $max
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function maxLength($value, $max, $message = '') {}

        /**
         * Inclusive , so Assert::lengthBetween('asd', 3, 5); passes the assertion.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $min
         * @param int|float $max
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function lengthBetween($value, $min, $max, $message = '') {}

        /**
         * Will also pass if $value is a directory, use Assert::file() instead if you need to be sure it is a file.
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function fileExists($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function file($value, $message = '') {}

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function directory($value, $message = '') {}

        /**
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function readable($value, $message = '') {}

        /**
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function writable($value, $message = '') {}

        /**
         * @psalm-assert class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function classExists($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert class-string<ExpectedType>|ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function subclassOf($value, $class, $message = '') {}

        /**
         * @psalm-assert class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function interfaceExists($value, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert class-string<ExpectedType> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function implementsInterface($value, $interface, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $property
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function propertyExists($classOrObject, $property, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $property
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function propertyNotExists($classOrObject, $property, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $method
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function methodExists($classOrObject, $method, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $method
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function methodNotExists($classOrObject, $method, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param array      $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function keyExists($array, $key, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param array      $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function keyNotExists($array, $key, $message = '') {}

        /**
         * Checks if a value is a valid array key (int or string).
         *
         * @psalm-pure
         * @psalm-assert array-key $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function validArrayKey($value, $message = '') {}

        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int             $number
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function count($array, $number, $message = '') {}

        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $min
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function minCount($array, $min, $message = '') {}

        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $max
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function maxCount($array, $max, $message = '') {}

        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $min
         * @param int|float       $max
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function countBetween($array, $min, $max, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isList($array, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-assert non-empty-list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNonEmptyList($array, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T> $array
         * @psalm-assert array<string, T> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isMap($array, $message = '') {}

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T> $array
         * @psalm-assert array<string, T> $array
         * @psalm-assert !empty $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNonEmptyMap($array, $message = '') {}

        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function uuid($value, $message = '') {}

        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param Closure $expression
         * @param string  $class
         * @param string  $message
         *
         * @throws InvalidArgumentException
         */
        public static function throws(\Closure $expression, $class = 'Exception', $message = '') {}

        /**
         * @throws BadMethodCallException
         */
        public static function __callStatic($name, $arguments) {}

        /**
         * @param mixed $value
         *
         * @return string
         */
        protected static function valueToString($value) {}

        /**
         * @param mixed $value
         *
         * @return string
         */
        protected static function typeToString($value) {}

        protected static function strlen($value) {}

        /**
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @psalm-pure this method is not supposed to perform side-effects
         */
        protected static function reportInvalidArgument($message) {}

        private function __construct() {}

    }
}

namespace Webmozart\Assert
{
    use ArrayAccess;
    use Closure;
    use Countable;
    use InvalidArgumentException;
    use Throwable;

    interface Mixin
    {
        /**
         * @psalm-pure
         * @psalm-assert null|string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrString($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allString($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|non-empty-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrStringNotEmpty($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allStringNotEmpty($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrInteger($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<int> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allInteger($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIntegerish($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIntegerish($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|float $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrFloat($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<float> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allFloat($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNumeric($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNumeric($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNatural($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<int> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNatural($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|bool $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrBoolean($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<bool> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allBoolean($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|scalar $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrScalar($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<scalar> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allScalar($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|object $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrObject($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<object> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allObject($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|resource $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrResource($value, $type = null, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<resource> $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function allResource($value, $type = null, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|callable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsCallable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<callable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsCallable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|array $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsArray($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<array> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsArray($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|iterable $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsTraversable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable> $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsTraversable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|array|ArrayAccess $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsArrayAccessible($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<array|ArrayAccess> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsArrayAccessible($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|countable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsCountable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<countable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsCountable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|iterable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsIterable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsIterable($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert null|ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsInstanceOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsInstanceOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotInstanceOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotInstanceOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsInstanceOfAny($value, $classes, $message = '');

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsInstanceOfAny($value, $classes, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert null|ExpectedType|class-string<ExpectedType> $value
         *
         * @param null|object|string $value
         * @param string             $class
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsAOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType|class-string<ExpectedType>> $value
         *
         * @param iterable<object|string> $value
         * @param string                  $class
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsAOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         *
         * @param null|object|string $value
         * @param string             $class
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsNotA($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         *
         * @param iterable<object|string> $value
         * @param string                  $class
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsNotA($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param null|object|string $value
         * @param string[]           $classes
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsAnyOf($value, $classes, $message = '');

        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param iterable<object|string> $value
         * @param string[]                $classes
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsAnyOf($value, $classes, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsEmpty($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<empty> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsEmpty($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotEmpty($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotEmpty($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNull($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotNull($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|true $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrTrue($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<true> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allTrue($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|false $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrFalse($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<false> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allFalse($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotFalse($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotFalse($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIp($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIp($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIpv4($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIpv4($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIpv6($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIpv6($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrEmail($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allEmail($value, $message = '');

        /**
         * @param null|array $values
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrUniqueValues($values, $message = '');

        /**
         * @param iterable<array> $values
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function allUniqueValues($values, $message = '');

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrEq($value, $expect, $message = '');

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allEq($value, $expect, $message = '');

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotEq($value, $expect, $message = '');

        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotEq($value, $expect, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrSame($value, $expect, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allSame($value, $expect, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotSame($value, $expect, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotSame($value, $expect, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrGreaterThan($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allGreaterThan($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrGreaterThanEq($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allGreaterThanEq($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrLessThan($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allLessThan($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrLessThanEq($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allLessThanEq($value, $limit, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrRange($value, $min, $max, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allRange($value, $min, $max, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrOneOf($value, $values, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allOneOf($value, $values, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrInArray($value, $values, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allInArray($value, $values, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $subString
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrContains($value, $subString, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $subString
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allContains($value, $subString, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $subString
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotContains($value, $subString, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $subString
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotContains($value, $subString, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotWhitespaceOnly($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotWhitespaceOnly($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $prefix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrStartsWith($value, $prefix, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $prefix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allStartsWith($value, $prefix, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $prefix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotStartsWith($value, $prefix, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $prefix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotStartsWith($value, $prefix, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrStartsWithLetter($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allStartsWithLetter($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $suffix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrEndsWith($value, $suffix, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $suffix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allEndsWith($value, $suffix, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $suffix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotEndsWith($value, $suffix, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $suffix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotEndsWith($value, $suffix, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $pattern
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrRegex($value, $pattern, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $pattern
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allRegex($value, $pattern, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $pattern
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrNotRegex($value, $pattern, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $pattern
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allNotRegex($value, $pattern, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrUnicodeLetters($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allUnicodeLetters($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrAlpha($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allAlpha($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrDigits($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allDigits($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrAlnum($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allAlnum($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|lowercase-string $value
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrLower($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<lowercase-string> $value
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allLower($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrUpper($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allUpper($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param int         $length
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrLength($value, $length, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int              $length
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allLength($value, $length, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param int|float   $min
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMinLength($value, $min, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $min
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMinLength($value, $min, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param int|float   $max
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMaxLength($value, $max, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $max
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMaxLength($value, $max, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param int|float   $min
         * @param int|float   $max
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrLengthBetween($value, $min, $max, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $min
         * @param int|float        $max
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allLengthBetween($value, $min, $max, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrFileExists($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allFileExists($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrFile($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allFile($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrDirectory($value, $message = '');

        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allDirectory($value, $message = '');

        /**
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrReadable($value, $message = '');

        /**
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allReadable($value, $message = '');

        /**
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrWritable($value, $message = '');

        /**
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allWritable($value, $message = '');

        /**
         * @psalm-assert null|class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrClassExists($value, $message = '');

        /**
         * @psalm-assert iterable<class-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allClassExists($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert null|class-string<ExpectedType>|ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrSubclassOf($value, $class, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<class-string<ExpectedType>|ExpectedType> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function allSubclassOf($value, $class, $message = '');

        /**
         * @psalm-assert null|class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrInterfaceExists($value, $message = '');

        /**
         * @psalm-assert iterable<class-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allInterfaceExists($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert null|class-string<ExpectedType> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrImplementsInterface($value, $interface, $message = '');

        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert iterable<class-string<ExpectedType>> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allImplementsInterface($value, $interface, $message = '');

        /**
         * @psalm-pure
         * @psalm-param null|class-string|object $classOrObject
         *
         * @param null|string|object $classOrObject
         * @param mixed              $property
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrPropertyExists($classOrObject, $property, $message = '');

        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $property
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allPropertyExists($classOrObject, $property, $message = '');

        /**
         * @psalm-pure
         * @psalm-param null|class-string|object $classOrObject
         *
         * @param null|string|object $classOrObject
         * @param mixed              $property
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrPropertyNotExists($classOrObject, $property, $message = '');

        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $property
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allPropertyNotExists($classOrObject, $property, $message = '');

        /**
         * @psalm-pure
         * @psalm-param null|class-string|object $classOrObject
         *
         * @param null|string|object $classOrObject
         * @param mixed              $method
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMethodExists($classOrObject, $method, $message = '');

        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $method
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMethodExists($classOrObject, $method, $message = '');

        /**
         * @psalm-pure
         * @psalm-param null|class-string|object $classOrObject
         *
         * @param null|string|object $classOrObject
         * @param mixed              $method
         * @param string             $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMethodNotExists($classOrObject, $method, $message = '');

        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $method
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMethodNotExists($classOrObject, $method, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|array $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrKeyExists($array, $key, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<array> $array
         * @param string|int      $key
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function allKeyExists($array, $key, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|array $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrKeyNotExists($array, $key, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<array> $array
         * @param string|int      $key
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function allKeyNotExists($array, $key, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|array-key $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrValidArrayKey($value, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<array-key> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allValidArrayKey($value, $message = '');

        /**
         * @param null|Countable|array $array
         * @param int                  $number
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrCount($array, $number, $message = '');

        /**
         * @param iterable<Countable|array> $array
         * @param int                       $number
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         */
        public static function allCount($array, $number, $message = '');

        /**
         * @param null|Countable|array $array
         * @param int|float            $min
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMinCount($array, $min, $message = '');

        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $min
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMinCount($array, $min, $message = '');

        /**
         * @param null|Countable|array $array
         * @param int|float            $max
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrMaxCount($array, $max, $message = '');

        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $max
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         */
        public static function allMaxCount($array, $max, $message = '');

        /**
         * @param null|Countable|array $array
         * @param int|float            $min
         * @param int|float            $max
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrCountBetween($array, $min, $max, $message = '');

        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $min
         * @param int|float                 $max
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         */
        public static function allCountBetween($array, $min, $max, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsList($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<list> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsList($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert null|non-empty-list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsNonEmptyList($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-list> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsNonEmptyList($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param null|mixed|array<T> $array
         * @psalm-assert null|array<string, T> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsMap($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>> $array
         * @psalm-assert iterable<array<string, T>> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsMap($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param null|mixed|array<T> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrIsNonEmptyMap($array, $message = '');

        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function allIsNonEmptyMap($array, $message = '');

        /**
         * @psalm-pure
         *
         * @param null|string $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrUuid($value, $message = '');

        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         */
        public static function allUuid($value, $message = '');

        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param null|Closure $expression
         * @param string       $class
         * @param string       $message
         *
         * @throws InvalidArgumentException
         */
        public static function nullOrThrows($expression, $class = 'Exception', $message = '');

        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param iterable<Closure> $expression
         * @param string            $class
         * @param string            $message
         *
         * @throws InvalidArgumentException
         */
        public static function allThrows($expression, $class = 'Exception', $message = '');

    }
}

namespace Composer\Autoload
{

    /**
     * Scope isolated include.
     *
     * Prevents access to $this/self from included files.
     */
    function Composer\Autoload\includeFile($file) {}

}

namespace
{

    function composerRequiredd83a7ee27459590b297489146651a64($fileIdentifier, $file) {}

}

namespace
{

    function resolveNodes($code) {}

}

namespace
{

    function resolveMacros($code) {}

}

namespace
{

    function assertArgs($num, $args, $name) {}

}

namespace
{

    function resolveStackAccess($code) {}

}

namespace
{

    function removeTrailingWhitespace($code) {}

}

namespace
{

    function ensureDirExists($dir) {}

}

namespace
{

    function execCmd($cmd) {}

}

namespace
{

    function regex($regex) {}

}

namespace
{

    function magicSplit($regex, $string) {}

}

